<?xml version="1.0" encoding="UTF-8" standalone="no"?><!--

  Licensed to the Apache Software Foundation (ASF)

      http://www.apache.org/licenses/LICENSE-2.0

  This is an automatically generated file. DO NOT EDIT.
  See the files in the ../../../book/ directory instead.

--><!DOCTYPE html SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">

<head>
<title>Introduction à Apache SIS</title>
<meta charset="UTF-8"/>
<link href="../book.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p style="margin-top: 30pt"><span style="font-size: 30pt; font-weight: 900">Introduction à Apache SIS™</span></p>
<p style="margin-bottom: 20pt">(<a href="../en/developer-guide.html">English</a> | Français)</p>
<p><i>Martin Desruisseaux</i><br/>
<i>Christina Hough</i> (pour la traduction anglaise)</p>
<p>Ce document est distribué sous licence Apache 2.</p>
<hr/>

<p><b style="font-size: 20pt">Table des matières</b></p>
<nav>
<ul class="toc">
<li><a href="#Standards">Standards et normes</a><ul>
<li><a href="#ConceptualModels">Sources des modèles conceptuels de Apache SIS</a></li>
<li><a href="#GeoAPI">Des modèles conceptuels vers des interfaces Java: GeoAPI</a><ul>
<li><a href="#GeoAPI-implementation">Implémentations fournies par Apache SIS</a></li></ul></li>
<li><a href="#AboutBook">Conventions utilisées dans ce guide</a><ul>
<li><a href="#ChosenTerms">Choix des termes</a></li></ul></li></ul></li>
<li><a href="#DataAccess">Accès aux données géospatiales</a><ul>
<li><a href="#GetMetadataElement">Parcourir les méta-données</a></li></ul></li>
<li><a href="#Coverage">Couvertures de données (Coverages)</a></li>
<li><a href="#Geometry">Géométries</a><ul>
<li><a href="#GeometryBase">Classes de base</a><ul>
<li><a href="#DirectPosition">Points et positions directes</a></li>
<li><a href="#Envelope">Enveloppes</a><ul>
<li><a href="#AntiMeridian">Enveloppes traversant l’antiméridien</a></li></ul></li></ul></li></ul></li>
<li><a href="#Referencing">Systèmes de références spatiales</a><ul>
<li><a href="#ComponentsOfCRS">Composantes d’un système de références par coordonnées</a><ul>
<li><a href="#Ellipsoid">Géoïde et ellipsoïde</a></li>
<li><a href="#GeodeticDatum">Référentiel géodésique</a></li>
<li><a href="#CoordinateSystem">Systèmes de coordonnées</a><ul>
<li><a href="#AxisOrder">Ordre des axes</a></li></ul></li>
<li><a href="#GeographicCRS">Systèmes géographiques</a><ul>
<li><a href="#GeographicWKT">Format Well-Known Text</a></li></ul></li>
<li><a href="#ProjectedCRS">Projections cartographiques</a><ul>
<li><a href="#ProjectedWKT">Format Well-Known Text</a></li></ul></li>
<li><a href="#CompoundCRS">Dimensions verticales et temporelles</a><ul>
<li><a href="#CompoundWKT">Format Well-Known Text</a></li></ul></li></ul></li>
<li><a href="#GetCRS">Obtention d’un système de référence spatial</a><ul>
<li><a href="#CRSAuthorityFactory">Systèmes prédéfinis par des autorités</a></li>
<li><a href="#CRSParsing">Lecture d’une définition au format GML ou WKT</a></li>
<li><a href="#CRSFactory">Construction programmatique explicite</a></li>
<li><a href="#CRS_UserCode">Ajout de définitions</a></li></ul></li>
<li><a href="#CoordinateOperations">Opérations sur les coordonnées</a><ul>
<li><a href="#MathTransform">Exécution de opérations</a></li>
<li><a href="#TransformDerivative">Dérivées partielles des opérations</a><ul>
<li><a href="#DerivativeAndEnvelope">Utilité des dérivées pour la reprojection d’enveloppes</a></li>
<li><a href="#DerivativeAndRaster">Utilité des dérivées pour la reprojection d’images</a></li>
<li><a href="#GetDerivative">Obtention de la dérivée en un point</a></li></ul></li></ul></li>
<li><a href="#Formats">Formats de stockage des données</a></li>
<li><a href="#XML-ISO">Représentation des objets en XML</a><ul>
<li><a href="#XML-ISO-19115">Représentation des méta-données selon ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification d’instances déjà définies</a></li>
<li><a href="#nilReason">Représentation de valeurs manquantes</a></li></ul></li></ul></li></ul></li>
<li><a href="#Utilities">Classes et méthodes utilitaires</a><ul>
<li><a href="#ComparisonModes">Modes de comparaisons des objets</a></li>
<li><a href="#ObjectConverters">Convertisseurs d’objets</a></li>
<li><a href="#Internationalization">Internationalisation</a><ul>
<li><a href="#LocalizedString">Chaînes de caractères distinctes pour chaque conventions locales</a></li>
<li><a href="#InternationalString">Instance unique pour toutes les conventions locales</a></li>
<li><a href="#Locale.ROOT">Convention Locale.ROOT</a></li>
<li><a href="#UnicodePoint">Traitement des caractères</a><ul>
<li><a href="#Whitespaces">Interprétation des espaces blancs</a></li></ul></li></ul></li></ul></li>
<li><a href="#GeoAPI-details">Relation entre GeoAPI et les standards</a><ul>
<li><a href="#GeoAPI-modules">Les modules de GeoAPI</a></li>
<li><a href="#SpecificationToInterfaces">Des spécifications de l’OGC aux interfaces Java</a><ul>
<li><a href="#UML-annotation">Correspondances explicites entre GeoAPI et les spécifications abstraites</a></li>
<li><a href="#MappingToJDK">Correspondances implicites avec le JDK standard</a></li></ul></li>
<li><a href="#ReduceDependency">Réduire la dépendance directe envers Apache SIS</a><ul>
<li><a href="#UML-annotation-indep">Correspondances entre GeoAPI et les spécifications abstraites</a></li>
<li><a href="#ServiceLoader">Obtenir une implémentation des interfaces de GeoAPI</a><ul>
<li><a href="#GeoAPI-simple">Fournir sa propre implémentation</a></li></ul></li></ul></li></ul></li>
<li><a href="#Tests">Les suites de tests</a><ul>
<li><a href="#GeoAPI-conformance">Conformance avec GeoAPI</a><ul>
<li><a href="#GeoAPI-validators">Validations des instances</a></li>
<li><a href="#GeoAPI-tests">Exécution des tests pré-définis</a></li></ul></li></ul></li>
<li><a href="#DesignNotes">Notes de design</a><ul>
<li><a href="#AffineTransform">Utilisation des transformations affines</a><ul>
<li><a href="#AffineTransformAPI">Intégration avec les bibliothèques graphiques</a></li></ul></li>
<li><a href="#MatrixLibrary">Particularités d’une bibliothèque de calculs matriciels pour un SIG</a><ul>
<li><a href="#NonSquareMatrix">Que faire des matrices qui ne sont pas carrées (et pourquoi)</a></li>
<li><a href="#MatrixLibrarySummary">La bibliothèque matricielle de Apache SIS</a></li></ul></li></ul></li>
</ul>
</nav>

<main>












<section>
<header>
<h1 id="Standards"><span class="section-number">1.</span> Standards et normes</h1>
<nav><div class="chapter-links"><div class="next-chapter"><a href="#DataAccess">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#ConceptualModels">Sources des modèles conceptuels de Apache SIS</a></li>
<li><a href="#GeoAPI">Des modèles conceptuels vers des interfaces Java: GeoAPI</a><ul>
<li><a href="#GeoAPI-implementation">Implémentations fournies par Apache SIS</a></li></ul></li>
<li><a href="#AboutBook">Conventions utilisées dans ce guide</a><ul>
<li><a href="#ChosenTerms">Choix des termes</a></li></ul></li></ul></nav>
<p>
Une communauté d’informations géospatiales est un ensemble de systèmes ou d’individus capables d’échanger
leurs données géospatiales grâce à des définitions et des standards communs ainsi qu’une reconnaissance réciproque.
Comme il existe une multitude de façons de représenter des informations géospatiales,
chaque communauté est amenée à les structurer en fonction de ses centres d’intérêts.
Cette diversité complique la tâche des utilisateurs de systèmes d’information géographiques (<abbr>SIG</abbr>)
en les plaçant devant une variété apparemment chaotique de formats et de structures de données.
Les caractéristiques de ces structures varient en fonction des phénomènes observés et des méthodes de mesure,
ainsi que des habitudes des organisations produisant les données.
Une telle variété agit comme un frein aux études qui requièrent des combinaisons de données hétérogènes,
surtout lorsqu’elles proviennent de communautés traditionnellement distinctes.
Par exemple, un chercheur étudiant le choléra peut s’intéresser aux populations de crevettes comme vecteur de propagation de la maladie.
Mais les médecins et les océanographes n’ayant pas forcement l’habitude de partager leurs travaux,
les participants à une telle étude peuvent être limités par les efforts qu’ils sont disposés à fournir pour convertir les données.
</p><p>
Nous ne pouvons pas imposer un format uniforme à l’ensemble des données, car la diversité des formats tient
à des facteurs tels que les contraintes des appareils de mesure et la distribution statistique des valeurs.
Une solution plus flexible consiste à assurer l’interopérabilité des données à travers une interface de programmation
(<abbr title="Application Programming Interface">API</abbr>) commune.
Cette <abbr>API</abbr> n’est pas forcement définie dans un langage de programmation;
la tendance actuelle est plutôt de définir des conventions utilisant les protocoles web existants,
que l’on peut transposer dans des langages de programmation.
Mais pour que cette démarche puisse être pérennisée, l’<abbr>API</abbr> doit être largement accepté par des développeurs indépendants.
Autrement dit, l’<abbr>API</abbr> doit s’approcher autant que possible des standards industriels.
</p><p>
Les accès aux bases de données relationnelles sont un exemple de tâche ayant bénéficié d’une standardisation relativement bien réussie.
L’industrie a établie un langage commun — le standard <abbr title="Structured Query Language">SQL</abbr> — que les concepteurs du Java
ont enrobé dans des interfaces de programmation formant le standard <abbr title="Java DataBase Connectivity">JDBC</abbr>.
Ces interfaces sont aujourd’hui implementées par de nombreux logiciels libres et commerciaux.
Comme pour les bases de données, des méthodes d’accès aux informations géographiques ont été standardisées.
Mais les efforts en ce sens sont plus récents et leurs intégrations dans les logiciels, surtout les plus anciens,
sont incomplètes et pas toujours cohérentes.
Au moment d’écrire ces lignes, aucun produit de notre connaissance n’implémente la totalité des spécifications.
Mais on trouve de nombreuses implémentations couvrant un spectre plus ou moins large.
La bibliothèque Apache <abbr>SIS</abbr>™ décrite dans ce document en est une.
</p><p>
Apache <abbr title="Spatial Information System">SIS</abbr> se caractérise par un effort soutenu de respect des standards.
De manière générale, le respect des standards exige un effort plus grand que ce qu’aurait requis un développement isolé,
mais se rentabilise par un double avantage: en plus d’accroître l’interopérabilité des données avec celles des projets externes,
il nous indique aussi une voie robuste à suivre pour l’élaboration du modèle conceptuel qui sera reflété par l’<abbr>API</abbr>.
En effet, les groupes d’experts qui conçoivent les standards anticipent des difficultés qui échappent parfois à l’ingénieur en début de projet,
mais qui risquent de le rattraper avant la fin.
</p>






<section>
<header>
<h2 id="ConceptualModels"><span class="section-number">1.1.</span> Sources des modèles conceptuels de Apache SIS</h2>
</header>
<p>
La majorité des standards utilisés par Apache <abbr title="Spatial Information System">SIS</abbr> ont été élaborés
par le <a href="http://www.opengeospatial.org">consortium <i>Open Geospatial</i></a> (<abbr>OGC</abbr>),
parfois en collaboration avec l’<a href="http://www.iso.org">organisation internationale de normalisation</a> (<abbr>ISO</abbr>).
Certains standards de l’<abbr>ISO</abbr> deviennent eux-mêmes des standards Européens via la
<a href="http://inspire.jrc.ec.europa.eu">directive INSPIRE</a>, ou des standards français via l’<abbr>AFNOR</abbr>.
Ces standards offrent deux technologies clés:
</p>
<ul>
<li>
Permettre à une communauté d’annoncer leurs informations,
de manière à ce que des individus ou des systèmes en dehors de cette communauté puissent les découvrir.
</li>
<li>
Transférer des informations d’une communauté vers une autre en préservant leurs sémantiques,
même si les deux communautés utilisent des représentations internes très différentes.
</li>
</ul>
<p>
Ces standards sont fournis gratuitement à la communauté internationale sous la forme de
<a href="http://www.opengeospatial.org/standards/is">spécifications (fichiers <abbr title="Portable Document Format">PDF</abbr>)</a> ou de
<a href="http://schemas.opengis.net/gml/3.3/">schémas (fichiers <abbr title="XML Schema Definition">XSD</abbr>)</a>.
Les organismes de normalisation ne fabriquent pas de logiciel; pour obtenir une implémentation de ces spécifications,
les utilisateurs doivent choisir un des produits conformes disponibles sur le marché ou développer leur propres solutions.
C’est le respect volontaire de ces spécifications qui permet à des communautés à priori indépendantes d’échanger
plus facilement des informations géographiques.
</p>



<details>
<summary>Pour en savoir plus sur le processus de standardisation</summary>
<article id="OGC-process">
<header>
<h2>Processus de standardisation à l’<abbr>OGC</abbr></h2>
</header>
<p>
Les travaux de l’<abbr title="Open Geospatial Consortium">OGC</abbr> se font par courriers électroniques,
par conférences téléphoniques et par <a href="http://www.opengeospatial.org/event?category=ogctcpc">réunions réelles</a>.
L’<abbr>OGC</abbr> organise quatre réunions par années, chacune d’une durée de cinq jours,
hébergées par des organisations membres sponsorisant l’événement (compagnies, universités, centres de recherches, <i>etc.</i>).
Le continent hôte alterne entre l’Europe et l’Amérique du Nord, avec une présence croissante en Asie depuis 2011.
Ces réunions reçoivent habituellement entre 50 et 100 participants parmi les centaines de membres de l’<abbr>OGC</abbr>.
Certains participants sont présents à quasiment toutes les réunions et constituent des piliers de l’organisation.
Les réunions de l’<abbr>OGC</abbr> offrent des opportunités d’échanges avec des membres d’horizons diverses.
</p><p>
La création d’un standard <abbr>OGC</abbr> commence par le regroupement d’organisations ou d’individus constatant un intérêt commun pour une problématique.
Un groupe de travail est proposé sous l’appellation de <i>Domain Working Group</i> (<abbr>DWG</abbr>) ou <i>Standard Working Group</i> (<abbr>SWG</abbr>).
Les <abbr>DWG</abbr> sont ouverts à tout membre de l’<abbr>OGC</abbr>,
tandis que les <abbr>SWG</abbr> nécessitent de la part des participants un engagement à ne pas entraver
la diffusion du standard par des réclamations de propriétés intellectuelles.
</p>

<h3 id="OGC-SWG">Fonctionnement des groupes de travail (<abbr>SWG</abbr>)</h3>
<p>
Pour être accepté, un projet de standardisation doit être supporté par un nombre minimal de membres appartement à des organisations distinctes.
Ces membres fondateurs rédigent une charte définissant les objectifs du <abbr>SWG</abbr>,
qui doit être approuvée par le comité technique de l’<abbr title="Open Geospatial Consortium">OGC</abbr>.
Chaque membre fondateur est doté d’un droit de vote, dans les limites d’un membre votant par organisation.
Tout nouveau membre qui souhaite joindre le <abbr>SWG</abbr> après sa création se verra attribué un rôle d’observateur,
avec attribution sur demande d’un droit de vote après quelques mois d’observation.
</p><p>
Un <abbr>SWG</abbr> peut contenir plusieurs dizaines de membres,
mais les volontaires effectuant l’essentiel du travail sont habituellement moins nombreux.
Leurs propositions sont soumises à l’ensemble des membres du groupe, qui peuvent les accepter par consentement unanime.
Les objections, s’il y en a, doivent être argumentées et une alternative proposée.
Les <abbr>SWG</abbr> essaient généralement de débattre d’un problème jusqu’à ce qu’un consensus se forme
plutôt que d’avancer malgré des votes négatifs, même s’ils sont minoritaires.
Les décisions du groupes sont alors intégrées dans la spécification par un membre assumant le rôle d’éditeur.
</p><p>
Le groupe de travail doit autant que possible structurer la spécification sous forme d’un noyau autour duquel gravite diverses extensions.
Une suite de tests doit accompagner le standard, et permettre de classer les implémentations en fonction du niveau des tests passés.
Au moins une <i>implémentation de référence</i> passant les tests doit exister pour démontrer que le standard est utilisable.
</p><p>
Lorsque le standard est jugé prêt, le <abbr>SWG</abbr> vote une motion
proposant de le soumettre au vote des instances supérieures de l’<abbr>OGC</abbr>.
Cette procédure nécessite plusieurs mois.
Il existe une procédure plus rapide pour entériner des standards de fait, mais elle n’est appliquée qu’avec parcimonie.
</p>

<h3 id="OGC-OAB">Le conseil d’architecture (<abbr>OAB</abbr>) et le comité technique (<abbr>TC</abbr>)</h3>
<p>
Toute proposition de standard est d’abord examinée par le conseil d’architecture (<i><abbr title="Open Geospatial Consortium">OGC</abbr> Architecture Board</i> — <abbr>OAB</abbr>).
Ce conseil vérifie que le standard répond aux exigences de l’<abbr>OGC</abbr> sur la forme,
sur la modularisation, et en termes d’intégration avec les autres standards.
Si l’<abbr>OAB</abbr> donne son aval, le standard est alors soumis au vote des membres du comité technique (<abbr>TC</abbr>).
Ce comité regroupe les principaux membres de l’<abbr>OGC</abbr> qui sont seuls habilités à donner le vote final.
En cas d’approbation, le standard est diffusé publiquement pour commentaires pendant une période de quelques mois.
Au terme de cette période, le <abbr title="Standard Working Group">SWG</abbr> doit examiner et répondre à chacun des commentaires.
Les éventuelles modifications au standard sous soumises à l’<abbr>OAB</abbr>, puis le standard est définitivement publié.
Cette diffusion est alors annoncée par un communiqué de presse de l’<abbr>OGC</abbr>.
</p><p>
Certains membres de l’<abbr title="Open Geospatial Consortium">OGC</abbr> et du <abbr title="Technical Committe">TC</abbr>
assurent aussi la liaison avec l’organisation internationale de normalisation (<abbr title="International Organization for Standardization">ISO</abbr>).
La coopération entre les deux organismes va dans les deux sens: l’<abbr>OGC</abbr> adopte les standards <abbr>ISO</abbr> comme base sur
laquelle développer de nouveaux standards, et certains de ces nouveaux standards <abbr>OGC</abbr> deviennent des standards <abbr>ISO</abbr>.
</p>

<h3 id="OGC-RFC">Procédure de soumission de propositions de modifications</h3>
<p>
Tout utilisateur, qu’il soit membre ou non du consortium <i>Open Geospatial</i>, peut proposer des modifications à des standards <abbr title="Open Geospatial Consortium">OGC</abbr>.
Une liste des propositions actuelles de changements, ainsi qu’un formulaire permettant d’en soumettre de nouvelles,
sont <a href="http://www.opengeospatial.org/standards/cr">disponibles en ligne</a>.
Chaque proposition est revue par le <abbr title="Standard Working Group">SWG</abbr>.
</p><p>
Certains groupes de travail utilisent d’autres systèmes de soumission en parallèle, par exemple GitHub,
hébergés en dehors des structures de l’<abbr>OGC</abbr>.
</p>
</article>
</details>



<p>
Outre ces organisations formelles de normalisation, il existe aussi des organisations qui ne sont pas officiellement
dédiées à l’élaboration de normes mais dont les travaux ont été largement adoptés comme standards de fait.
En particulier, la base de données <a href="http://www.epsg.org">EPSG</a> fournit des codes numériques permettant d’identifier
facilement un système de référence des coordonnées parmi <a href="../../tables/CoordinateReferenceSystems.html">plusieurs milliers</a>.
Cette base de données est offerte par des compagnies pétrolières qui ont vu leur intérêt à ce que leurs prospections se fassent
bien à l’endroit voulu, sachant qu’elles ne contrôlent pas toujours la production des cartes sur lesquelles elles se positionnent.
D’autres exemples de standards de fait sont les formats
<a href="http://geotiff.osgeo.org">GeoTIFF</a> pour les données réparties sur une grille (les images), et
<a href="http://fr.wikipedia.org/wiki/Shapefile">Shapefile</a> pour les données vectorielles (les géométries).
</p><p>
Les standards <abbr>OGC</abbr> sont spécifiés dans plusieurs dizaines de documents.
Chaque document élabore un service, par exemple les transformations de coordonnées.
Le fonctionnement de chaque service est décrit par un ensemble de classes d’objets et leurs interactions.
Ces éléments sont illustrés par des diagrammes <abbr>UML</abbr> (<i>Unified Modeling Language</i>)
dans des spécifications dites « abstraites ».
Les <a href="http://www.opengeospatial.org/standards/as">spécifications abstraites</a> ne font référence à aucun langage informatique concret.
Leurs concepts peuvent se concrétiser dans un langage de programmation, une base de données ou un schéma <abbr>XML</abbr> de manière plus ou moins directe.
Il existe toutefois une part d’arbitraire dans la façon de concrétiser une spécification abstraite, étant donné que des ajustements sont souvent nécessaires
pour tenir compte des contraintes ou des conventions du langage ciblé.
Certaines structures de données n’existent que dans quelques langages, par exemple les unions qui existent en C/C++ mais pas en Java.
</p>



<details>
<summary>Pour en savoir plus sur les « spécifications d’implémentation »</summary>
<article id="implementation-standard">
<header>
<h2>Note historique</h2>
</header>
<p>
Au tournant du millénaire, les spécifications abstraites étaient explicitement concrétisées dans des <i>spécifications d’implémentations</i>.
Le terme « implémentation » était ici à prendre au sens de tout type d’interfaces (Java ou autres) dérivées des diagrammes
<abbr title="Unified Modeling Language">UML</abbr> — et non pas d’implémentations au sens du Java.
Des telles spécifications existaient pour les langages <abbr title="Structured Query Language">SQL</abbr>,
<abbr title="Common Object Request Broker Architecture">CORBA</abbr>, <abbr title="Component Object Model">COM</abbr> et Java.
Ces langages étant capables d’exécuter des procédures, les spécifications de cette époque définissaient
non seulement des structures de données, mais aussi des opérations s’appliquant sur ces structures.
</p><p>
Par la suite, l’engouement pour le « web 2.0 » a fait grimper l’intérêt pour le <abbr>XML</abbr> au détriment des autres langages.
Les anciennes spécifications d’implémentations ont été dépréciées, et les schémas <abbr title="XML Schema Definition">XSD</abbr>
sont devenus la principale concrétisation des spécifications abstraites.
Même la façon de concevoir les spécifications abstraites a évoluée: les opérations y sont plus rarement définies,
par conséquence ce qui reste ressemble davantage à des descriptions de schémas de base de données.
Certaines opérations qui étaient définies dans les anciennes normes apparaissent maintenant, sous une autre forme, dans les spécifications des services web.
Enfin le terme « spécification d’implémentation » a été abandonné, pour être englobé dans « standard <abbr title="Open Geospatial Consortium">OGC</abbr> ».
Mais malgré leur dépréciation, les <a href="http://www.opengeospatial.org/docs/retired">anciennes spécifications d’implémentation</a>
restent utiles aux programmes en langage Java car:
</p>
<ul>
<li>
Leurs modèles plus simples, appliqués aux mêmes concepts, aident à comprendre les nouvelles spécifications.
</li>
<li>
Ils définissent parfois des façons simples d’effectuer des tâches courantes
là où les nouvelles spécifications se limitent au cas général.
</li>
<li>
Les opérations étant plus souvent omises dans les nouvelles spécifications,
les anciennes spécifications restent un complément utile pour définir des <abbr title="Application Programming Interface">API</abbr>.
</li>
</ul>
<p>
Le projet Apache <abbr title="Spatial Information System">SIS</abbr> se base sur les spécifications les plus récentes,
tout en puisant dans les archives de l’<abbr title="Open Geospatial Consortium">OGC</abbr>
pour compléter certains standards abstraits ou les rendre un peu plus facile d’utilisation.
Certaines anciennes définitions sont conservées comme « méthodes de commodités »,
n’apportant pas toujours de nouvelles fonctionnalités mais facilitant l’usage pratique d’une bibliothèque.
</p>
</article>
</details>

<p>
Le tableau suivant liste les principales normes utilisées par le projet.
Plusieurs normes sont publiées à la fois comme standard <abbr title="International Organization for Standardization">ISO</abbr> et comme standard <abbr>OGC</abbr>,
d’où la disposition côte-à-côte des deux premières colonnes.
La section des « spécifications d’implémentation » liste des spécifications qui apportent peu de concepts nouveaux
comparativement aux spécifications abstraites, mais précisent comment les représenter dans des contextes précis
tels qu’un document <abbr>XML</abbr>.
Les normes dépréciées mais malgré tout partiellement utilisées apparaissent <s>barrées</s>.
Enfin, les paquets GeoAPI seront introduits dans le chapitre suivant.
</p>
<table>
<caption>Principaux standards en relation avec le projet Apache <abbr>SIS</abbr></caption>
<tr>
<th>Norme <abbr>ISO</abbr></th>
<th>Norme <abbr>OGC</abbr></th>
<th>Titre</th>
<th>Paquet de GeoAPI</th>
<th>Paquet de Apache SIS</th>
</tr><tr>
<td class="separator" colspan="5">Spécifications abstraites</td>
</tr><tr>
<td><abbr>ISO</abbr> 19103</td>
<td/>
<td><i>Conceptual schema language</i></td>
<td><code class="GeoAPI">org.opengis.util</code></td>
<td><code class="SIS">org.apache.sis.util.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-1</td>
<td>Topic 11</td>
<td><i>Metadata</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-2</td>
<td/>
<td><i>Metadata — extensions for imagery and gridded data</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111</td>
<td>Topic 2</td>
<td><i>Spatial referencing by coordinates</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111-2</td>
<td/>
<td><i>Referencing — extension for parametric values</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19112</td>
<td/>
<td><i>Spatial referencing by geographic identifier</i></td>
<td><code class="GeoAPI">org.opengis.referencing.gazetteer</code></td>
<td><code class="SIS">org.apache.sis.referencing.gazetteer</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19108</td>
<td/>
<td><i>Temporal Schema</i></td>
<td><code class="GeoAPI">org.opengis.temporal</code></td>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19107</td>
<td>Topic 1</td>
<td><i>Feature geometry</i></td>
<td><code class="GeoAPI">org.opengis.geometry</code></td>
<td><code class="SIS">org.apache.sis.geometry</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19109</td>
<td>Topic 5</td>
<td><i>Rules for application schema</i></td>
<td><code class="GeoAPI">org.opengis.feature</code></td>
<td><code class="SIS">org.apache.sis.feature</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19123</td>
<td>Topic 6</td>
<td><i>Schema for coverage geometry and functions</i></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19156</td>
<td>Topic 20</td>
<td><i>Observations and measurements</i></td>
<td><code class="GeoAPI">org.opengis.observation</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Spécifications d’implémentation</td>
</tr><tr>
<td><abbr>ISO</abbr> 19139</td>
<td/>
<td><i>Metadata <abbr>XML</abbr> schema implementation</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19136</td>
<td>OGC 07-036</td>
<td><i>Geography Markup Language (<abbr>GML</abbr>) Encoding Standard</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19162</td>
<td>OGC 12-063</td>
<td><i>Well-known text representation of coordinate reference systems</i></td>
<td/>
<td><code class="SIS">org.apache.sis.io.wkt</code></td>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-009</s></td>
<td><s><i>Coordinate Transformation Services</i></s></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-004</s></td>
<td><s><i>Grid Coverage</i></s></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td/>
<td><abbr>OGC</abbr> 10-092</td>
<td><i>NetCDF binary encoding: classic and 64-bit offset format</i></td>
<td/>
<td><code class="SIS">org.apache.sis.storage.netcdf</code></td>
</tr><tr>
<td/>
<td><abbr>OGC</abbr> 14-084</td>
<td><i>Moving features Comma Separated Values (CSV) encoding</i></td>
<td/>
<td><code class="SIS">org.apache.sis.storage</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 13249</td>
<td/>
<td><i><abbr>SQL</abbr> spatial</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SLD</abbr></td>
<td><i>Styled Layer Descriptor</i></td>
<td><code class="GeoAPI">org.opengis.style</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Services web</td>
</tr><tr>
<td/>
<td><abbr>CSW</abbr></td>
<td><i>Catalog Services</i></td>
<td/>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19128</td>
<td><abbr>WMS</abbr></td>
<td><i>Web Map Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WMTS</abbr></td>
<td><i>Web Map Tile Service</i></td>
<td/>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19142</td>
<td><abbr>WFS</abbr></td>
<td><i>Web Feature Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WCS</abbr></td>
<td><i>Web Coverage Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WPS</abbr></td>
<td><i>Web Processing Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td>Open<abbr>LS</abbr></td>
<td><i>Location Services</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SWE</abbr></td>
<td><i>Sensor Web Enablement</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SOS</abbr></td>
<td><i>Sensor Observation Service</i></td>
<td/>
<td/>
</tr>
</table>
</section>


<section>
<header>
<h2 id="GeoAPI"><span class="section-number">1.2.</span> Des modèles conceptuels vers des interfaces Java: GeoAPI</h2>
</header>
<p>
Le projet <a href="http://www.geoapi.org">GeoAPI</a> offre un ensemble d’interfaces Java pour les applications géo-spatiales.
Dans une séries de paquets <code class="GeoAPI">org.opengis.*</code>, GeoAPI définit des structures représentant des méta-données,
des systèmes de référence des coordonnées, ainsi que des opérations effectuant des projections cartographiques.
Dans une partie qui n’est pas encore standardisée — dénommée <i>pending</i> — GeoAPI définit des structures
représentant des images géo-référencées, des géométries, des filtres pouvant s’appliquer à des requêtes, et d’autres fonctionnalités.
Ces interfaces suivent de très près les spécifications de l’<abbr title="Open Geospatial Consortium">OGC</abbr>, tout en les interprétant et en les adaptant
de manière à répondre aux attentes des développeurs Java — par exemple en se conformant aux conventions de nommage.
Ces interfaces bénéficient à la fois aux applications clientes et aux bibliothèques:
</p>
<ul>
<li><p>
Les développeurs des applications clientes bénéficient d’une plus grande base de connaissances disponible sur internet
(due aux nombreuses publications en lien avec les standards de l’<abbr>OGC</abbr>), ainsi que d’une interopérabilité accrue.
L’interopérabilité est facilitée par une meilleure séparation entre les applications qui <em>appellent</em> les fonctions de GeoAPI,
et les bibliothèques qui <em>implémentent</em> GeoAPI. Il s’agit d’une séparation similaire à celle qu’offrent les interfaces
<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/"><abbr title="Java DataBase Connectivity">JDBC</abbr></a> (<i>Java Database Connectivity</i>) du Java standard.
En utilisant l’<abbr title="Application Programming Interface">API</abbr> des interfaces, les développeurs peuvent faire abstraction de l’implémentation sous-jacente.
Par exemple ils peuvent effectuer des projections cartographiques à l’aide des bibliothèques
<a href="http://www.geoapi.org/geoapi-proj4/index.html">Proj.4</a> ou Apache <abbr title="Spatial Information System">SIS</abbr>,
sans changer leurs programmes lorsqu’ils changent de bibliothèque.
</p></li>
<li><p>
Les développeurs des bibliothèques héritent de l’expertise des auteurs des spécifications, via les modèles que représentent les interfaces.
GeoAPI fournit aussi un cadre dans lequel les développeurs peuvent implémenter en priorité les fonctionnalité qui leurs sont le plus nécessaires,
tout en ayant des points où raccrocher les développements futurs.
Par exemple les clients peuvent appeler une fonction de GeoAPI même si elle n’est pas encore supportée par la bibliothèque,
quitte à obtenir une valeur nulle en attendant qu’une nouvelle version de la bibliothèque retourne une valeur intéressante.
</p></li>
</ul>

<details>
<summary>Pour en savoir plus sur les origines du projet GeoAPI</summary>
<article id="GeoAPI-history">
<header>
<h2>Historique du projet GeoAPI</h2>
</header>
<p>
En 2001, le consortium <i>Open GIS</i> (l’ancien nom du consortium <i>Open Geospatial</i>) publia la spécification d’implémentation
<a href="http://www.opengeospatial.org/standards/ct"><abbr title="Open Geospatial Consortium">OGC</abbr> 01-009: <cite>Coordinate Transformation Services</cite></a>.
Cette spécification, élaborée par <i>Computer Aided Development Corporation</i> (Cadcorp),
était accompagnée d’interfaces <abbr title="Component Object Model">COM</abbr>, <abbr title="Common Object Request Broker Architecture">CORBA</abbr> et Java.
À cette époque, la vague des services web n’avait pas encore éclipsé les interfaces de programmation classiques.
Les interfaces de l’<abbr>OGC</abbr> anticipaient tout de même un monde connecté en réseau,
mais misaient plutôt — dans le cas du Java — sur la technologie <abbr>RMI</abbr> (<i>Remote Method Invocation</i>).
Bien que le projet GeoAPI n’existait pas encore, nous désignons rétrospectivement ces interfaces historiques sous le nom de
« <a href="http://www.geoapi.org/0.1/index.html">GeoAPI 0.1</a> ».
Ces interfaces utilisaient déjà le nom de paquet <code class="GeoAPI">org.opengis</code>, qui sera adopté par GeoAPI.
</p><p>
En 2002, des développeurs de projets libres ont lancé un
<a href="http://web.archive.org/web/20030509104308/http://digitalearth.org/story/2002/10/10/55046/206">appel à la création d’un <abbr title="Application Programming Interface">API</abbr> géo-spatial</a>.
La proposition initiale suscita l’intérêt d’au moins cinq projets libres.
Le projet fut créé sur <a href="http://sourceforge.net/projects/geoapi/">SourceForge</a>,
qui héberge depuis lors le code source dans un <a href="http://www.geoapi.org/source-repository.html">dépôt Subversion</a>.
Le projet pris le nom de « GeoAPI » à ce moment là, et utilisa les interfaces de la spécification <abbr>OGC</abbr> 01-009 comme point de départ.
</p><p>
Quelques mois plus tard, l’<abbr>OGC</abbr> lança le projet
<a href="http://www.opengeospatial.org/standards/go"><abbr>GO-1</abbr>: <i>Geographic Objects</i></a>,
qui poursuivait des buts similaires à ceux de GeoAPI.
Entre-temps, l’<abbr>OGC</abbr> avait abandonné certaines de leur spécifications en faveur des normes <abbr title="International Organization for Standardization">ISO</abbr>.
GeoAPI et <abbr>GO-1</abbr> ont joint leurs efforts pour une refonte des interfaces de GeoAPI en les basant sur ces nouvelles normes <abbr>ISO</abbr>.
La première mouture, <a href="http://www.geoapi.org/1.0/index.html">GeoAPI 1.0</a>, a servit de point de départ
aux premières ébauches de la spécification <abbr>OGC</abbr> 03-064 du groupe de travail <abbr>GO</abbr>-1.
La version finale de cette spécification est devenue un standard <abbr>OGC</abbr> en 2005, et
<a href="http://www.geoapi.org/2.0/index.html">GeoAPI 2.0</a> a été publiée à cette occasion.
</p><p>
Le projet <abbr>GO</abbr>-1 était porté essentiellement par une compagnie nommée <i>Polexis</i>.
Son rachat par <i>Sys Technology</i> et le changement de priorité des nouveaux propriétaires
ont causé l’arrêt des travaux de <abbr>GO</abbr>-1, et par ricochet un ralentissement des développements de GeoAPI.
Afin de reprendre les développements, un nouveau groupe de travail « GeoAPI 3.0 » a été créé à l’<abbr>OGC</abbr>.
Ce groupe a réduit les ambitions par rapport à GeoAPI 2.0 en se concentrant sur les interfaces les plus stables,
et en plaçant les autres — notamment les géométries — dans un module nommé « <a href="http://www.geoapi.org/geoapi-pending/index.html">pending</a> »,
pour considérations futures. <a href="http://www.geoapi.org/3.0/index.html">GeoAPI 3.0</a> est devenu un
<a href="http://www.opengeospatial.org/standards/geoapi">standard <abbr>OGC</abbr></a> en 2011.
Cette version a été la première à être déployée dans le <a href="http://search.maven.org/#search|ga|1|geoapi">dépôt central de Maven</a>.
</p>
</article>
</details>

<p id="GeoAPI-core">
GeoAPI est constitué de plusieurs modules.
Les modules <code class="GeoAPI">geoapi</code> et <code class="GeoAPI">geoapi-pending</code>
fournissent les interfaces dérivées des schémas <abbr title="Unified Modeling Language">UML</abbr> des standards internationaux.
Le modèle conceptuel sera expliqué en détails dans les chapitres décrivant l’implémentation Apache <abbr title="Spatial Information System">SIS</abbr>.
On peut toutefois avoir un aperçu de son contenu en consultant la page listant les
<a href="http://www.geoapi.org/3.0/javadoc/content.html">types et méthodes de GeoAPI et les standards d’où ils proviennent</a>.
Ces modules ainsi que la correspondance entre GeoAPI et les standards internationaux sont décrits plus en détails
<a href="#SpecificationToInterfaces">en annexe</a>.
</p>



<h3 id="GeoAPI-implementation"><span class="section-number">1.2.1.</span> Implémentations fournies par Apache SIS</h3>
<p>
Apache SIS implémente la plupart des interfaces de GeoAPI avec une classe du même nom que l’interface,
mais préfixée de « <code>Abstract</code> », « <code>Default</code> » ou « <code>General</code> ».
Les classes de Apache SIS qui sont préfixées par « <code>Default</code> » peuvent être instanciées directement
par une instruction <code>new DefaultXXX(…)</code> ou par la méthode <code>createXXX(…)</code> correspondante d’une fabrique.
</p>
<div class="example"><b>Example:</b> pour représenter un système de référence de coordonnées projetées (Mercator, Lambert, <i>etc</i>):
<ul>
<li><code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> est l’interface définie par GeoAPI sur la base du standard ISO 19111, et</li>
<li><code class="SIS">org.apache.sis.referencing.crs.DefaultProjectedCRS</code> est l’implémentation fournie par Apache SIS.</li>
</ul>
Une instance peut être créée par:
<ul>
<li><code>ProjectedCRS crs = new DefaultProjectedCRS(…)</code>, ou</li>
<li><code>ProjectedCRS crs = CRSFactory​.createProjectedCRS(…)</code>.</li>
</ul>
Les deux approches attendent les mêmes arguments (omis dans cet exemple).
</div>
<p>
Dans la configuration par défaut de Apache SIS,
utiliser <code>FooFactory​.createXXX(…)</code> ou <code>new DefaultXXX(…)</code> revient presque au même
excepté que les <code>FooFactory</code> peuvent retourner des instances existantes
plutôt que de créer systématiquement de nouvelles instances,
et que les exceptions en cas d’arguments invalides sont de types différents.
Dans des configurations plus avancées, l’usage des <code class="GeoAPI">Factory</code> permet de
<a href="#ServiceLoader">réduire la dépendance directe d’une application envers SIS</a>
et de permettre une inversion de contrôle.
</p><p>
Le préfix « <code>General</code> » est parfois utilisé à la place de « <code>Default</code> »
afin de signaler que des implémentations alternatives existent pour des cas spécifiques.
Par exemple l’interface <code class="GeoAPI">Envelope</code> est implémentée par au moins deux classes de Apache SIS:
<code class="SIS">GeneralEnvelope</code> et <code class="SIS">Envelope2D</code>.
La première implémentation peut représenter des enveloppes de n’importe quelle dimension
alors que la seconde implémentation est spécialisée pour les enveloppes à deux dimensions.
</p><p>
Les classes de Apache SIS qui sont préfixées par « <code>Abstract</code> » ne doivent pas – en principe – être instanciées.
Il faut plutôt instancier une sous-classe non-abstraites.
Toutefois plusieurs classes de SIS ne sont abstraites que conceptuellement,
sans que la définition de la classe ne contienne le mot-clé <code>abstract</code> du Java.
Ces classes peuvent être instanciées par l’instruction <code>new AbstractXXX(…)</code>
– mais pas par les <code class="GeoAPI">Factory</code> – malgré qu’elles soient conceptuellement abstraites.
Mais ces instanciations ne devraient être faites qu’en dernier recours,
lorsqu’il n’est vraiment pas possible de déterminer le sous-type exact.
</p>
</section>


<section>
<header>
<h2 id="AboutBook"><span class="section-number">1.3.</span> Conventions utilisées dans ce guide</h2>
</header>
<p>
Les éléments définis dans un langage informatique, tels que les classes ou méthodes en Java
ainsi que les éléments dans un fichier <abbr>XML</abbr>, apparaissent avec une police de caractères mono-espacée.
Afin de faciliter la compréhension des liens qui existent entre Apache <abbr title="Spatial Information System">SIS</abbr> et les standards,
ces éléments sont en outre représentés en utilisant les codes de couleurs suivants:
</p>
<ul>
<li>
Les éléments définis dans un standard de l’<abbr title="Open Geospatial Consortium">OGC</abbr>
ou de l’<abbr title="International Organization for Standardization">ISO</abbr> apparaissent en bleu.
Exemple: <code class="OGC">CD_Ellipsoid</code>.
</li>
<li>
Les éléments définis dans GeoAPI apparaissent en vert.
Exemple: <code class="GeoAPI">Ellipsoid</code>.
</li>
<li>
Les éléments définis dans Apache <abbr title="Spatial Information System">SIS</abbr> apparaissent en brun.
Exemple: <code class="SIS">DefaultEllipsoid</code>.
</li>
<li>
Les autres éléments, notamment ceux du Java standard, sont laissés en noir.
Exemple: <code>String</code>.
</li>
</ul>
<p>
Des compléments d’information apparaissent dans des boîtes grises.
Le lecteur peut ignorer ces boîtes grises sans que cela ne nuise à la compréhension du texte.
</p>



<h3 id="ChosenTerms"><span class="section-number">1.3.1.</span> Choix des termes</h3>
<p>
Les standards privilégient parfois l’application de certains termes génériques à des contextes particuliers,
qui peuvent différer du contexte dans lequel d’autres communautés emploient ces termes.
Par exemple les termes <i>domain</i> et <i>range</i> peuvent s’appliquer à des fonctions arbitraires
pour désigner l’ensemble des valeurs possibles en entrés et en sorties respectivement.
Mais les fonctions auxquelles certains standards <abbr title="International Organization for Standardization">ISO</abbr>
les appliquent ne sont pas les mêmes que les fonctions auxquelles d’autres bibliothèques les appliquent.
Par exemple <abbr>ISO</abbr> 19123 applique ces termes aux objets <code class="OGC">CV_Coverage</code>,
vus comme des fonctions dont le domaine est l’ensemble des coordonnées spatio-temporelles de la couverture de données
et le <i>range</i> l’ensemble des valeurs de la couverture.
Mais la bibliothèque <abbr title="Network Common Data Form">netCDF</abbr> de l’<abbr title="University Corporation for Atmospheric Research">UCAR</abbr>
applique plutôt ces termes à la fonction convertissant les indices de pixels (son domaine) vers les coordonnées spatio-temporelles (son <i>range</i>).
Ainsi, un <i>range</i> de la bibliothèque de l’<abbr>UCAR</abbr> peut être le domaine de <abbr>ISO</abbr> 19123.
</p><p>
La bibliothèque Apache <abbr title="Spatial Information System">SIS</abbr> privilégie autant que possible l’utilisation des termes dans le sens des normes <abbr title="Open Geospatial Consortium">OGC</abbr> et <abbr>ISO</abbr>.
Mais un soin particulier doit être apporté aux interfaces entre <abbr>SIS</abbr> et certaines bibliothèques externes, afin de réduire les risques de confusions.
</p>
</section>
</section>


<section>
<header>
<h1 id="DataAccess"><span class="section-number">2.</span> Accès aux données géospatiales</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Standards">Chapitre précédent</a></div><div class="next-chapter"><a href="#Coverage">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#GetMetadataElement">Parcourir les méta-données</a></li></ul></nav>
<p>
Bien qu’il soit possible de créer des structures de données programmatiquement en mémoire,
le plus souvent les données sont lues à partir de fichiers ou autres types d’entrepôts.
Il y a plusieurs moyens d’accéder à ces données, mais une façon pratique est d’utiliser
la méthode de commodité <code class="SIS">DataStores​.open(Object)</code>.
L’argument donné à cette méthode peut être un chemin vers un fichier
(<code>File</code>, <code>Path</code>, <code>URL</code>, <code>URI</code>),
un flux d’entrée vers un fichier déjà ouvert
(<code>Channel</code>, <code>DataInput</code>, <code>InputStream</code>, <code>Reader</code>),
une connexion à une base de données (<code>DataSource</code>, <code>Connection</code>)
ou d’autres types d’objets spécifiques à la source de données.
La méthode <code class="SIS">DataStores​.open(Object)</code> se charge de détecter le format de données
et retourne une instance de <code class="SIS">DataStore</code> pouvant le lire.
</p>
<p>
Les fonctionnalités d’un <code class="SIS">DataStore</code> dépendent de la nature des données à manipuler
(couvertures de données, ensembles de géométries, séries temporelles, <i>etc.</i>),
mais dans tous les cas il y aura toujours au moins quelques méta-données que l’on peut extraire.
Les méta-données permettent d’identifier les phénomènes ou entités décrits par les données
(température, occupation du sol, <i>etc.</i>),
la région géographique ou la plage temporelle couverte par les données ainsi que leur résolution.
Certains sources suffisamment riches fournissent aussi une estimation de la qualité des données,
des informations permettant de contacter la personne ou l’organisme responsable des données,
les contraintes légales ou techniques à l’utilisation, l’historique des traitements,
les dates prévues des prochaines mises-à-jour, <i>etc.</i>
</p>
<p>
Les différents formats de données ont souvent leurs propres modèles de méta-données,
mais Apache <abbr title="Spatial Information System">SIS</abbr> les traduit tous vers un modèle unique afin de cacher cette hétérogénéité.
Cette approche, consistant à choisir un seul modèle de méta-données comme <em>modèle pivot</em>, est fréquemment utilisée par d’autres bibliothèques aussi.
Par exemple Apache Tika utilise le standard <cite>Dublin Core</cite> comme modèle pivot,
alors que Java Image I/O définit son propre modèle standard dans le paquet <code>javax.imageio.metadata</code>.
Pour Apache <abbr>SIS</abbr>, le modèle pivot choisi est le standard international de méta-données en information géographique
<abbr title="International Organization for Standardization">ISO</abbr> 19115-1:2014 — <cite>principes de base</cite>, complété par
<abbr>ISO</abbr> 19115-2 — <cite>extensions pour l’acquisition et le traitement</cite>.
Ce modèle organise les méta-données dans une arborescence où chaque information est accessible via un chemin bien défini,
peu importe l’origine de cette information.
Par exemple si un format de données peut nous fournir les coordonnées géographiques d’une boîte englobant toutes les données,
alors cette information sera toujours accessible (peu importe le format de données) à partir de l’objet <code class="GeoAPI">Metadata</code>
sous le noeud <code class="OGC">identificationInfo</code>, sous-noeud <code class="OGC">extent</code>,
sous-noeud <code class="OGC">geographicElement</code>.
</p>
<div class="example"><p><b>Exemple:</b>
le code suivant lit un fichier de méta-données d’une image Landsat-8 et affiche les limites géographiques qui y sont déclarées:
</p>

<pre><code><b>try</b> (<code class="SIS">DataStore</code> ds = DataStores.open(<b>new</b> File(<i>"LC81230522014071LGN00_MTL.txt"</i>))) {
    <code class="GeoAPI">Metadata</code> md = ds.getMetadata();

    <code class="comment">// Afin de simplifier cet exemple, nous omettons les vérifications de valeurs nulles ou de collections vides.
</code>    <code class="GeoAPI">Identification</code>   idInfo = md    .getIdentificationInfo().iterator().next();
    <code class="GeoAPI">Extent</code>           extent = idInfo.getExtents()           .iterator().next();
    <code class="GeoAPI">GeographicExtent</code> bbox   = extent.getGeographicElements().iterator().next();

    System.out.println(<i>"La région géographique des données est:"</i>);
    System.out.println(bbox);
}</code></pre>

<p>
Cet exemple produit la sortie suivante (la région est située au Vietnam):
</p>

<pre><samp>La région géographique des données est:
Geographic Bounding Box
  ├─West bound longitude…………………………… 108°20′10,464″E
  ├─East bound longitude…………………………… 110°26′39,66″E
  ├─South bound latitude…………………………… 10°29′59,604″N
  └─North bound latitude…………………………… 12°37′25,716″N</samp></pre>

<p>
Le code Java dans cet exemple extrait des éléments de méta-données par des appels à des méthodes Java telles que <code class="GeoAPI">getExtents()</code>,
mais les chapitres suivants introduiront d’autres façons utilisant des identifiants sous forme de chaînes de caractères.
Ces approches alternatives sont plus pratiques lorsque l’on ne connaît pas au moment de la compilation quelles méthodes appeler.
</p>
</div>

<p>
La norme <abbr>ISO</abbr> 19115 définit des centaines d’éléments.
Certains de ces éléments seront introduits progressivement dans les chapitres suivants.
Mais afin de donner une petite idée de ce qui est disponible, le tableau suivant en liste quelques uns.
La plupart des noeuds acceptent un nombre arbitraire de valeurs.
Par exemple il peut y avoir plusieurs zones géographiques décrites sous le noeud <code class="OGC">extent</code>.
</p>

<table style="line-height:1">
<caption>Quelques éléments de méta-données extraits de ISO 19115</caption>
<tr><th>Élément</th>                                <th>Description</th></tr>
<tr><td style="padding-top:9px">Metadata</td>       <td style="padding-top:9px">Méta-données à propos d’un jeu de données, d’un service ou autres ressources.</td></tr>
<tr><td>  ├─Reference system info</td>              <td>Description du système de référence spatial et temporel utilisé dans le jeu de données.</td></tr>
<tr><td>  ├─Identification info</td>                <td>Information de base à propos de la ressource décrite par les méta-données.</td></tr>
<tr><td>  │   ├─Citation</td>                       <td>Nom selon lequel la ressource est connue, ainsi que des dates de références, la forme de présentation, <i>etc.</i></td></tr>
<tr><td>  │   │   └─Cited responsible party</td>    <td>Rôle, nom, contact et position des individus ou organisations qui sont responsables de la ressource.</td></tr>
<tr><td>  │   ├─Topic category</td>                 <td>Principaux thèmes de la ressource (agriculture, climatologie, environnement, économie, santé, transport, <i>etc.</i>).</td></tr>
<tr><td>  │   ├─Descriptive keywords</td>           <td>Mots-clés, leurs types, et référence vers la source les définissant.</td></tr>
<tr><td>  │   ├─Spatial resolution</td>             <td>Facteur (échelle, taille de pixel) donnant une idée globale de la densité spatiale des données de la ressource.</td></tr>
<tr><td>  │   ├─Temporal resolution</td>            <td>La plus petite période temporelle pouvant être résolue dans la ressource.</td></tr>
<tr><td>  │   ├─Extent</td>                         <td>Étendue spatiale et temporelle de la ressource.</td></tr>
<tr><td>  │   ├─Resource format</td>                <td>Description du format de la ressource.</td></tr>
<tr><td>  │   ├─Resource maintenance</td>           <td>Information sur la fréquence des mises-à-jours de la ressources, ainsi que la portée de ces mises-à-jours.</td></tr>
<tr><td>  │   └─Resource constraints</td>           <td>Information sur les contraintes légales ou de sécurités qui s’appliquent à la ressource.</td></tr>
<tr><td>  ├─Content info</td>                       <td>Information sur le catalogue d’entités ainsi que les caractéristiques des couvertures de données ou images.</td></tr>
<tr><td>  │   ├─Imaging condition</td>              <td>Conditions qui affectent les images (image floue, brouillard, semi-obscurité, <i>etc.</i>).</td></tr>
<tr><td>  │   ├─Cloud cover percentage</td>         <td>Proportion des données masquées par les nuages, comme pourcentage de l’étendue spatiale.</td></tr>
<tr><td>  │   └─Attribute group</td>                <td>Information sur les groupes d’attributs de la ressource.</td></tr>
<tr><td>  │       ├─Content type</td>               <td>Types d’information représentée par les valeurs (classification thématique, mesures physiques, <i>etc.</i>).</td></tr>
<tr><td>  │       └─Attribute</td>                  <td>Information sur un attribut d’une ressource.</td></tr>
<tr><td>  │           ├─Sequence identifier</td>    <td>Nom ou numéro unique qui identifie l’attribut dans une couverture de données.</td></tr>
<tr><td>  │           ├─Peak response</td>          <td>Longueur d’onde à laquelle la réponse du capteur est maximale.</td></tr>
<tr><td>  │           ├─Min/max value</td>          <td>Valeur minimale/maximale des données pour chaque dimension d’échantillonage inclue dans la ressource.</td></tr>
<tr><td>  │           ├─Units</td>                  <td>Unités de mesures pour chaque dimension d’échantillonage inclue dans la ressource.</td></tr>
<tr><td>  │           └─Transfer function type</td> <td>Type de fonction de transfert utilisée pour convertir un élément en valeur physique.</td></tr>
<tr><td>  ├─Distribution info</td>                  <td>Information sur les distributeurs et les façons d’obtenir la ressource.</td></tr>
<tr><td>  │   ├─Distribution format</td>            <td>Description des formats dans lesquels les données peuvent être distribuées.</td></tr>
<tr><td>  │   └─Transfer options</td>               <td>Moyens techniques et médias par lesquels une ressource peut être obtenue à partir de son distributeur.</td></tr>
<tr><td>  ├─Data quality info</td>                  <td>Évaluation globale de la qualité de la ressource.</td></tr>
<tr><td>  ├─Acquisition information</td>            <td>Information sur l’acquisition des données.</td></tr>
<tr><td>  │   ├─Environmental conditions</td>       <td>Conditions environnementales dans lesquels les données ont été acquises.</td></tr>
<tr><td>  │   └─Platform</td>                       <td>Information générale sur la plate-forme à partir de laquelle les données ont été acquises.</td></tr>
<tr><td>  │       └─Instrument</td>                 <td>Instruments montées sur la plate-forme.</td></tr>
<tr><td>  └─Resource lineage</td>                   <td>Information sur la provenance, les sources et/ou les étapes de production de la ressource.</td></tr>
<tr><td>      ├─Source</td>                         <td>Information sur les données sources utilisées pour créer les données décrites par les méta-données.</td></tr>
<tr><td>      └─Process step</td>                   <td>Historique des événements survenues dans la productions des données.</td></tr>
</table>



<section>
<header>
<h2 id="GetMetadataElement"><span class="section-number">2.1.</span> Parcourir les méta-données</h2>
</header>
<p>
L’utilisation de méthodes telles que <code class="GeoAPI">getExtents()</code>
est efficace lorsque l’on cherche un élément bien précis, connu au moment de la compilation.
Mais le fait que l’élément recherché peut être assez loin dans l’arborescence et
que beaucoup d’éléments soient optionnels ou membres de collections rend parfois le parcourt laborieux.
Pour quelques éléments fréquemment demandés, des méthodes de commodité existent.
Elles sont généralement définies sous forme de méthodes statiques dans une classe dont le nom est au pluriel.
Par exemple la classe <code class="SIS">Extents</code> définie des méthodes statiques pour extraire plus facilement
certaines informations à partir de l’élément de méta-donnée <code class="GeoAPI">Extent</code>.
Ainsi la ligne suivante prendra en charge le travail un peu fastidieux de parcourir les différentes branches possible
pouvant aboutir aux limites nord, sud, est et ouest de la donnée:
</p>
<pre><code><code class="GeoAPI">GeographicBoundingBox</code> bbox = <code class="SIS">Extents</code>.getGeographicBoundingBox(extent);</code></pre>
<p>
Ces méthodes de commodité sont définies sous forme de méthodes statiques
afin de permettre leur utilisation avec différentes implémentations des éléments de méta-données.
Même dans Apache <abbr title="Spatial Information System">SIS</abbr>, la classe <code class="SIS">DefaultExtent</code> n’est pas la seule implémentation de l’interface <code class="GeoAPI">Extent</code>.
Il y a aussi d’autres implémentations qui puiseront leur information à la demande dans une base de données,
ou des implémentations conçues spécifiquement pour des formats de données particuliers.
D’autres exemples de classes fournissant des méthodes statiques dédiées à une interface sont
<code class="SIS">Citations</code>, <code class="SIS">Envelopes</code>, <code class="SIS">Matrices</code> et <code class="SIS">MathTransforms</code>.
</p><p>
Ces méthodes statiques parcourent une plus grande portion de l’arbre de méta-données afin de trouver ou dériver l’élément demandé,
mais ce dernier reste un élément dont le type et au moins une partie du chemin sont connus au moment de la compilation.
Il arrive que l’on veuille plutôt accéder à des éléments qui ne sont connus qu’au moment de l’exécution, ou encore parcourir tous les éléments.
Dans ces cas, on peut utiliser une vue sous forme de <code>java.util.Map</code> comme dans l’exemple suivant:
</p>

<pre><code>Map&lt;String,Object&gt; elements = MetadataStandard.ISO_19115.asValueMap(
        metadata,                           <code class="comment">// N’importe quelle instance du paquet org.opengis.metadata ou d’un sous-paquet.
</code>        <b>null</b>,                               <code class="comment">// Utilisé pour résoudre des ambiguïtés. Peut être ignoré pour cet exemple.
</code>        KeyNamePolicy.JAVABEANS_PROPERTY,   <code class="comment">// Les clés seront les noms des méthodes mais sans le prefix « get ».
</code>        ValueExistencePolicy.NON_EMPTY);    <code class="comment">// Les entrés dont la valeur est nulle ou vide seront omises.
</code><code class="comment">/*
 * Affiche les noms de tous les éléments à la racine de la méta-données qui ont une valeur.
 * Cette bouche ne va pas descendre dans les enfants (pas de récursivité).
 */</code>
<b>for</b> (String name : elements.keySet()) {
    System.out.println(name);
}</code></pre>

<p>
Le <code>Map</code> retourné par <code class="SIS">asValueMap(…)</code> est une vue « vivante »:
tout changement dans l’instance <code>metadata</code> se reflétera immédiatement dans la vue.
En fait, chaque appel à <code>map.get("foo")</code> se traduit par un appel à la méthode <code>metadata​.getFoo()</code> correspondante.
Réciproquement, toute opération <code>map.put("foo", …)</code> ou <code>map.remove("foo")</code> effectuée sur la vue
sera traduite en appel à la méthode <code>metadata​.setFoo(…)</code> correspondante si cette dernière existe.
Cette vue est assez souple sur les clés données en argument aux méthodes de <code>Map</code>:
elles peuvent être le nom de la propriété (<code>"foo"</code>), le nom de la méthode (<code>"getFoo"</code>),
ou le nom utilisé dans les diagrammes <abbr title="Unified Modeling Language">UML</abbr> de la norme <abbr title="International Organization for Standardization">ISO</abbr> 19115
(assez proche du nom de la propriété mais pas toujours identique).
Les différences entre majuscules et minuscules sont ignorées si elles ne causent pas d’ambiguïtés.
</p><p>
Parmi les éléments de méta-données présentés dans ce chapitre,
il en est un qui fera l’objet d’un chapitre dédié: <code class="OGC">referenceSystemInfo</code>.
Son contenu est essentiel pour positionner précisément les données.
Sans lui, même les positions exprimées sous forme de latitudes et longitudes sont ambigües.
Les systèmes de références ont plusieurs caractéristiques qui les différencient des autres méta-données:
ils sont immuables, ne peuvent pas être parcourus par <code class="SIS">MetadataStandard.ISO_19115​.asValueMap(…)</code>,
ont une représentation sous forme de texte particulière,
et sont associés à un mécanisme permettant de transformer des coordonnées d’un référentiel vers un autre.
</p>
</section>
</section>


<section>
<header>
<h1 id="Coverage"><span class="section-number">3.</span> Couvertures de données (<i>Coverages</i>)</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#DataAccess">Chapitre précédent</a></div><div class="next-chapter"><a href="#Geometry">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc"/></nav>
<p>
Les images, souvent nommées <i>rasters</i> en anglais, sont des cas particuliers
d’une structure de données appelée <i>coverages</i>.
On pourrait traduire ce terme anglais par « couverture de données ».
Le titre du standard les décrivant, « <i>Coverage geometry and functions</i> »
(<abbr title="International Organization for Standardization">ISO</abbr> 19123), résume bien les deux éléments essentiels des couvertures de données:
</p>
<ul>
<li>
<p>
Un <i>coverage</i> est une fonction qui, à partir d’une coordonnée spécifiée en entrée,
retourne une valeur d’attribut. L’ensemble des valeurs pouvant être données en entrée est appelé le domaine
(<i>domain</i> en anglais), alors que l’ensemble des valeurs pouvant être retournées est appelé <i>range</i> en anglais.
Le domaine est souvent l’espace spatio-temporel couvert par les données,
mais rien dans <abbr title="Spatial Information System">SIS</abbr> n’empêche les couvertures de s’étendre à d’autres dimensions.
Par exemple les études en thermodynamique utilisent souvent un espace dont les dimensions sont la température et la pression.
</p>
<div class="example"><p><b>Exemple:</b>
les valeurs des pixels d’une image pourraient contenir des mesures d’élévation du terrain.
Si une fonction <var>h</var> = <var>f</var>(φ,λ) permet d’obtenir (éventuellement à l’aide d’interpolations)
l’élévation <var>h</var> en fonction d’une coordonnée géographique (φ,λ), alors
l’enveloppe géographique de l’image définie le <i>domain</i>, la fonction <var>f</var> est le <i>coverage</i>,
et l’ensemble des valeurs de <var>h</var> que peut retourner cette fonction est le <i>range</i>.
</p></div>
</li>
<li>
<p>
Les différents types de couvertures peuvent se caractériser par la géométrie de leurs cellules.
En particulier, une couverture n’est pas nécessairement composée de cellules quadrilatérales.
Toutefois les cellules quadrilatérales étant de loin les plus fréquentes (puisque c’est la géométrie classique des pixels des images),
on utilisera souvent le terme <i>grid coverage</i> pour désigner les couvertures composées de telles cellules.
Dans <abbr>SIS</abbr>, la géométrie de ces couvertures est décrite par la classe <code class="SIS">GridGeometry</code>.
</p>
</li>
</ul>
<p>
Les caractéristiques du domaine spatial sont définies par le standard <abbr>ISO</abbr> 19123,
alors que les caractéristiques du <i>range</i> ne font pas parties du standard.
Le standard mentionne simplement que les <i>ranges</i> peuvent être finis ou infinis,
et ne sont pas nécessairement numériques.
Par exemple les valeurs retournées par une couverture peuvent provenir d’une énumération
(« ceci est une forêt », « ceci est un lac », <i>etc.</i>).
Toutefois, le standard définit deux grands types de couvertures qui ont un impact
sur les types de <i>ranges</i> autorisés:
les couvertures <i>discrètes</i> et les couvertures <i>continues</i>.
Présentées simplement, les couvertures continues sont des fonctions pouvant utiliser des méthodes d’interpolations.
Or, les interpolations n’étant possibles qu’avec des valeurs numériques, les <i>ranges</i> de valeurs
non-numériques ne peuvent être utilisés qu’avec des couvertures de type <code class="OGC">CV_DiscreteCoverage</code>.
En revanche, les <i>ranges</i> de valeurs numériques peuvent
être utilisés aussi avec des couvertures de type <code class="OGC">CV_ContinuousCoverage</code>.
</p>
<aside>
<h2>La classe <code class="SIS">Range</code> de SIS et sa relation avec les standards</h2>
<p>
La distinction entre les plages de tout type de valeurs et les plages de valeurs numériques est représentée dans <abbr title="Spatial Information System">SIS</abbr>
par les classes <code class="SIS">Range</code> et <code class="SIS">NumberRange</code> respectivement.
La classe <code class="SIS">NumberRange</code> est la plus utilisée, et elle est aussi celle qui se rapproche le plus de la
<a href="http://fr.wikipedia.org/wiki/Intervalle_%28math%C3%A9matiques%29">notion mathématique usuelle d’un intervalle</a>.
Se représentation textuelle se rapproche des spécifications du standard <abbr title="International Organization for Standardization">ISO</abbr> 31-11,
excepté que la virgule est remplacée par le caractère “…” comme séparateur des valeurs minimales et maximales.
Par exemple “[0 … 256)” représente la plage des valeurs 0 inclusivement à 256 exclusivement.
</p>
<p>
Les objets <code class="SIS">Range</code> ne sont associés aux <i>coverages</i> que indirectement.
Dans <abbr>SIS</abbr>, les valeurs que peuvent retourner les couvertures sont décrites par des
objets de type <code class="SIS">SampleDimension</code>. Ce sont ces derniers qui contiendront
des instances de <code class="SIS">Range</code> ainsi que d’autres informations telles qu’une
<i>fonction de transfert</i> (décrite plus loin).
</p>
</aside>
</section>


<section>
<header>
<h1 id="Geometry"><span class="section-number">4.</span> Géométries</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Coverage">Chapitre précédent</a></div><div class="next-chapter"><a href="#Referencing">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#GeometryBase">Classes de base</a><ul>
<li><a href="#DirectPosition">Points et positions directes</a></li>
<li><a href="#Envelope">Enveloppes</a><ul>
<li><a href="#AntiMeridian">Enveloppes traversant l’antiméridien</a></li></ul></li></ul></li></ul></nav>
<p>
Ce chapitre introduit quelques aspects de la norme <abbr title="International Organization for Standardization">ISO</abbr> 19107 (<i>Spatial schema</i>)
et les classes de Apache <abbr title="Spatial Information System">SIS</abbr> qui les implémentent.
</p>




<section>
<header>
<h2 id="GeometryBase"><span class="section-number">4.1.</span> Classes de base</h2>
</header>
<p>
Chaque objet géométrique est considéré comme un ensemble infini de points.
En tant qu’ensemble, leurs opérations les plus fondamentales sont de même nature que les opérations standards des collections du Java.
On pourrait donc voir une géométrie comme une sorte de <code>java.util.Set</code> dont les éléments seraient des points,
à ceci près que le nombre d’éléments contenus dans cet ensemble est infini (à l’exception des géométries représentant un simple point).
Pour mieux représenter ce concept, la norme <abbr title="International Organization for Standardization">ISO</abbr> et GeoAPI définissent une interface <code class="OGC">TransfiniteSet</code>
que l’on peut voir comme un <code>Set</code> de taille infini. Bien qu’un lien de parenté existe conceptuellement entre ces interfaces,
GeoAPI ne définit pas <code class="GeoAPI">TransfiniteSet</code> comme une sous-interface de <code>java.util.Set</code>
car la définition de certaines méthodes telles que <code>size()</code> et <code>iterator()</code> serait problématique.
On y retrouve toutefois des méthodes très similaires telles que <code class="GeoAPI">contains(…)</code> et <code class="GeoAPI">intersects(…)</code>.
</p>
<p>
Toutes les géométries sont des spécialisations de <code class="GeoAPI">TransfiniteSet</code>.
La classe parente de toutes ces géométries est appelée <code class="OGC">GM_Object</code> dans la norme <abbr>ISO</abbr> 19107.
Les interfaces de GeoAPI utilisent plutôt le nom <code class="GeoAPI">Geometry</code>, car l’omission du préfixe <code class="OGC">GM_</code>
(comme le veut la convention dans GeoAPI) aurait laissé un nom trop proche de la classe <code>Object</code> du Java.
</p>



<h3 id="DirectPosition"><span class="section-number">4.1.1.</span> Points et positions directes</h3>
<p>
<abbr title="International Organization for Standardization">ISO</abbr> 19107 définit deux types de structures pour représenter un point:
<code class="OGC">GM_Point</code> et <code class="OGC">DirectPosition</code>.
Le premier type est une véritable géométrie et peut donc être relativement lourd, selon les implémentations.
Le second type n’est pas considéré formellement comme une géométrie;
il n’étend ni <code class="OGC">GM_Object</code> ni <code class="OGC">TransfiniteSet</code>.
Il ne définit pratiquement pas d’opérations autres que le stockage d’une séquence de nombres représentant une coordonnée.
Il peut donc être un objet plus léger.
</p>
<p>
Afin de permettre à l’<abbr title="Application Programming Interface">API</abbr> de travailler indifféremment avec ces deux types de positions,
<abbr>ISO</abbr> 19107 définit <code class="OGC">Position</code> comme une <cite>union</cite> de
<code class="OGC">DirectPosition</code> et <code class="OGC">GM_Point</code>.
Il s’agit d’une union au sens du C/C++. Pour le langage Java, GeoAPI obtient le même effet en définissant
<code class="GeoAPI">Position</code> comme l’interface parente de <code class="GeoAPI">DirectPosition</code> et <code class="GeoAPI">Point</code>.
Dans la pratique, la grande majorité des <abbr>API</abbr> de Apache <abbr title="Spatial Information System">SIS</abbr> travaillent sur des <code class="GeoAPI">DirectPosition</code>,
ou occasionnellement des <code class="GeoAPI">Position</code> quand il semble utile d’autoriser aussi des points géométriques.
</p>



<h3 id="Envelope"><span class="section-number">4.1.2.</span> Enveloppes</h3>
<p>
Les enveloppes stockent les valeurs minimales et maximales des coordonnées d’une géométrie.
Les enveloppes <em>ne sont pas</em> elles-mêmes des géométries; ce ne sont pas des ensembles
infinis de points (<code class="OGC">TransfiniteSet</code>). Il n’y a aucune garantie
que toutes les positions contenues dans les limites d’une enveloppe soient géographiquement valides.
Il faut voir les enveloppes comme une information sur les valeurs extrêmes que peuvent prendre les
coordonnées d’une géométrie en faisant comme si chaque dimension était indépendante des autres,
rien de plus. Nous assimilons néanmoins les enveloppes à des rectangles, cubes ou hyper-cubes
(selon le nombre de dimensions) afin de faciliter la discussion, mais en gardant à l’esprit leur
nature non-géométrique.
</p>
<div class="example"><p><b>Exemple:</b>
Nous pouvons tester si une position est à l’intérieur des limites de l’enveloppe.
Un résultat positif ne garantie pas que la position est à l’intérieur de la géométrie délimitée par l’enveloppe,
mais un résultat négatif garantie qu’elle est à l’extérieur. De même on peut effectuer des tests d’intersections.
En revanche appliquer une rotation n’a pas beaucoup de sens pour une enveloppe, car le résultat peut être très différent
de celui que nous aurions obtenu en effectuant une rotation de la géométrie originale, puis en recalculant son enveloppe.
</p></div>
<p>
Une enveloppe peut être représentée par deux positions correspondant à deux coins opposés
d’un rectangle, cube ou hyper-cube. On prend souvent comme premier coin celui dont toutes
les ordonnées ont la valeur minimale (<code class="OGC">lowerCorner</code>), et comme second
coin celui dont toutes les ordonnées ont la valeur maximale (<code class="OGC">upperCorner</code>).
Lors d’un affichage utilisant un système de coordonnées classique (valeurs de l’axe des <var>y</var> augmentant vers le haut),
ces deux positions apparaissent respectivement dans le coin inférieur gauche et dans le coin supérieur droit d’un rectangle.
Attention toutefois aux différents systèmes de coordonnées, qui peuvent faire varier les positions de ces coins à l’écran.
Les expressions <i>lower corner</i> et <i>upper corner</i>
doivent être comprises au sens mathématique plutôt que visuel.
</p>



<h4 id="AntiMeridian"><span class="section-number">4.1.2.1.</span> Enveloppes traversant l’antiméridien</h4>
<p>
Les minimums et maximums sont les valeurs les plus souvent assignées aux <code class="OGC">lowerCorner</code>
et <code class="OGC">upperCorner</code>. Mais les choses se compliquent dans le cas d’une enveloppe traversant
l’antiméridien (-180° ou 180° de longitude). Par exemple, une enveloppe de 10° de largeur peut commencer à 175° de longitude et
se terminer à -175°. Dans ce cas, la valeur de longitude assignée au <code class="OGC">lowerCorner</code> est
supérieure à celle qui est assignée à l’<code class="OGC">upperCorner</code>.
Apache <abbr title="Spatial Information System">SIS</abbr> emploie donc une définition légèrement différente de ces deux coins:
</p>
<ul>
<li><b><code class="SIS">lowerCorner</code>:</b>
le point de départ lorsque l’on parcourt l’intérieur de l’enveloppe dans la direction des valeurs croissantes.
</li>
<li><b><code class="SIS">upperCorner</code>:</b>
le point d’arrivé lorsque l’on a parcouru l’intérieur de l’enveloppe dans la direction des valeurs croissantes.
</li>
</ul>
<p>
Lorsque l’enveloppe ne traverse par l’antiméridien, ces deux définitions sont équivalentes à la sélection
des valeurs minimales et maximales respectivement. C’est le cas du rectangle vert dans la figure ci-dessous.
Lorsque l’enveloppe traverse l’antiméridien, les coins <code class="SIS">lowerCorner</code>
et <code class="SIS">upperCorner</code> apparaissent encore en bas et en haut du rectangle
(en supposant un système de coordonnées classique), donc leurs noms restent appropriés d’un point de vue visuel.
Mais les positions gauche et droite sont interchangées.
Ce cas est représenté par le rectangle rouge dans la figure ci-dessous.
</p>
<p style="text-align:center">
<img alt="Exemples d’enveloppes avec et sans croisement de l’antiméridien." src="../../apidocs/org/apache/sis/geometry/doc-files/AntiMeridian.png"/>
</p>
<p>
Les notions d’inclusion et d’intersection s’interprètent toutefois de manière légèrement différente dans ces deux cas.
Dans le cas habituel où l’on ne traverse pas l’antiméridien, le rectangle vert délimite bien une région d’inclusion.
Les régions exclues de ce rectangle se propagent à l’infini dans toutes les directions.
En d’autres mots, la région d’inclusion n’est pas répétée tous les 360°.
Mais dans le cas du rectangle rouge, l’information fournie par l’enveloppe délimite plutôt la région d’exclusion qui
se trouve entre les deux bords du rectangle. La région d’inclusion se propage à l’infini des côtés gauche et droit.
Nous pourrions stipuler que toute longitude inférieure à -180° ou supérieure à 180° est considérée exclue,
mais ça serait une décision arbitraire qui ne serait pas un reflet symétrique du cas habituel (rectangle vert).
Un développeur pourrait vouloir utiliser ces valeurs, par exemple dans une mosaïque où la carte du monde
est répétée plusieurs fois horizontalement tout en considérant chaque répétition comme distincte des autres.
Si un développeur souhaite effectuer des opérations comme si les régions d’inclusions ou d’exclusions étaient
répétées tous les 360°, alors il doit lui-même ramener ses valeurs de longitudes entre -180° et 180° au préalable.
Toutes les fonctions <code class="SIS">add(…)</code>, <code class="SIS">contains(…)</code>,
<code class="SIS">intersect(…)</code>, <i>etc.</i> de toutes les enveloppes
définies dans le paquet <code class="SIS">org.apache.sis.geometry</code> effectuent leurs calculs selon cette convention.
</p>
<aside>
<h5>Généralisation à d’autres types d’axes</h5>
<p>
Cette section nomme spécifiquement la longitude car il constitue le cas le plus courant d’axe cyclique.
Mais dans les enveloppes de Apache <abbr title="Spatial Information System">SIS</abbr>, il n’est fait nul part mention explicite du cas de la longitude, ni de son cycle de 360°.
Les caractéristiques de la plage de valeurs de chaque axe (ses extremums, unités, type de cycle, <i>etc.</i>)
sont des attributs des objets <code class="GeoAPI">CoordinateSystemAxis</code>, indirectement associés aux enveloppes via le système de référence des coordonnées.
Apache <abbr>SIS</abbr> inspecte ces attributs pour déterminer de quelle façon il doit effectuer ses opérations.
Ainsi, tout axe associé au code <code class="GeoAPI">RangeMeaning.WRAPAROUND</code> bénéficiera du même traitement que la longitude.
Cela pourrait être par exemple un axe du temps dans des données climatologiques
(une “année” représentant la température moyenne de tous les mois de janvier, suivit de la moyenne de tous les mois de février,
<i>etc.</i>).
Cette généralisation s’applique aussi aux axes de longitudes définis par une plage de 0° à 360° plutôt que de -180° à 180°.
</p>
</aside>
<p>
Pour que les fonctions telles que <code class="SIS">add(…)</code> fonctionnent correctement,
tous les objets impliqués doivent utiliser le même système de référence des coordonnées, y compris
la même plage de valeurs. Ainsi, une enveloppe exprimant les longitudes dans la plage [-180 … +180]°
n’est pas compatible avec une enveloppe exprimant les longitudes dans la plage [0 … 360]°.
Les conversions, si nécessaires, sont à la charge de l’utilisateur
(la classe <code class="SIS">Envelopes</code> fournit des méthodes de commodités pour ce faire).
En outre, les coordonnées de l’enveloppe doivent être comprises dans les limites du système de coordonnées,
sauf si le développeur souhaite volontairement considérer (par exemple) 300° de longitude
comme un position distincte de -60°. La classe <code class="SIS">GeneralEnvelope</code>
fournit une méthode <code class="SIS">normalize()</code> pour ramener les coordonnées
dans les limites attendues, au prix parfois de valeurs <cite><i>lower</i></cite>
supérieures à la valeur <cite><i>upper</i></cite>.
</p>
<aside>
<h5>Le cas particulier de la plage [+0 … -0]</h5>
<p>
le Java (ou de manière plus générale, la norme IEEE 754) définit deux valeurs distinctes de zéro:
un zéro positif et un zéro négatif. Ces deux valeurs sont considérées égales lorsqu’on les compares avec l’opérateur <code>==</code> du Java.
Mais dans les enveloppes de <abbr title="Spatial Information System">SIS</abbr>, ils peuvent mener à des résultats opposés pour les axes ayant <code class="GeoAPI">RangeMeaning.WRAPAROUND</code>.
Une enveloppe dont la plage est [0 … 0], [-0 … -0] ou [-0 … +0] sera bien considérée comme une enveloppe vide,
mais la page [+0 … -0] sera au contraire considérée comme incluant la totalité des valeurs, jusqu’à l’infini.
Ce comportement est conforme à la définition de <code class="SIS">lowerCorner</code> et <code class="SIS">upperCorner</code>
qui considère +0 comme le point de départ, et -0 comme le point d’arrivé après avoir fait le tour des valeurs possibles.
Un tel comportement ne se produit que pour la paire de valeurs +0 et -0, et seulement dans cet ordre.
Pour toutes les autres valeurs réelles, si la condition <code>lower</code> <code>==</code> <code>upper</code>
est vrai, alors il est garanti que l’enveloppe est vide.
</p>
</aside>
</section>
</section>


<section>
<header>
<h1 id="Referencing"><span class="section-number">5.</span> Systèmes de références spatiales</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Geometry">Chapitre précédent</a></div><div class="next-chapter"><a href="#Utilities">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#ComponentsOfCRS">Composantes d’un système de références par coordonnées</a><ul>
<li><a href="#Ellipsoid">Géoïde et ellipsoïde</a></li>
<li><a href="#GeodeticDatum">Référentiel géodésique</a></li>
<li><a href="#CoordinateSystem">Systèmes de coordonnées</a><ul>
<li><a href="#AxisOrder">Ordre des axes</a></li></ul></li>
<li><a href="#GeographicCRS">Systèmes géographiques</a><ul>
<li><a href="#GeographicWKT">Format Well-Known Text</a></li></ul></li>
<li><a href="#ProjectedCRS">Projections cartographiques</a><ul>
<li><a href="#ProjectedWKT">Format Well-Known Text</a></li></ul></li>
<li><a href="#CompoundCRS">Dimensions verticales et temporelles</a><ul>
<li><a href="#CompoundWKT">Format Well-Known Text</a></li></ul></li></ul></li>
<li><a href="#GetCRS">Obtention d’un système de référence spatial</a><ul>
<li><a href="#CRSAuthorityFactory">Systèmes prédéfinis par des autorités</a></li>
<li><a href="#CRSParsing">Lecture d’une définition au format GML ou WKT</a></li>
<li><a href="#CRSFactory">Construction programmatique explicite</a></li>
<li><a href="#CRS_UserCode">Ajout de définitions</a></li></ul></li>
<li><a href="#CoordinateOperations">Opérations sur les coordonnées</a><ul>
<li><a href="#MathTransform">Exécution de opérations</a></li>
<li><a href="#TransformDerivative">Dérivées partielles des opérations</a><ul>
<li><a href="#DerivativeAndEnvelope">Utilité des dérivées pour la reprojection d’enveloppes</a></li>
<li><a href="#DerivativeAndRaster">Utilité des dérivées pour la reprojection d’images</a></li>
<li><a href="#GetDerivative">Obtention de la dérivée en un point</a></li></ul></li></ul></li>
<li><a href="#Formats">Formats de stockage des données</a></li>
<li><a href="#XML-ISO">Représentation des objets en XML</a><ul>
<li><a href="#XML-ISO-19115">Représentation des méta-données selon ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification d’instances déjà définies</a></li>
<li><a href="#nilReason">Représentation de valeurs manquantes</a></li></ul></li></ul></li></ul></nav>
<p>
Pour donner une position sur la Terre, on peut utiliser des noms tels que celui d’une ville ou une adresse postale
— on parle alors de références spatiales par <cite>identifiants</cite> —
ou on peut donner des valeurs numériques valides dans un système de coordonnées donné telles que les latitudes et longitudes
— on parle alors de références spatiales par <cite>coordonnées</cite>.
Chaque système de référence implique des approximations telles que
le choix de la forme géométrique (géoïde, ellipsoïde, <i>etc.</i>) utilisée comme approximation de la forme de la Terre,
le choix des propriétés géométriques (angles, distances, <i>etc.</i>) à préserver lors de la représentation d’une carte sur une surface plane, et
les pertes de précision lorsque l’on doit transformer des coordonnées vers des systèmes utilisant un <a href="#GeodeticDatum">référentiel</a> différent.
</p><p>
Une fausse croyance très répandue est que l’on peut éviter cette complexité en choisissant un seul système de référence des coordonnées
(typiquement <abbr title="World Geodetic System 1984">WGS84</abbr>) comme système universel pour toutes les données.
Les chapitres suivants expliqueront pourquoi la réalité n’est pas si simple.
Qu’un système universel réponde ou non aux besoins d’une application dépend de la précision désirée,
ainsi que du type de calculs que l’on souhaite effectuer avec les coordonnées.
Sauf indication contraire, Apache <abbr title="Spatial Information System">SIS</abbr> tente d’assurer une précision de 1 centimètre pour les coordonnées sur la Terre.
Mais la maîtrise de cette précision nécessite le respect de certaines conditions:
</p>
<ul>
<li>Rester dans la zone de validité du système telle que donnée par <code class="GeoAPI">ReferenceSystem​.getDomainOfValidity()</code>.</li>
<li>Savoir que les mesures de distances dans une projection cartographique donnée ne sont vraies qu’à certains endroits,
appelés par exemple « parallèles standards ».</li>
<li>Vérifier la précision des transformations de coordonnées, par exemple avec
<code class="GeoAPI">CoordinateOperation​.getCoordinateOperationAccuracy()</code>.</li>
<li>Trouver les paramètres les plus appropriées pour une transformation de coordonnées requiert l’usage d’une base de données géodétiques telles que <abbr>EPSG</abbr>.
Déclarer ces paramètres directement dans le <abbr>CRS</abbr> (par exemple avec un élément <code class="OGC">TOWGS84</code>) n’est souvent pas suffisant.</li>
</ul>
<article>
<header>
<h2>Bibliothèques de type « early binding » versus « late binding »</h2>
</header>
<p>
Le caractère universel du système <abbr title="World Geodetic System 1984">WGS84</abbr> rend tentante l’idée de l’utiliser comme système pivot,
afin de simplifier l’implémentation d’une bibliothèque de transformation de coordonnées.
La transformation d’une coordonnée d’un référentiel <var>A</var> vers un référentiel <var>B</var>
pourrait se faire en transformant d’abord de <var>A</var> vers <abbr>WGS84</abbr>, puis de <abbr>WGS84</abbr> vers <var>B</var>.
Il suffirait ainsi de stocker dans chaque objet <code class="GeoAPI">GeodeticDatum</code> les informations nécessaires à la transformation vers <abbr>WGS84</abbr>.
Cette approche était encouragée dans la version 1 du format <abbr>WKT</abbr>, qui définissait un élément <code>TOWGS84[…]</code> remplissant ce rôle.
Cette approche est désignée par <abbr>EPSG</abbr> sous le nom de « early binding »
car elle associe des informations sur la transformations de coordonnées très tôt dans la définition des objets géodésiques,
souvent directement au moment de la construction d’un object <code class="GeoAPI">GeographicCRS</code>.
Bien que <abbr>EPSG</abbr> reconnaisse que cette approche soit couramment employée, elle n’est pas recommandée pour plusieurs raisons:
</p>
<ul>
<li>Il existe parfois plusieurs transformations allant d’un référentiel <var>A</var> vers <var>B</var>,
chacune étant plus précise pour une région géographique donnée.</li>
<li>Certaines opérations sont conçues spécifiquement pour transformer de <var>A</var> vers <var>B</var>
et n’ont pas la même précision qu’aurait une autre transformation faisant un détour par <abbr>WGS84</abbr>.</li>
<li><abbr>WGS84</abbr> lui-même subit parfois des révisions, ce qui en fait une cible mouvante (bien que très lentement)
pour les bibliothèques de transformations de coordonnées.</li>
<li>Il existe d’autres systèmes globaux qui pourraient servir de pivot, par exemple le <cite>Galileo Reference Frame</cite> (<abbr>GTRF</abbr>)
mis en place par le concurrent européen du <abbr>GPS</abbr>.</li>
</ul>
<div class="example"><p><b>Exemple:</b>
la base de données géodésiques <abbr>EPSG</abbr> définie une cinquantaine de transformations de <abbr>NAD27</abbr> vers <abbr>NAD83</abbr>.
Dans une approche de type « early binding », le même système de référence « <abbr>NAD27</abbr> » représenté dans le format <abbr>WKT</abbr> 1
aurait besoin d’être défini avec un élément <code>TOWGS84[-8, 160, 176]</code> pour des coordonnées aux États-Unis,
ou avec un élément <code>TOWGS84[-10, 158, 187]</code> pour coordonnées aux Canada.
Différents paramètres existent aussi pour d’autres régions telles que Cuba.
Il n’est donc pas possible de représenter une telle diversité en associant un seul élément <code>TOWGS84[…]</code> à un système de référence des coordonnées.
Même en restreignant l’usage d’un référenciel au domaine de validité de son élément <code>TOWGS84[…]</code>,
ces transformations resteraient approximatives avec une précision de 10 mètres dans le cas des États-Unis.
Des transformations plus précises existent sous la forme des grilles de changements de référentiel <abbr>NADCON</abbr>,
mais ces grilles sont pour des transformations de <abbr>NAD27</abbr> vers <abbr>NAD83</abbr>
(qui se déplacent ensemble sur la même plaque continentale) et non vers <abbr>WGS84</abbr> (qui se déplace indépendamment).
Cette différence était souvent ignorée lorsque l’on considérait que <abbr>NAD83</abbr> et <abbr>WGS84</abbr>
étaient pratiquement équivalents, mais cette supposition est aujourd’hui à prendre avec plus de précautions.
</p></div>
<p>
<abbr>EPSG</abbr> recommande plutôt d’utiliser une approche dite « late binding »,
selon laquelle les méthodes et paramètres nécessaires aux transformations de coordonnées sont définis pour des paires
de référentiels « <var>A</var> vers <var>B</var> » (éventuellement complétées par leurs domaines de validité)
plutôt qu’associés à des référentiels pris isolément.
Apache <abbr title="Spatial Information System">SIS</abbr> est une implémentation de type « late binding »,
bien qu’une réminiscence de l’approche « early binding » existe toujours
sous la forme de la propriété <code class="SIS">DefaultGeodeticDatum​.getBursaWolfParameters()</code>.
<abbr>SIS</abbr> n’utilise cette dernière que comme solution de dernier recours
s’il ne peut pas appliquer l’approche « late binding » avec les systèmes de références donnés.
</p>
</article>
<p>
Le module <code class="SIS">sis-referencing</code> de Apache <abbr>SIS</abbr> fournit un ensemble de classes implémentant
les différentes spécialisations de l’interface <code class="GeoAPI">ReferenceSystem</code> ainsi que leurs composantes.
Ces implémentations permettent de stocker une description des systèmes de références spatiales
ainsi que leurs méta-données telles que la zone de validité.
Toutefois ces objets n’effectuent aucune opération sur les coordonnées.
Les <cite>conversions</cite> ainsi que les <cite>transformations</cite> de coordonnées sont le travail d’une autre famille de classes,
dont la racine est l’interface <code class="GeoAPI">CoordinateOperation</code>.
Ces classes seront discutées dans <a href="#CoordinateOperations">une autre section</a>.
</p>






<section>
<header>
<h2 id="ComponentsOfCRS"><span class="section-number">5.1.</span> Composantes d’un système de références par coordonnées</h2>
</header>
<p>
Les systèmes de références spatiales par coordonnées fournissent les informations nécessaires pour faire
correspondre des coordonnées numériques à des positions dans le monde réel. Dans Apache <abbr title="Spatial Information System">SIS</abbr>,
ils sont pratiquement tous représentés par des classes dont le nom se termine en <abbr>CRS</abbr>
(l’abréviation de <i>Coordinate Reference System</i> en anglais). Ces objets contiennent:
</p>
<ul>
<li>Un référentiel (<i>datum</i> en anglais),
qui indique entre autres quel ellipsoïde utiliser comme approximation de la forme de la terre.</li>
<li>Une description de chaque axe (nom, direction, unité de mesure, limites).</li>
<li>Parfois une liste de paramètres permettant de convertir les coordonnées d’un autre système.
C’est le cas notamment lorsqu’on utilise des projections cartographiques.</li>
</ul>
<p>
Ces systèmes sont décrits par la norme <abbr title="International Organization for Standardization">ISO</abbr> 19111 (<i>Referencing by Coordinates</i>),
qui remplace en grande partie une norme plus ancienne mais encore utilisée pour certains aspects,
<abbr>OGC 01-009</abbr> (<i>Coordinate Transformation Services</i>).
Ces normes sont complétées par deux autres standards définissant des formats d’échanges:
<abbr>ISO</abbr> 19136 et 19162 pour respectivement
le <cite>Geographic Markup Language</cite> (<abbr>GML</abbr>) — un format <abbr>XML</abbr> précis mais verbeux —
et le <cite>Well-Known Text</cite> (<abbr>WKT</abbr>) — un format texte plus facile à lire par les humains.
</p>

<h3 id="Ellipsoid"><span class="section-number">5.1.1.</span> Géoïde et ellipsoïde</h3>
<p>
La surface topographique réelle étant difficile à représenter mathématiquement, elle n’est pas utilisée directement en cartographie.
Une autre surface un peu plus facilement utilisable est le géoïde,
une surface sur laquelle la force gravitationnelle a partout la même valeur (surface équipotentielle du champ de gravité terrestre).
Cette surface est en tout point perpendiculaire à la direction indiquée par un fil à plomb (verticale du lieu).
Le géoïde coïnciderait avec le niveau moyen des mers s’il n’y avait ni vent ni courants marins permanents comme le Gulf Stream.
</p><p>
Tout en étant nettement plus lisse que la surface topographique,
le géoïde présente des creux et des bosses liés à l’inégale distribution des masses de la Terre.
Pour une utilisation mathématiquement plus aisée, le géoïde est donc approximé par un ellipsoïde.
Cette « figure de la Terre » est représentée dans GeoAPI par l’interface <code class="GeoAPI">Ellipsoid</code>,
qui constitue un élément fondamental des systèmes de références de type <code class="GeoAPI">GeographicCRS</code> et <code class="GeoAPI">ProjectedCRS</code>.
Plusieurs dizaines d’ellipsoïdes sont couramment employés pour la définition de référentiels.
Certains offrent une excellente approximation pour une région précise
au détriment des régions pour lesquelles le référentiel n’a pas été conçu,
et d’autres offrant un compromis pour l’ensemble de la planète.
</p>
<div class="example"><p><b>Exemple:</b>
la base de données géodétiques <abbr>EPSG</abbr> définit entre autres les ellipsoïdes « <abbr>WGS</abbr> 84 », « Clarke 1866 », « Clarke 1880 »,
« <abbr>GRS</abbr> 1980 » and « <abbr>GRS</abbr> 1980 Authalic Sphere » (une sphère de même surface que l’ellipsoïde <abbr>GRS</abbr> 1980).
Un ellipsoïde peut être utilisé en divers endroits de la planète ou peut être très spécifique à une région précise.
Par exemple au début du XX<sup>e</sup> siècle aux États-Unis, l’état du Michigan utilisait pour ses cartes un ellipsoïde basé
sur l’ellipsoïde « Clarke 1866 » mais auquel la longueur des axes a été allongée de 800 pieds.
Cette modification visait à tenir compte du niveau moyen de l’état au dessus du niveau de la mer.</p>
</div>

<h3 id="GeodeticDatum"><span class="section-number">5.1.2.</span> Référentiel géodésique</h3>
<p>
Pour définir un système géodésique dans un pays, l’état met en place un ellipsoïde de référence
qui épouse au mieux sur l’ensemble du pays la forme locale du géoïde.
L’écart entre cet ellipsoïde de référence et les creux et les bosses du géoïde reste généralement inférieur à 100 mètres.
Les paramètres qui permettent de lier un <code class="GeoAPI">Ellipsoid</code> à la surface de la Terre (par exemple la position de son centre)
sont représentées par un objet de type <code class="GeoAPI">GeodeticDatum</code>, que l’on traduit en français par « référentiel géodésique ».
Plusieurs <code class="GeoAPI">GeodeticDatum</code> peuvent utiliser le même <code class="GeoAPI">Ellipsoid</code>, mais centré ou orienté différemment.
</p><p>
Avant l’avènement des satellites, les mesures géodésiques se déroulaient exclusivement à la surface de la terre.
En conséquence, deux îles ou continents qui ne sont pas à portée visuelle l’un de l’autre n’étaient pas rattachés géodésiquement entre eux.
Ainsi les référentiels <cite>North American Datum 1983</cite> (<abbr>NAD83</abbr>) et
<cite>European Datum 1950</cite> (<abbr>ED50</abbr>) sont indépendants l’un de l’autre:
leurs ellipsoïdes de référence ont des centres distincts et des dimensions différentes.
Une même coordonnée géographique correspondra à des positions différentes dans le monde réel
selon que la coordonnée se réfère à l’un ou l’autre de ces référentiels.
</p><p>
L’invention du <abbr title="Global Positioning System">GPS</abbr> a précipité la création d’un système géodésique mondial,
nommé <abbr title="World Geodetic System 1984">WGS84</abbr>.
L’ellipsoïde de référence est alors unique et centré au centre de gravité de la terre.
Les <abbr>GPS</abbr> donnent à tout moment la position absolue du récepteur rapportée à ce système géodésique.
Mais <abbr>WGS84</abbr> étant un système mondial, il peut diverger significativement des systèmes locaux.
Par exemple l’écart entre <abbr>WGS84</abbr> et le système européen <abbr>ED50</abbr> est de l’ordre de 150 mètres,
et l’écart moyen par rapport au système de l’île de la Réunion 1947 est de 1,5 kilomètres.
Il ne faut donc pas rapporter aveuglement des positions <abbr>GPS</abbr> sur une carte.
Des correspondances avec les systèmes régionaux peuvent être nécessaires
et sont représentées dans GeoAPI sous forme d’objets de type <code class="GeoAPI">Transformation</code>.
</p><p>
Les généralisation de l’usage du système <abbr>WGS84</abbr> tend à réduire le besoin d’utiliser
les objets <code class="GeoAPI">Transformation</code> pour les données récentes, mais ne l’élimine pas complètement.
La Terre bouge sous l’effet de la tectonique des plaques et de nouveaux systèmes sont définis chaque année pour en tenir compte.
Par exemple bien que le référentiel <abbr>NAD83</abbr> a été défini à l’origine comme pratiquement équivalent à <abbr>WGS84</abbr>,
il existe maintenant (en 2016) un écart d’environ 1.5 mètres entre ces deux systèmes.
Le référentiel <cite>Japanese Geodetic Datum 2000</cite> était aussi défini comme pratiquement équivalent à <abbr>WGS84</abbr>,
mais le nouveau référentiel <cite>Japanese Geodetic Datum 2011</cite> s’en écarte.
Le référentiel <abbr>WGS84</abbr> lui-même, sensé correspondre à une définition à un instant donné,
a subit des révisions dues notamment à l’amélioration de la précision des instruments.
Ainsi il existe aujourd’hui au moins six versions de <abbr>WGS84</abbr>.
En outre beaucoups de bordures ont été définies légalement dans des référentiels plus anciens, par exemple <abbr>NAD27</abbr> aux États-Unis.
Mettre à jour dans un nouveau référentiel peut obliger à transformer des lignes droites ou des formes géométriques simples en des formes plus irrégulières
si on ne veut pas que des parcelles de terrain changent de propriétaire.
</p>

<h3 id="CoordinateSystem"><span class="section-number">5.1.3.</span> Systèmes de coordonnées</h3>
<p style="color: red">TODO</p>

<h4 id="AxisOrder"><span class="section-number">5.1.3.1.</span> Ordre des axes</h4>
<p>
L’ordre des axes est spécifié par l’autorité (typiquement une agence nationale) qui définit le
<cite>système de référence des coordonnées</cite> (<abbr>CRS</abbr>).
L’ordre dépend du type de <abbr>CRS</abbr> ainsi que du pays qui l’a définit.
Dans le cas des <abbr>CRS</abbr> de type géographique,
l’ordre (<var>latitude</var>, <var>longitude</var>) est utilisé par les géographes et les pilotes depuis des siècles.
Toutefois des développeurs de logiciels tendent à préférer l’ordre (<var>x</var>, <var>y</var>) pour tous systèmes de coordonnées.
Ces différentes pratiques entraînent des définitions contradictoires de l’ordre des axes pour pratiquement tous les <abbr>CRS</abbr>
de type <code class="GeoAPI">GeographicCRS</code>, pour certains <code class="GeoAPI">ProjectedCRS</code> dans l’hémisphère sud (Afrique du Sud, Australie, <i>etc.</i>)
et pour certaines projections polaires entre autres.
</p><p>
Les standards <abbr title="Open Geospatial Consortium">OGC</abbr> récents demandent d’ordonner les axes tel que spécifié par l’autorité qui a définit le <abbr>CRS</abbr>.
Mais des standards <abbr>OGC</abbr> plus anciens utilisaient l’ordre (<var>x</var>, <var>y</var>) inconditionnellement,
en ignorant les spécifications des autorités sur ce point.
Beaucoup de logiciels continuent d’utiliser cet ordre (<var>x</var>, <var>y</var>),
peut-être parce qu’une telle uniformisation rend l’implémentation et l’utilisation des <abbr>CRS</abbr> <em>en apparence</em> plus simple.
Apache <abbr title="Spatial Information System">SIS</abbr> supporte les deux conventions avec l’approche suivante:
par défaut, <abbr>SIS</abbr> construit les <abbr>CRS</abbr> avec les axes <em>dans l’ordre définit par l’autorité</em>.
Ces <abbr>CRS</abbr> sont construits par des appels à la méthode <code>CRS.forCode(String)</code>,
et l’ordre des axes effectif peut être vérifié après la création du <abbr>CRS</abbr> par un appel à <code>System.out​.println(crs)</code>.
Mais si l’ordre (<var>x</var>, <var>y</var>) est désiré pour des raisons de compatibilité avec d’anciens standards <abbr>OGC</abbr> ou avec d’autres logiciels,
alors les <abbr>CRS</abbr> peuvent être modifiés de manière à avoir la longitude en premier avec un appel à la méthode suivante:
</p>

<pre><code><code class="GeoAPI">CoordinateReferenceSystem</code> crs = …;  <code class="comment">// CRS obtenu de n’importe quelle façon.
</code>crs = AbstractCRS.castOrCopy(crs).forConvention(AxesConvention.RIGHT_HANDED)</code></pre>

<p>
Parmi les anciens standards de l’<abbr>OGC</abbr> qui utilisaient un ordre des axes non-conforme,
un standard influent était la version 1 du format <cite>Well Known Text</cite> (<abbr>WKT</abbr>).
D’après ce format largement utilisé, les définitions <abbr>WKT</abbr> 1 sans éléments <code>AXIS[…]</code> explicites
doivent être interprétés comme ayant ses axes dans l’ordre (<var>longitude</var>, <var>latitude</var>) ou (<var>x</var>, <var>y</var>).
Dans la version 2 du format <abbr>WKT</abbr>, les éléments <code>AXIS[…]</code> ne sont plus optionnel
et devrait contenir explicitement un sous-élément <code>ORDER[…]</code> pour rendre l’ordre voulu encore plus évident.
Mais si les éléments <code>AXIS[…]</code> sont malgré tout omis dans une définition <abbr>WKT</abbr> 2,
alors Apache <abbr>SIS</abbr> utilise l’ordre (<var>latitude</var>, <var>longitude</var>) par défaut.
Pour résumer:
</p>
<ul>
<li>L’ordre par défaut d’un <abbr>CRS</abbr> géographique en <abbr>WKT</abbr> 1 est (<var>longitude</var>, <var>latitude</var>) tel que spécifié par le standard <abbr>OGC</abbr> 01-009.</li>
<li>L’ordre par défaut d’un <abbr>CRS</abbr> géographique en <abbr>WKT</abbr> 2 est (<var>latitude</var>, <var>longitude</var>), mais c’est une interprétation spécifique de <abbr>SIS</abbr>
vu que la norme <abbr title="International Organization for Standardization">ISO</abbr> 19162 ne mentionne pas de comportement par défaut.</li>
</ul>
<p>
Pour éviter des ambiguïtés, les utilisateurs sont encouragés à toujours fournir explicitement les éléments <code>AXIS[…]</code> dans leurs <abbr>WKT</abbr>.
Le format <abbr>WKT</abbr> sera présenté plus en détails dans les sections suivantes.
</p>

<h3 id="GeographicCRS"><span class="section-number">5.1.4.</span> Systèmes géographiques</h3>
<p style="color: red">TODO</p>

<h4 id="GeographicWKT"><span class="section-number">5.1.4.1.</span> Format <i>Well-Known Text</i></h4>
<p style="color: red">TODO</p>

<h3 id="ProjectedCRS"><span class="section-number">5.1.5.</span> Projections cartographiques</h3>
<p>
Les projections cartographiques représentent une surface courbe (la Terre) sur une surface plane (une carte ou un écran d’ordinateur)
en contrôlant les déformations: on peut préserver les angles ou les surfaces, mais pas les deux à la fois.
Les propriétés géométriques à conserver dépendent de l’objet d’étude et du travail à effectuer.
Par exemple les pays plutôt allongés dans le sens Est-Ouest utilisent souvent une projection de Lambert,
alors que les pays plutôt allongés dans le sens Nord-Sud préfèrent une projection de Mercator Transverse.
</p>
<p style="color: red">TODO</p>

<h4 id="ProjectedWKT"><span class="section-number">5.1.5.1.</span> Format <i>Well-Known Text</i></h4>
<p style="color: red">TODO</p>

<h3 id="CompoundCRS"><span class="section-number">5.1.6.</span> Dimensions verticales et temporelles</h3>
<p style="color: red">TODO</p>

<h4 id="CompoundWKT"><span class="section-number">5.1.6.1.</span> Format <i>Well-Known Text</i></h4>
<p style="color: red">TODO</p>
</section>


<section>
<header>
<h2 id="GetCRS"><span class="section-number">5.2.</span> Obtention d’un système de référence spatial</h2>
</header>
<p style="color: red">TODO</p>

<h3 id="CRSAuthorityFactory"><span class="section-number">5.2.1.</span> Systèmes prédéfinis par des autorités</h3>
<p style="color: red">TODO</p>

<h3 id="CRSParsing"><span class="section-number">5.2.2.</span> Lecture d’une définition au format GML ou WKT</h3>
<p style="color: red">TODO</p>

<h3 id="CRSFactory"><span class="section-number">5.2.3.</span> Construction programmatique explicite</h3>
<p style="color: red">TODO</p>

<h3 id="CRS_UserCode"><span class="section-number">5.2.4.</span> Ajout de définitions</h3>
<p style="color: red">TODO</p>
</section>


<section>
<header>
<h2 id="CoordinateOperations"><span class="section-number">5.3.</span> Opérations sur les coordonnées</h2>
</header>
<p>
Étant donné un système de référence des coordonnées (<abbr>CRS</abbr>) <em>source</em> selon lequel sont exprimés des coordonnées existantes
et un système de référence des coordonnées <em>destination</em> selon lequel les coordonnées sont désirées,
Apache <abbr title="Spatial Information System">SIS</abbr> peut fournir une <em>opération sur les coordonnées</em> qui effectuera le travail de conversion ou de transformation.
La recherche d’une opération peut utiliser un troisième argument, optionnel mais recommandé: la région géographique des données à transformer.
Ce dernier argument est recommandé parce que les opérations sur les coordonnées sont souvent valides seulement dans une région géographique
(typiquement un pays ou une province particulière), et plusieurs transformations peuvent exister pour la même paire de <abbr>CRS</abbr>
source et destination mais avec des domaines de validité différents.
Il peut aussi y avoir des différentes transformations qui sont différents compromis entre la précision et le domaine de validité,
de sorte que spécifier à Apache <abbr>SIS</abbr> qu’on s’intéresse à une région plus petite
peut lui permettre de sélectionner une opération plus précise.
</p>
<div class="example"><p><b>Exemple:</b>
la base de données géodésiques <abbr>EPSG</abbr> (dans sa version 7.9) définit 77 opérations sur les coordonnées
allant du système géographique <cite>North American Datum 1927</cite> (EPSG:4267)
vers le système <cite>World Geodetic System 1984</cite> (EPSG:4326).
Il y a une opération valide seulement pour la transformation de coordonnées au Québec,
une autre opération valide pour la transformation de coordonnées au Texas mais à l’ouest de 100°W,
une autre opération pour le même état mais à l’est de 100°W, <i>etc</i>.
Si l’utilisateur ne spécifie pas la région géographique qui l’intéresse,
alors le comportement par défaut de Apache <abbr>SIS</abbr> est de sélectionner l’opération valide dans la plus grande région géographique.
Dans cet exemple, ce critère entraîne la sélection d’une opération valide pour le Canada, mais qui n’est pas valide pour les États-Unis.</p>
</div>
<p>
La façon la plus facile d’obtenir une opération sur les coordonnées à partir des informations présentées ci-dessus
est d’utiliser la classe de commodité <code class="SIS">org.apache.sis.referencing.CRS</code>:
</p>

<pre><code><code class="GeoAPI">CoordinateOperation</code> cop = CRS.findOperation(sourceCRS, targetCRS, areaOfInterest);</code></pre>

<p>
Parmi les information fournies par l’objet <code class="GeoAPI">CoordinateOperation</code> obtenu, on note en particulier:
</p>
<ul>
<li>Le <cite>domaine de validité</cite>, soit comme une description textuelle telle que « Canada – onshore and offshore »
ou comme les coordonnées géographiques d’une boîte englobante.</li>
<li>La <cite>précision</cite>, qui peut être n’importe quoi entre 1 centimètre et quelques kilomètres.</li>
<li>Le sous-type de l’opération sur les coordonnées. Parmi les sous-types possibles,
deux offrent les mêmes fonctionnalités mais avec une différence conceptuelle notable:
<ul class="verbose">
<li>
Les <strong>conversions</strong> de coordonnées sont entièrement définies par une formule mathématique.
Les conversions s’effectueraient avec une précision infinie s’il n’y avait pas les inévitables
erreurs d’arrondissements inhérents aux calculs sur des nombres réels.
Les projections cartographiques entrent dans cette catégorie.
</li><li>
Les <strong>transformations</strong> de coordonnées sont définies de manière empirique.
Elles ont souvent des erreurs de quelques mètres qui ne sont pas dues à des limites de la précision des ordinateurs.
Ces erreurs découlent du fait que la transformation utilisée n’est qu’une approximation d’une réalité plus complexe.
Les changements de référentiels tel que le passage de la
<cite>Nouvelle Triangulation Française</cite> (<abbr>NTF</abbr>) vers le
<cite>Réseau Géodésique Français 1993</cite> (<abbr>RGF93</abbr>) entrent dans cette catégorie.
</li>
</ul>
</li>
</ul>
<p>
Lorsque l’opération sur les coordonnées est une instance de <code class="GeoAPI">Transformation</code>,
il est possible que l’instance choisie par <abbr>SIS</abbr> ne soit qu’une parmi plusieurs possibilités en fonction de la région d’intérêt.
En outre, sa précision sera certainement moindre que la précision centimétrique que l’on peut attendre d’une <code class="GeoAPI">Conversion</code>.
Vérifier la zone de validité ainsi que la précision déclarées dans les méta-données de la transformation prend alors une importance particulière.
</p>

<h3 id="MathTransform"><span class="section-number">5.3.1.</span> Exécution de opérations</h3>
<p>
L’objet <code class="GeoAPI">CoordinateOperation</code> introduit dans la section précédente fournit des informations de haut-niveau
(<abbr>CRS</abbr> source et destination, zone de validité, précision, paramètres de l’opération, <i>etc</i>).
Le travail mathématique réel est effectué par un objet séparé, obtenu par un appel à <code class="GeoAPI">CoordinateOperation​.getMathTransform()</code>.
Contrairement aux instances de <code class="GeoAPI">CoordinateOperation</code>, les instances de <code class="GeoAPI">MathTransform</code> ne contiennent aucune méta-données.
Elles sont une sorte de boîte noire qui ignore tout des <abbr>CRS</abbr> source et destination
(en fait la même instance de <code class="GeoAPI">MathTransform</code> peut être utilisée pour différentes paires de <abbr>CRS</abbr> si le travail mathématique est le même).
En outre une instance de <code class="GeoAPI">MathTransform</code> peut être implémentée d’une manière très différente à ce que <code class="GeoAPI">CoordinateOperation</code> dit.
En particulier, plusieurs opérations conceptuellement différentes (par exemple rotations de la longitude,
changements d’unités de mesure, conversions entre deux projections de Mercator qui utilisent le même référentiel, <i>etc.</i>)
sont implémentées par <code class="GeoAPI">MathTransform</code> comme des <a href="#AffineTransform">transformations affines</a>
et concaténées pour des raisons d’efficacité, même si <code class="GeoAPI">CoordinateOperation</code> les affiche comme une chaîne d’opérations telles que la projection de Mercator.
La section « <a href="#CoordinateOperationSteps">chaîne d’opération conceptuelle versus réelle</a> » explique plus en détails les différences.
</p>
<p>
Le code Java suivant effectue une projection cartographique à partir de coordonnées géographiques selon le référentiel
<cite>World Geodetic System 1984</cite> (<abbr title="World Geodetic System 1984">WGS84</abbr>) vers des coordonnées selon le système <cite>WGS 84 / UTM zone 33N</cite>.
Afin de rendre l’exemple un peu plus simple, ce code utilise des constantes pré-définies dans la classe de commodité <code>CommonCRS</code>.
Mais des applications plus avancées voudront souvent utiliser des codes <abbr>EPSG</abbr> plutôt.
Notons que toutes les coordonnées géographiques dans ce code ont la latitude avant la longitude.
</p>

<pre><code><b>import</b> org.opengis.geometry.<code class="GeoAPI">DirectPosition</code>;
<b>import</b> org.opengis.referencing.crs.<code class="GeoAPI">CoordinateReferenceSystem</code>;
<b>import</b> org.opengis.referencing.operation.<code class="GeoAPI">CoordinateOperation</code>;
<b>import</b> org.opengis.referencing.operation.<code class="GeoAPI">TransformException</code>;
<b>import</b> org.opengis.util.<code class="GeoAPI">FactoryException</code>;
<b>import</b> org.apache.sis.referencing.CRS;
<b>import</b> org.apache.sis.referencing.CommonCRS;
<b>import</b> org.apache.sis.geometry.DirectPosition2D;

<b>public</b> <b>class</b> MyApp {
    <b>public</b> <b>static</b> <b>void</b> main(String[] args) <b>throws</b> <code class="GeoAPI">FactoryException</code>, <code class="GeoAPI">TransformException</code> {
        <code class="GeoAPI">CoordinateReferenceSystem</code> sourceCRS = CommonCRS.WGS84.geographic();
        <code class="GeoAPI">CoordinateReferenceSystem</code> targetCRS = CommonCRS.WGS84.UTM(40, 14);  <code class="comment">// Obtient la zone valide pour 14°E.
</code>        <code class="GeoAPI">CoordinateOperation</code> operation = CRS.findOperation(sourceCRS, targetCRS, <b>null</b>);

        <code class="comment">// Les lignes précédentes sont coûteuses et ne devraient être exécutées qu’une seule fois avant
</code>        <code class="comment">// de transformer plusieurs points.  Dans cet exemple, l’opération que nous obtenons est valide
</code>        <code class="comment">// pour des coordonnées dans la région géographique allant de 12°E à 18°E (zone 33) et 0°N à 84°N.
</code>
        <code class="GeoAPI">DirectPosition</code> ptSrc = <b>new</b> DirectPosition2D(40, 14);           <code class="comment">// 40°N 14°E
</code>        <code class="GeoAPI">DirectPosition</code> ptDst = operation.getMathTransform().transform(ptSrc, <b>null</b>);

        System.out.println(<i>"Source: "</i> + ptSrc);
        System.out.println(<i>"Target: "</i> + ptDst);
    }
}</code></pre>


<h3 id="TransformDerivative"><span class="section-number">5.3.2.</span> Dérivées partielles des opérations</h3>
<p>
La section précédente indiquait comment projeter les coordonnées d’un système de référence vers un autre.
Mais il existe une autre opération moins connue, qui consiste à calculer non pas la coordonnée projetée d’un point,
mais plutôt la dérivée de la fonction de projection cartographique en ce point.
Cette opération était définie dans une ancienne spécification du consortium Open Geospatial,
<a href="http://www.opengeospatial.org/standards/ct">OGC 01-009</a>, aujourd’hui un peu oubliée mais pourtant encore utile.
Appelons <var>P</var> une projection cartographique qui convertit une latitude et longitude (<var>φ</var>, <var>λ</var>) en degrés
vers une coordonnée projetée (<var>x</var>, <var>y</var>) en mètres.
Dans l’expression ci-dessous, nous représentons le résultat de la projection cartographique
sous forme d’une matrice colonne (la raison sera plus claire bientôt):
</p>

<div class="row-of-boxes">
<div style="min-width:350px; padding-right:60px">
<div class="caption">Équation</div>
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mi>P</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mtd></mtr>
<mtr><mtd><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mtd></mtr>
</mtable>
</mfenced>
</math>
</div>
<div style="min-width:500px; padding-left:60px">
<div class="caption">Code Java</div>
<pre style="margin:0"><code><code class="GeoAPI">DirectPosition</code> geographic = <b>new</b> DirectPosition2D(<var>φ</var>, <var>λ</var>);
<code class="GeoAPI">DirectPosition</code> projected = <var><b>P</b></var>.transform(geographic, <b>null</b>);
<b>double</b> <var>x</var> = projected.getOrdinate(0);
<b>double</b> <var>y</var> = projected.getOrdinate(1);</code></pre>
</div>
</div>

<p>La dérivée de la projection cartographique en ce même point peut se représenter par une matrice Jacobienne:</p>

<div class="row-of-boxes">
<div style="min-width:350px; padding-right:60px">
<div class="caption">Équation</div>
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<msup><mi>P</mi><mo>′</mo></msup><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo>
<mo>=</mo>
<msub><mi>JAC</mi><mrow><mi>P</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow></msub>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</div>
<div style="min-width:500px; padding-left:60px">
<div class="caption">Code Java</div>
<pre style="margin:0"><code><code class="GeoAPI">DirectPosition</code> geographic = <b>new</b> DirectPosition2D(<var>φ</var>, <var>λ</var>);
<code class="GeoAPI">Matrix</code> jacobian = <var><b>P</b></var>.derivative(geographic);
<b>double</b> dx_dλ = jacobian.getElement(0,1);
<b>double</b> dy_dφ = jacobian.getElement(1,0);</code></pre>
</div>
</div>

<p>
Les équations suivantes dans cette section abrégeront
∂<var>x</var>(<var>φ</var>, <var>λ</var>) par ∂<var>x</var> ainsi que
∂<var>y</var>(<var>φ</var>, <var>λ</var>) par ∂<var>y</var>,
mais il faut garder à l’esprit que chacune de ces valeurs dépendent de la coordonnée (<var>φ</var>, <var>λ</var>) donnée au moment du calcul de la matrice Jacobienne.
La première colonne de la matrice nous dit que si l’on effectue un petit déplacement de ∂<var>φ</var> degrés de latitude
à partir de la position (<var>φ</var>, <var>λ</var>)
— c’est-à-dire si on se déplace à la position geographique (<var>φ</var> + ∂<var>φ</var>, <var>λ</var>) —
alors la coordonnée projetée subira un déplacement de (∂<var>x</var>, ∂<var>λ</var>) metres
— c’est-à-dire qu’elle deviendra (<var>x</var> + ∂<var>x</var>, <var>y</var> + ∂<var>λ</var>).
De même la dernière colonne de la matrice nous indique quel sera le déplacement que subira la coordonnée projetée
si on effectue un petit déplacement de ∂<var>λ</var> degrés de longitude de la coordonnée géographique source.
On peut se représenter visuellement ces déplacements comme ci-dessous.
Cette figure représente la dérivée en deux points, <var>P</var><sub>1</sub> et <var>P</var><sub>2</sub>,
pour mieux illustrer le fait que le résultat varie en chaque point.
Dans cette figure, les vecteurs <var>U</var> et <var>V</var> désignent respectivement
la première et deuxième colonne des matrices Jacobiennes.
</p>

<div class="row-of-boxes">
<div>
<img alt="Exemple de dérivées d’une projection cartographique" src="../images/Derivatives.png" style="border: solid 1px"/>
</div><div>
<p>où les vecteurs sont reliés à la matrice par:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mtable><mtr>
<mtd>
<mover><mi>U</mi><mo>→</mo></mover><mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</mtd>
<mtd><mtext>et</mtext></mtd>
<mtd>
<mover><mi>V</mi><mo>→</mo></mover><mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</mtd>
</mtr></mtable>
</math>
</div>
</div>

<p>
Cette figure nous montre déjà une utilisation possible des dérivées:
elles donnent la direction des parallèles et des méridiens à une position donnée dans une projection cartographique.
Par extension, on peut aussi s’en servir pour déterminer si des axes sont interchangés,
ou si la direction d’un axe est renversée. Mais l’intérêt des dérivées ne s’arrête pas là.
</p>

<h4 id="DerivativeAndEnvelope"><span class="section-number">5.3.2.1.</span> Utilité des dérivées pour la reprojection d’enveloppes</h4>
<p>
Les systèmes d’information géographiques ont très fréquemment besoin de projeter une enveloppe.
Mais l’approche naïve, qui consisterait à projeter chacun des 4 coins du rectangle, ne suffit pas.
La figure ci-dessous montre une enveloppe avant le projection, et la forme géométrique que l’on obtiendrait
si on projetait finement l’enveloppe (pas seulement les 4 coins). Cette forme géométrique est plus complexe
qu’un simple rectangle à cause des courbures induites par la projection cartographique.
Construire une enveloppe rectangulaire qui engloberait les 4 coins de cette forme géométrique ne suffit pas,
car la surface en bas de la forme est plus basse que les 2 coins du bas.
Cette surface serait donc en dehors du rectangle.
</p>
<div class="row-of-boxes">
<div>
<div class="caption">Enveloppe avant la projection</div>
<img alt="Enveloppe dans un CRS géographique" src="../images/GeographicArea.png" style="border: solid 1px; margin-right: 15px"/>
</div><div>
<div class="caption">Forme géométrique après la projection</div>
<img alt="Forme géométrique dans un CRS projeté" src="../images/ConicArea.png" style="border: solid 1px; margin-left:  15px"/>
</div>
</div>
<p>
Une façon simple d’atténuer le problème est d’échantillonner un plus grand nombre de points sur chacun des
bords de la forme géométrique. On trouve ainsi des bibliothèques de <abbr>SIG</abbr> qui vont par exemple
échantillonner 40 points sur chaque bord, et construire un rectangle qui englobe tout ces points.
Mais même avec 40 points, les échantillons les plus proches peuvent encore être légèrement à côté du point le plus bas de la figure.
Une petite portion de la forme géométrique peut donc toujours se trouver en dehors du rectangle.
Il est tentant de considérer cette légère erreur comme négligeable, mais quelques pixels manquants
entraînent divers artefacts comme une apparence de quadrillage lors de l’affichage d’images tuilées,
ou une “pointe de tarte” manquante lors de la projection d’images sur un pôle.
Augmenter artificiellement d’un certain pourcentage la taille de l’enveloppe projetée peut éliminer ces artefacts dans certains cas.
Mais un pourcentage trop élevé fera traiter plus de données que nécessaire
(en particulier lorsque cela entraîne le chargement de nouvelles tuiles d’images),
alors qu’un pourcentage trop faible laissera quelques artefacts.
</p><p>
Les dérivées des projections cartographiques permettent de résoudre ce problème d’une manière plus efficace que la force brute.
La figure ci-dessous reprend la forme projetée en exagérant des déformations.
L’approche consiste à calculer la projection cartographiques des 4 coins comme dans l’approche naïve,
mais en récupérant aussi les dérivées de la projection de ces 4 coins.
Entre deux coins et avec leurs dérivées, on peut faire passer une et une seule courbe cubique
(de la forme <i>f(<var>x</var>)</i> = <var>C</var>₀ + <var>C</var>₁<var>x</var> + <var>C</var>₂<var>x</var>² + <var>C</var>₃<var>x</var>³),
dont on peut calculer les coefficients <var>C</var>.
Cette approximation (représentée en rouge ci-dessous) ne correspond pas tout-à-fait à la courbe désirée (en bleue) mais s’en rapproche.
Ce qui nous intéresse n’est pas vraiment les valeurs de l’approximation, mais plutôt la position de son minimum,
en particulier la longitude λ où se trouve ce minimum dans notre exemple (ligne pointillée verte).
L’avantage est que la position du minimum d’une courbe cubique est facile à calculer lorsque l’on connaît les valeurs de <var>C</var>.
En supposant que la longitude du minimum de la courbe cubique est proche de la longitude du minimum de la courbe réelle,
il suffit de calculer la projection cartographique d’un point à cette longitude plutôt que d’échantillonner 40 points sur le bord de l’enveloppe.
</p>
<div class="row-of-boxes">
<div>
<img alt="Approximation cubique d’un bord d’une enveloppe" src="../images/Approximation.png"/>
</div><div>
Légende:
<ul>
<li><b>En bleue:</b> la forme géométrique correspondant à la projection de l’enveloppe.
C’est la forme dont on souhaite avoir le rectangle englobant.</li>
<li><b>En rouge</b> (sous les hachures): L’approximation
<var>y</var> = <var>C</var>₀ + <var>C</var>₁λ + <var>C</var>₂λ² + <var>C</var>₃λ³.</li>
<li><b>En vert</b> (pointillés): La position λ<sub>m</sub> du minimum de l’approximation, trouvée en résolvant
0 = <var>C</var>₁ + 2<var>C</var>₂λ<sub>m</sub> + 3<var>C</var>₃λ<sub>m</sub>².
Il peut y avoir jusqu’à deux minimums pour une même courbe cubique.</li>
</ul>
</div>
</div>
<p>
Dans la pratique Apache <abbr title="Spatial Information System">SIS</abbr> utilise 8 points, soit les 4 coins plus un point au centre de chaque bord du rectangle à projeter,
afin de réduire le risque d’erreur qu’induirait une courbe trop tordue entre deux points.
Selon nos tests, l’utilisation de ces seuls 8 points avec leurs dérivées comme décrit ci-haut
donne un résultat plus précis que l’approche « force brute » utilisant un échantillonnage de 160 points sur les 4 bords du rectangle.
La précision de <abbr>SIS</abbr> pourrait être encore améliorée en répétant le processus à partir du minimum trouvée
(une ou deux itérations suffiraient peut-être).
</p><p>
Une économie de 150 points n’est pas énorme vu les performances des ordinateurs d’aujourd’hui.
Mais toute la discussion précédente utilisait une forme géométrique à deux dimensions en guise d’exemple,
alors que l’algorithme est applicable dans un espace à <var>n</var> dimensions.
Et de fait, l’implémentation de Apache SIS fonctionne pour un nombre arbitraire de dimensions.
Les économies apportées par cet algorithme par rapport à la force brute augmentent de manière exponentielle avec le nombre de dimensions.
</p><p>
L’approche décrite dans cette section est implémentée dans Apache <abbr>SIS</abbr>
par la méthode statique <code class="SIS">Envelopes​.transform(CoordinateOperation, Envelope)</code>.
Une méthode <code class="SIS">Envelopes​.transform(MathTransform, Envelope)</code> existe aussi comme alternative,
mais cette dernière ne devrait être utilisée que si on ne connaît pas l’objet <code class="GeoAPI">CoordinateOperation</code> utilisé.
La raison est que les objets de type <code class="GeoAPI">MathTransform</code> ne contiennent pas d’information sur le système de coordonnées sous-jasent,
ce qui empêche la méthode <code class="SIS">Envelopes​.transform(…)</code> de savoir comment gérer les points aux pôles.
</p>


<h4 id="DerivativeAndRaster"><span class="section-number">5.3.2.2.</span> Utilité des dérivées pour la reprojection d’images</h4>
<p>
La projection cartographique d’une image s’effectue en préparant une image initialement vide qui contiendra le résultat de l’opération,
puis à remplir cette image en itérant sur tous les pixels. Pour chaque pixel de l’image <em>destination</em>, on obtient la coordonnées
du pixel correspondant dans l’image source en utilisant <em>l’inverse</em> de la projection cartographique que l’on souhaite appliquer.
La position obtenue ne sera pas nécessairement au centre du pixel de l’image source, ce qui implique qu’une interpolation de la valeur
(ou de la couleur dans l’image ci-dessous) peut être nécessaire.
</p>
<div style="display:flex; flex-direction:column; align-items:center">
<div style="display:flex; justify-content:space-between; width:564px">
<div class="caption">Image source</div>
<div class="caption">Image destination</div>
</div>
<img alt="Reprojection d’images" src="../images/RasterProjection.png"/>
</div>
<p>
Toutefois, calculer la projection inverse pour chacun des pixels peut être relativement lent.
Afin d’accélérer les calculs, on utilise parfois une <cite>grille d’interpolation</cite>
dans laquelle on a pré-calculé les <em>coordonnées</em> de la projection inverse de seulement quelques points.
Les coordonnées des autres points se calculent alors par des interpolations bilinéaires entre les points pré-calculés,
calculs qui pourraient éventuellement tirer parti d’accélérations matérielles sous forme de <cite>transformations affines</cite>.
Cette approche est implémentée par exemple dans la bibliothèque <cite>Java Advanced Imaging</cite> avec l’objet <code>WarpGrid</code>.
Elle offre en outre l’avantage de permettre de réutiliser la grille autant de fois que l’on veut si on a plusieurs images de même
taille à projeter aux mêmes coordonnées géographiques.
</p><p>
Mais une difficulté de cette approche est de déterminer combien de points il faut pré-calculer pour que l’erreur
(la différence entre une position interpolée et la position réelle) ne dépasse pas un certain seuil (par exemple ¼ de pixel).
On peut procéder en commençant par une grille de taille 3×3, puis en augmentant le nombre de points de manière itérative:
</p>
<div class="row-of-boxes">
<div>
<img alt="Warp grid" src="../images/WarpGrid.png"/>
</div><div>
Légende:
<ul>
<li><b>Points bleus:</b>  première itération (9 points).</li>
<li><b>Points verts:</b>   seconde itération (25 points, dont 16 nouveaux).</li>
<li><b>Points rouges:</b> troisième itération (81 points, dont 56 nouveaux).</li>
</ul>
Si l’on continue…
<ul>
<li>Quatrième itération: 289 points, dont 208 nouveaux.</li>
<li>Cinquième itération: 1089 points, dont 800 nouveaux.</li>
<li>Sixième itération: 4225 points, dont 3136 nouveaux.</li>
<li>…</li>
</ul>
</div>
</div>
<p>
L’itération s’arrête lorsque, après avoir calculé de nouveaux points, on a vérifié que la différence entre les
coordonnées projetées et les coordonnées interpolées de ces nouveaux points est inférieure au seuil qu’on s’est fixé.
Malheureusement cette approche nous permet seulement de déterminer <strong>après</strong> avoir calculé de nouveaux points…
que ce n’était pas la peine de les calculer. C’est un peu dommage vu que le nombre de nouveaux points requis par chaque itération
est environ 3 fois la <em>somme</em> du nombre de nouveaux points de <em>toutes</em> les itérations précédentes.
</p><p>
Les dérivées des projections cartographiques nous permettent d’améliorer cette situation en estimant
si c’est la peine d’effectuer une nouvelle itération <strong>avant</strong> de la faire.
L’idée de base est de vérifier si les dérivées de deux points voisins sont presque pareilles,
auquel cas on présumera que la transformation entre ces deux points est pratiquement linéaire.
Pour quantifier « presque pareil », on procède en calculant l’intersection entre les tangentes aux deux points
(une information fournie par les dérivées), et en calculant la distance entre cette intersection et la droite
qui relie les deux points (la ligne pointillée dans la figure ci-dessous).
</p>
<p style="text-align:center"><img alt="Intersection of derivatives" src="../images/IntersectionOfDerivatives.png" style="border: solid 1px"/></p>
<p>
Dans l’approche sans dérivées, l’itération s’arrête lorsque la distance entre la ligne pointillée (positions interpolées)
et la ligne rouge (positions projetées) est inférieure au seuil de tolérance, ce qui implique de calculer la position projetée.
Dans l’approche avec dérivées, on remplace la position projetée par l’intersection des deux tangentes (carré bleu foncé).
Si la courbe n’est pas trop tordue – ce qui ne devrait pas être le cas entre deux points suffisamment proches –
la courbe réelle passera à quelque part entre la droite pointillée et l’intersection.
On s’évite ainsi des projections cartographiques, en apparence une seule dans cette illustration,
mais en fait beaucoup plus dans une grille de transformation d’image (3× la somme des itérations précédentes).
</p>

<h4 id="GetDerivative"><span class="section-number">5.3.2.3.</span> Obtention de la dérivée en un point</h4>
<p>
Cette discussion n’aurait pas un grand intérêt si le coût du calcul des dérivées des projections cartographiques
était élevé par rapport aux coût de la projection des points. Mais lorsque l’on dérive analytiquement les équations
des projections, on constate que les calculs des positions et de leurs dérivées ont souvent plusieurs termes en commun.
En outre le calcul des dérivées est simplifié lorsque le code Java effectuant les projections ne se concentre que sur le « noyau » non-linéaire,
après s’être déchargé des parties linéaires en les déléguant aux transformations affines comme le fait <abbr title="Spatial Information System">SIS</abbr>.
Les implémentations des projections cartographiques dans Apache <abbr>SIS</abbr> tirent parti de ces propriétés
en ne calculant les dérivées que si elles sont demandées,
et en offrant une méthode qui permet de projeter un point et obtenir sa dérivée en une seule opération
afin de permettre à <abbr>SIS</abbr> de réutiliser un maximum de termes communs.
Exemple:</p>

<pre><code><code class="SIS">AbstractMathTransform</code> projection = ...;         <code class="comment">// Une projection cartographique de Apache SIS.
</code><b>double</b>[] sourcePoint = {longitude, latitude};   <code class="comment">// La coordonnée géographique que l’on veut projeter.
</code><b>double</b>[] targetPoint = <b>new</b> <b>double</b>[2];           <code class="comment">// Là où on mémorisera le résultat de la projection.
</code><code class="GeoAPI">Matrix</code>   derivative  = projection.<code class="SIS">transform</code>(sourcePoint, 0, targetPoint, 0, <b>true</b>);</code></pre>

<p>
Si seule la matrice Jacobienne est désirée (sans la projection du point), alors la méthode
<code class="GeoAPI">MathTransform​.derivative(DirectPosition)</code> offre une alternative plus lisible.
</p><p>
Apache <abbr>SIS</abbr> est capable combiner les dérivées des projections cartographiques de la même façon que pour les projections de coordonnées:
concaténation d’une chaîne de transformations, inversion, opérer sur un sous-ensemble des dimensions, <i>etc.</i>
Les opérations inverses (des systèmes projetés vers géographiques)
sont souvent beaucoup plus compliquées à implémenter que les opérations originales (des systèmes géographiques vers projetés),
mais par chance la matrice Jacobienne d’une fonction inverse est simplement l’inverse de la matrice Jacobienne de la fonction originale.
Une fonction inverse peut donc implémenter le calcul de sa dérivée comme suit:
</p>

<pre><code>@Override
<b>public</b> <code class="GeoAPI">Matrix</code> derivative(<code class="GeoAPI">DirectPosition</code> p) <b>throws</b> <code class="GeoAPI">TransformException</code> {
    <code class="GeoAPI">Matrix</code> jac = inverse().derivative(transform(p));
    <b>return</b> <code class="SIS">Matrices</code>.inverse(jac);
}</code></pre>

</section>
</section>


<section>
<header>
<h2 id="Formats"><span class="section-number">5.4.</span> Formats de stockage des données</h2>
</header>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> peut lire et écrire des données spatiales et leurs méta-données associées dans différents formats.

</p>




<section>
<header>
<h2 id="XML-ISO"><span class="section-number">5.5.</span> Représentation des objets en <abbr>XML</abbr></h2>
</header>
<p>
Les objets définis par les standards <abbr title="Open Geospatial Consortium">OGC</abbr>/<abbr title="International Organization for Standardization">ISO</abbr> doivent pouvoir être échangés sur internet
entre des machines distantes, utilisant des logiciels différents écrits dans des langages différents.
Quelques uns des formats les plus connus sont
le <abbr>WKT</abbr> (<i>Well-Known Text</i>) et
le <abbr>WKB</abbr> (<i>Well-Known Binary</i>).
Mais le format le plus exhaustif et souvent considéré comme la référence est le <abbr>XML</abbr>,
au point où la façon de représenter les objets <abbr>ISO</abbr> dans ce format fait parfois l’objet d’un standard international à part entière.
Ainsi, les classes de méta-données sont décrites dans le standard <abbr>ISO</abbr> 19115-1 (une spécification dite <i>abstraite</i>),
alors que la représentation de ces classes en <abbr>XML</abbr> est décrite par les standards <abbr>ISO</abbr> 19115-3 et 19139.
</p>
<p>
Les différents standards <abbr>OGC</abbr>/<abbr>ISO</abbr> n’emploient pas tous la même stratégie pour exprimer les objets en <abbr>XML</abbr>.
Le standard <abbr>ISO</abbr> 19115-3 en particulier emploie une approche plus verbeuse que les autres normes,
et fera l’objet d’une <a href="#XML-ISO-19115">section particulière</a>.
Mais la plupart des formats <abbr>XML</abbr> ont en commun de définir des types et des attributs supplémentaires
qui ne font pas partie des spécifications abstraites d’origines.
Ces attributs supplémentaires sont habituellement propres au <abbr>XML</abbr> et peuvent ne pas apparaître directement dans l’<abbr title="Application Programming Interface">API</abbr> de Apache <abbr title="Spatial Information System">SIS</abbr>.
Certains de ces attributs, notamment <code class="OGC">id</code>, <code class="OGC">uuid</code> et <code>xlink:href</code>,
restent toutefois accessibles sous forme de paires clé-valeurs.
</p>
<p>
Les documents <abbr>XML</abbr> peuvent employer les préfixes de leur choix,
mais les préfixes suivants sont couramment employés dans la pratique.
Ils apparaissent donc par défaut dans les documents produits par Apache <abbr>SIS</abbr>.
Ces préfixes sont définis dans la classe <code class="SIS">org.apache.sis.xml.Namespaces</code>.
</p>
<table>
<caption>Préfixes d’espaces de noms <abbr>XML</abbr> courants</caption>
<tr>
<th>Préfixe</th>
<th>Espace de nom</th>
</tr>
<tr>
<td><code class="OGC">gco</code></td>
<td><code>http://www.isotc211.org/2005/gco</code></td>
</tr>
<tr>
<td><code class="OGC">gfc</code></td>
<td><code>http://www.isotc211.org/2005/gfc</code></td>
</tr>
<tr>
<td><code class="OGC">gmd</code></td>
<td><code>http://www.isotc211.org/2005/gmd</code></td>
</tr>
<tr>
<td><code class="OGC">gmi</code></td>
<td><code>http://www.isotc211.org/2005/gmi</code></td>
</tr>
<tr>
<td><code class="OGC">gmx</code></td>
<td><code>http://www.isotc211.org/2005/gmx</code></td>
</tr>
<tr>
<td><code class="OGC">gml</code></td>
<td><code>http://www.opengis.net/gml/3.2</code></td>
</tr>
<tr>
<td><code>xlink</code></td>
<td><code>http://www.w3.org/1999/xlink</code></td>
</tr>
</table>

<aside>
<h2>Outils de lecture et d’écriture de documents <abbr>XML</abbr></h2>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> emploie différentes bibliothèques pour lire et écrire différents type d’objets.
La bibliothèque utilisée dépend de la complexité de l’objet et des contraintes de performances.
Par exemple les annotations de <abbr title="Java Architecture for XML Binding">JAXB</abbr> ont l’avantage d’être proches du code,
ce qui facilite la maintenance de la correspondance entre le Java et le <abbr>XML</abbr>.
En revanche <abbr title="Simple API for XML">SAX</abbr> a l’avantage d’être performant.
De manière générale, Apache <abbr>SIS</abbr> emploie:
</p>
<ul>
<li>
<abbr>JAXB</abbr> pour les objets qui ne sont pas répétés très souvent dans le document
mais dont la structure est complexe, avec des arborescences profondes.
L’ensemble des méta-données <abbr title="International Organization for Standardization">ISO</abbr> 19115-3 est un exemple typique.
</li>
<li>
<abbr>SAX</abbr> pour les objets relativement simples mais pouvant exister en très grand nombre.
L’ensemble des points dans une géométrie est un exemple typique.
</li>
<li>
<abbr title="Document Object Model">DOM</abbr> comme une alternative à <abbr>JAXB</abbr>
lorsque les éléments <abbr>XML</abbr> ne correspondent pas directement à des attributs Java.
Les <i>features</i> en sont un exemple, car leur structure est dynamique.
</li>
</ul>
</aside>




<section>
<header>
<h3 id="XML-ISO-19115"><span class="section-number">5.5.1.</span> Représentation des méta-données selon <abbr title="International Organization for Standardization">ISO</abbr> 19115-3</h3>
</header>
<p>
Pour chaque classe de méta-donnée, il existe un type <abbr>XML</abbr> portant le même nom que dans la spécification abstraite
(par exemple <code class="OGC">gmd:MD_Metadata</code> et <code class="OGC">gmd:CI_Citation</code>).
Tous ces types peuvent être employés comme racine d’un document <abbr>XML</abbr>.
Ainsi, il est possible d’écrire un document représentant un objet <code class="OGC">MD_Metadata</code> complet,
ou d’écrire un document représentant seulement un objet <code class="OGC">CI_Citation</code>.
</p>
<p>
Le standard <abbr>ISO</abbr> 19139 dispose le contenu de ces objets d’une manière inhabituelle:
pour chaque propriété dont le type de la valeur est lui-même une autre classe du standard <abbr>ISO</abbr> 19139,
la valeur est enveloppée dans un élément qui représente son type plutôt que d’être écrite directement.
Par exemple dans un objet de type <code class="OGC">CI_Citation</code>,
la valeur de la propriété <code class="OGC">citedResponsibleParty</code>
est enveloppée dans un élément <code class="OGC">CI_Responsibility</code>.
Cette pratique double la profondeur de l’arborescence, en introduisant une duplication
à tous les niveaux pour chaque valeur, comme dans l’exemple suivant:
</p>

<pre><samp class="xml"><b>&lt;MD_Metadata&gt;</b>
  &lt;identificationInfo&gt;
    <b>&lt;MD_DataIdentification&gt;</b>
      &lt;citation&gt;
        <b>&lt;CI_Citation&gt;</b>
          &lt;citedResponsibleParty&gt;
            <b>&lt;CI_Responsibility&gt;</b>
              &lt;party&gt;
                <b>&lt;CI_Party&gt;</b>
                  &lt;contactInfo&gt;
                    <b>&lt;CI_Contact&gt;</b>
                      &lt;onlineResource&gt;
                        <b>&lt;CI_OnlineResource&gt;</b>
                          &lt;linkage&gt;
                            &lt;URL&gt;http://www.opengeospatial.org&lt;/URL&gt;
                          &lt;/linkage&gt;
                        <b>&lt;/CI_OnlineResource&gt;</b>
                      &lt;/onlineResource&gt;
                    <b>&lt;/CI_Contact&gt;</b>
                  &lt;/contactInfo&gt;
                <b>&lt;/CI_Party&gt;</b>
              &lt;/party&gt;
            <b>&lt;/CI_Responsibility&gt;</b>
          &lt;/citedResponsibleParty&gt;
        <b>&lt;/CI_Citation&gt;</b>
      &lt;/citation&gt;
    <b>&lt;/MD_DataIdentification&gt;</b>
  &lt;/identificationInfo&gt;
<b>&lt;/MD_Metadata&gt;</b></samp></pre>

<p>
L’exemple précédent, comme tous les documents conformes à <abbr>ISO</abbr> 19139,
est donc constitué d’une alternance systématique de deux types d’éléments <abbr>XML</abbr> imbriqués:
</p>
<ol>
<li><p>
Il y a d’abord le nom de la propriété, qui commence toujours par une lettre minuscule (en ignorant les préfixes).
Dans les <abbr title="Application Programming Interface">API</abbr> Java, chaque propriété correspond à une méthode de la classe englobante.
Dans l’exemple ci-haut, <code class="OGC">gmd:identificationInfo</code> (une propriété de la classe <code class="OGC">MD_Metadata</code>)
correspond à la méthode <code class="GeoAPI">Metadata​.getIdentificationInfo()</code>.
</p></li>
<li><p>
Sous chaque propriété se trouve le type de la valeur, sauf si elle a été remplacée par une référence
(la <a href="#gco-id">sous-section suivante</a> suivante approfondira ce sujet).
Le type de la valeur est un élément <abbr>XML</abbr> dont le nom commence toujours par une lettre majuscule, en ignorant les préfixes.
Dans l’exemple ci-haut nous avions <code class="OGC">MD_DataIdentification</code>, qui correspond à l’interface Java <code class="GeoAPI">DataIdentification</code>.
C’est cet élément <abbr>XML</abbr> qui contient les valeurs de la propriété.
</p></li>
</ol>

<p>
Afin de réduire la complexité des bibliothèques, GeoAPI et Apache <abbr title="Spatial Information System">SIS</abbr>
n’exposent publiquement qu’une vision unifiée de ces deux types d’éléments.
L’<abbr>API</abbr> public correspond essentiellement au deuxième groupe.
Toutefois, lors de l’écriture d’un document <abbr>XML</abbr>, des éléments du premier groupe doivent être temporairement recréés.
Les classes qui y correspondent sont définies dans des paquets internes de <abbr>SIS</abbr>.
Ces classes peuvent être ignorées, sauf si le développeur souhaite implémenter ses propres classes
dont les instances devront être lues et écrites par <abbr title="Java Architecture for XML Binding">JAXB</abbr>.
</p>

<aside id="XML-SIS">
<h3>Stratégie d’implémentation dans Apache <abbr title="Spatial Information System">SIS</abbr></h3>
<p>
Les paquets <code class="SIS">org.apache.sis.internal.jaxb.*</code> (non-publiques)
définissent des adaptateurs <abbr title="Java Architecture for XML Binding">JAXB</abbr> pour tous les types d’objet <abbr title="International Organization for Standardization">ISO</abbr>.
Ces adaptateurs sont de toute façon nécessaires pour permettre à <abbr>JAXB</abbr>
d’obtenir les classes <abbr>SIS</abbr> implémentant les interfaces de GeoAPI.
De manière opportuniste, <abbr>SIS</abbr> en fait à la fois des adaptateurs <abbr>JAXB</abbr>
et des objets enveloppants le “vrai” objet à lire ou écrire.
Cette utilisation double permet d’éviter d’avoir à doubler le nombre de classes
(déjà très élevé) présents dans les paquets internes.
</p>
<h4>Convention de nommage dans les schémas <abbr title="XML Schema Definition">XSD</abbr></h4>
<p>
Les schémas <abbr>XSD</abbr> de l’<abbr title="Open Geospatial Consortium">OGC</abbr> définissent pour chaque élément du premier groupe
un type dont le nom se termine par “<code class="OGC">_PropertyType</code>”.
Pour le second groupe, chaque élément a un type dont le nom se termine par “<code class="OGC">_Type</code>”.
Les “<code class="OGC">_PropertyType</code>” peuvent avoir un groupe d’attributs
(notamment <code class="OGC">gco:uuidref</code> et <code>xlink:href</code>)
que les schémas <abbr>XSD</abbr> nomment collectivement <code class="OGC">gco:ObjectReference</code>.
Ces attributs n’ont pas de méthodes Java dédiées, mais sont accessibles indirectement via l’interface
<code class="SIS">IdentifiedObject</code> décrite dans la sous-section suivante.
</p>
</aside>


<h4 id="gco-id"><span class="section-number">5.5.1.1.</span> Identification d’instances déjà définies</h4>
<p>
L’élément englobant peut contenir un attribut <code class="OGC">id</code> ou <code class="OGC">uuid</code>.
Si un de ces attributs est présent, l’élément englobé peut être complètement omis;
il sera remplacé au moment de la lecture par l’élément référencé par l’attribut.
Dans l’exemple suivant, la partie gauche définie un élément associé à l’identifiant “<code>mon_id</code>”,
alors que la partie droite référence cet élément:
</p>

<div class="row-of-boxes">
<div>
<div class="caption">Définir un identifiant</div>
<pre style="margin-top: 6pt"><samp class="xml">&lt;MD_MetaData&gt;
  &lt;identificationInfo&gt;
    &lt;MD_DataIdentification id=<i>"<b>mon_id</b>"</i>&gt;
      <code class="comment">&lt;!-- insérer ici des propriétés filles --&gt;</code>
    &lt;/MD_DataIdentification&gt;
  &lt;/identificationInfo&gt;
&lt;/MD_MetaData&gt;</samp></pre>
</div>
<div>
<div class="caption">Utiliser l’identifiant défini</div>
<pre style="margin-top: 6pt"><samp class="xml">&lt;MD_MetaData&gt;
  &lt;identificationInfo xlink:href=<i>"<b>#mon_id</b>"</i>/&gt;
&lt;/MD_MetaData&gt;</samp></pre>
</div>
</div>

<p>
Le choix de l’attribut à utiliser dépend de la portée de l’élément référencé:
</p>
<ul>
<li>
<code class="OGC">id</code> n’est valide qu’à l’intérieur du document <abbr>XML</abbr>
qui définit l’objet ainsi référencé.
</li>
<li>
<code class="OGC">uuid</code> peut être valide à l’extérieur du document <abbr>XML</abbr>,
mais quelqu’un doit maintenir une base de données fournissant les objets pour chaque UUID donnés.
</li>
<li>
<code>xlink:href</code> peut faire référence à un autre document <abbr>XML</abbr> accessible sur internet.
</li>
</ul>
<p>
Dans la bibliothèque <abbr title="Spatial Information System">SIS</abbr>, tous les objets susceptibles d’être identifiés dans un document <abbr>XML</abbr>
implémentent l’interface <code class="SIS">org.apache.sis.xml.IdentifiedObject</code>.
Chaque instance de cette interface fournit une vue de ses identifiants sous forme de <code>Map&lt;Citation,String&gt;</code>,
dans lequel la clé <code class="GeoAPI">Citation</code> identifie le type d’identifiant et la valeur est l’identifiant lui-même.
Quelques constantes représentant différents types d’identifiants sont énumérées dans <code class="SIS">IdentifierSpace</code>,
notamment <code class="SIS">ID</code>, <code class="SIS">UUID</code> et <code class="SIS">HREF</code>.
Chacune de ces clés peut être associée à une valeur d’un type différent (habituellement <code>String</code>,
<code>UUID</code> ou <code>URI</code>) selon la clé.
Par exemple le code suivant définit une valeur pour l’attribut <code class="OGC">uuid</code>:
</p>

<pre><code><b>import</b> org.apache.sis.metadata.iso.<code class="SIS">DefaultMetadata</code>;
<b>import</b> org.apache.sis.xml.<code class="SIS">IdentifierSpace</code>;
<b>import</b> java.util.UUID;

<b>public</b> <b>class</b> MyClass {
    <b>public</b> <b>void</b> myMethod() {
        UUID identifier = UUID.randomUUID();
        <code class="SIS"><code class="SIS">DefaultMetadata</code></code> metadata = <b>new</b> <code class="SIS"><code class="SIS">DefaultMetadata</code></code>();
        metadata.<code class="SIS">getIdentifierMap().putSpecialized</code>(<code class="SIS">IdentifierSpace</code>.UUID, identifier);
    }
}</code></pre>

<p>
Bien que ce mécanisme aie été définit dans le but de mieux supporter les représentations des
attributs <abbr>XML</abbr> du groupe <code class="OGC">gco:ObjectIdentification</code>,
il permet aussi de manière opportuniste de manipuler d’autres types d’identifiants.
Par exemple les attributs <code class="GeoAPI">ISBN</code> et <code class="GeoAPI">ISSN</code>
de <code class="GeoAPI">Citation</code> peuvent être manipulés de cette manière.
Les méthodes de l’interface <code class="SIS">IdentifiedObject</code> fournissent donc un endroit unique
où peuvent être manipulés tous types d’identifiants (pas seulement <abbr>XML</abbr>) associés à un objet.
</p>



<h4 id="nilReason"><span class="section-number">5.5.1.2.</span> Représentation de valeurs manquantes</h4>
<p>
Lorsqu’une propriété n’est pas définie, la méthode correspondante de GeoAPI retourne généralement <code>null</code>.
Toutefois les choses se compliquent lorsque la propriété manquante est une valeur considérée comme obligatoire par le standard <abbr title="International Organization for Standardization">ISO</abbr> 19115.
Le standard <abbr>ISO</abbr> 19139 autorise l’omission de propriétés obligatoires à la condition d’indiquer pourquoi la valeur est manquante.
Les raisons peuvent être que la propriété ne s’applique pas (<code class="OGC">inapplicable</code>),
que la valeur existe probablement mais n’est pas connue (<code class="OGC">unknown</code>),
que la valeur pourrait ne pas exister (<code class="OGC">missing</code>),
qu’elle ne peut pas être divulguée (<code class="OGC">withheld</code>), <i>etc.</i>
La transmission de cette information nécessite l’utilisation d’un objet non-nul même lorsque la valeur est manquante.
<abbr title="Spatial Information System">SIS</abbr> procède en retournant un objet qui, en plus d’implémenter l’interface GeoAPI attendue,
implémente aussi l’interface <code class="SIS">org.apache.sis.xml.NilObject</code>.
Cette interface marque les instances dont toutes les méthodes retournent une collection vide,
un tableau vide, <code>null</code>, <code>NaN</code>, <code>0</code> ou <code>false</code>,
dans cet ordre de préférence selon ce que les types de retours des méthodes permettent.
Chaque instance implémentant <code class="SIS">NilObject</code> fournit une méthode
<code class="SIS">getNilReason()</code> indiquant pourquoi l’objet est nul.
</p>
<p>
Dans l’exemple suivant, la partie gauche montre un élément <code class="OGC">CI_Citation</code>
contenant un élément <code class="OGC">CI_Series</code>, alors que dans la partie droite la série est inconnue.
Si l’élément <code class="OGC">CI_Series</code> avait été complètement omis,
alors la méthode <code class="GeoAPI">Citation​.getSeries()</code> retournerait <code>null</code> en Java.
Mais en présence d’un attribut <code class="OGC">nilReason</code>, l’implémentation <abbr>SIS</abbr>
de <code class="SIS">getSeries()</code> retournera plutôt un objet implémentant à la fois les interfaces
<code class="GeoAPI">Series</code> et <code class="SIS">NilReason</code>,
et dont la méthode <code class="SIS">getNilReason()</code> retournera la constante <code class="SIS">UNKNOWN</code>.
</p>

<div class="row-of-boxes">
<div>
<div class="caption">Information présente</div>
<pre style="margin-top: 6pt"><samp class="xml">&lt;CI_Citation&gt;
  &lt;series&gt;
    &lt;CI_Series&gt;
      <code class="comment">&lt;!-- insérer ici des propriétés filles --&gt;</code>
    &lt;/CI_Series&gt;
  &lt;/series&gt;
&lt;/CI_Citation&gt;</samp></pre>
</div>
<div>
<div class="caption">Information absente</div>
<pre style="margin-top: 6pt"><samp class="xml">&lt;CI_Citation&gt;
  &lt;series nilReason=<i>"unknown"</i>/&gt;
&lt;/CI_Citation&gt;</samp></pre>
</div>
</div>
</section>
</section>
</section>


<section>
<header>
<h1 id="Utilities"><span class="section-number">6.</span> Classes et méthodes utilitaires</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Referencing">Chapitre précédent</a></div><div class="next-chapter"><a href="#GeoAPI-details">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#ComparisonModes">Modes de comparaisons des objets</a></li>
<li><a href="#ObjectConverters">Convertisseurs d’objets</a></li>
<li><a href="#Internationalization">Internationalisation</a><ul>
<li><a href="#LocalizedString">Chaînes de caractères distinctes pour chaque conventions locales</a></li>
<li><a href="#InternationalString">Instance unique pour toutes les conventions locales</a></li>
<li><a href="#Locale.ROOT">Convention Locale.ROOT</a></li>
<li><a href="#UnicodePoint">Traitement des caractères</a><ul>
<li><a href="#Whitespaces">Interprétation des espaces blancs</a></li></ul></li></ul></li></ul></nav>
<p>
Ce chapitre décrit des aspects de Apache <abbr title="Spatial Information System">SIS</abbr> qui s’appliquent à l’ensemble de la bibliothèque.
La plupart de ces utilitaires ne sont pas spécifiques aux systèmes d’information spatiales.
</p>






<section>
<header>
<h2 id="ComparisonModes"><span class="section-number">6.1.</span> Modes de comparaisons des objets</h2>
</header>
<p>
Il existe différentes opinions sur la façon d’implémenter la méthode <code>Object​.equals(Object)</code> du Java standard.
Selon certains, il doit être possible de comparer différentes implémentations d’une même interface ou classe de base.
Mais cette politique nécessite que chaque interface ou classe de base définisse entièrement dans sa Javadoc les critères ou calculs
que doivent employer les méthodes <code>equals(Object)</code> et <code>hashCode()</code> dans toutes les implémentations.
Cette approche est choisie notamment par <code>java.util.Collection</code> et ses interfaces filles.
La transposition de cette approche aux centaines d’interfaces de GeoAPI serait toutefois une entreprise ardue,
qui risquerait d’être assez peu suivie par les diverses implémentations.
En outre, elle se fait au détriment de la possibilité de prendre en compte des attributs supplémentaires dans les interfaces filles
si cette possibilité n’a pas été spécifiée dans l’interface parente.
Cette contrainte découle des points suivants du contrat des méthodes <code>equals(Object)</code> et <code>hashCode()</code>:
</p>
<ul>
<li><code>A.equals(B)</code> implique <code>B.equals(A)</code> (symétrie);</li>
<li><code>A.equals(B)</code> et <code>B.equals(C)</code> implique <code>A.equals(C)</code> (transitivité);</li>
<li><code>A.equals(B)</code> implique <code>A.hashCode() == B.hashCode()</code>.</li>
</ul>
<p>
Par exemple ces trois contraintes sont violées si <var>A</var> (et éventuellement <var>C</var>)
peuvent contenir des attributs que <var>B</var> ignore.
Pour contourner cette difficulté, une approche alternative consiste à exiger que les objets comparés par la méthode
<code>Object​.equals(Object)</code> soient exactement de la même classe, c’est-à-dire que <code>A.getClass() == B.getClass()</code>.
Cette approche est parfois considérée contraire aux principes de la programmation orientée objets.
Dans la pratique, pour des applications relativement complexes, l’importance accordée à ces principes dépend du contexte dans lequel les objets sont comparés:
si les objets sont ajoutés à un <code>HashSet</code> ou utilisés comme clés dans un <code>HashMap</code>,
alors nous avons besoin d’un strict respect du contrat de <code>equals(Object)</code> et <code>hashCode()</code>.
Mais si le développeur compare les objets lui-même, par exemple pour vérifier si des informations qui l’intéresse ont changées,
alors les contraintes de symétrie, transitivité ou de cohérence avec les valeurs de hachages peuvent ne pas être pertinentes pour lui.
Des comparaisons plus permissives peuvent être souhaitables, allant parfois jusqu’à tolérer de légers écarts dans les valeurs numériques.
</p>
<p>
Afin de donner une certaine flexibilité aux développeurs, un grand nombre de classes de la bibliothèque <abbr title="Spatial Information System">SIS</abbr>
implémentent l’interface <code class="SIS">org.apache.sis.util.LenientComparable</code>, qui défini une méthode <code class="SIS">equals(Object, ComparisonMode)</code>.
Les principaux modes de comparaisons sont:
</p>
<ul>
<li><p>
<b><code class="SIS">STRICT</code></b> — Les objets comparés doivent être de la même classe
et tous leurs attributs strictement égaux, y compris d’éventuels attributs publics propres à l’implémentation.
</p></li>
<li><p>
<b><code class="SIS">BY_CONTRACT</code></b> — Les objets comparés doivent implémenter la même interface de GeoAPI (ou tout autre standard),
mais n’ont pas besoin d’être de la même classe d’implémentation. Seuls les attributs définis dans l’interface sont comparés;
tout autres attributs propres à l’implémentation — même s’ils sont publics — sont ignorés.
</p></li>
<li><p>
<b><code class="SIS">IGNORE_METADATA</code></b> — Comme <code class="SIS">BY_CONTRACT</code>,
mais ne compare que les attributs qui influencent les opérations (calculs numériques ou autre) effectuées par l’objet.
Par exemple dans un référentiel géodésique, la longitude (par rapport à Greenwich) du méridien d’origine sera pris en compte
alors que le nom de ce méridien sera ignoré.
</p></li>
<li><p>
<b><code class="SIS">APPROXIMATIVE</code></b> — Comme <code class="SIS">IGNORE_METADATA</code>,
mais tolère de légères différences dans les valeurs numériques.
</p></li>
</ul>
<p>
Le mode par défaut, utilisé par les toutes les méthodes <code>equals(Object)</code> de <abbr>SIS</abbr>,
est <code class="SIS">STRICT</code>. Ce mode est choisi pour une utilisation sécuritaire — notamment avec <code>HashMap</code> —
sans nécessiter de définitions rigoureuses des méthodes <code>equals(Object)</code> et <code>hashCode()</code> dans toutes les interfaces.
Avec ce mode, l’ordre des objets (<code>A.equals(B)</code> ou <code>B.equals(A)</code>) n’a pas d’importance.
C’est toutefois le seul mode à offrir cette garantie.
Dans l’expression <code>A.equals(B)</code>, le mode <code class="SIS">BY_CONTRACT</code>
(et donc par extension tous les autres modes qui en dépendent) ne comparera que les propriétés connues de <code>A</code>,
sans se soucier de savoir si <code>B</code> en connaît davantage.
</p>
</section>


<section>
<header>
<h2 id="ObjectConverters"><span class="section-number">6.2.</span> Convertisseurs d’objets</h2>
</header>
<p>
Il est parfois nécessaire de convertir une instance d’un type source <code>&lt;S&gt;</code> vers un type destination <code>&lt;T&gt;</code>
alors que ces types ne sont pas connus au moment de la compilation.
Divers projets (Apache Common Convert, Spring, <i>etc.</i>)
ont créé leur propres interfaces pour effectuer des conversions d’objets entre des types connus seulement au moment de l’exécution.
Les détails varient, mais ces interfaces ressemblent typiquement à l’interface suivante:
</p>

<pre><code><b>interface</b> ObjectConverter&lt;S,T&gt; {   <code class="comment">// Certains projets utilisent seulement "Converter" comme nom d’interface.
</code>    T apply(S object);             <code class="comment">// Un autre nom de méthode souvent utilisé par les autres projets est "convert".
</code>}</code></pre>

<p>
Comme d’autres projets, Apache <abbr title="Spatial Information System">SIS</abbr> définit sa propre interface <code>ObjectConverter</code>.
La principale différence entre l’interface de <abbr>SIS</abbr> est celle que l’on retrouve dans d’autres projets
est que <abbr>SIS</abbr> fournit des informations à propos de certaines propriétés mathématiques des convertisseurs.
Un convertisseur de Apache <abbr>SIS</abbr> peut avoir aucune, une ou plusieurs des propriétés suivantes:
</p>
<dl>
<dt><dfn>Injective</dfn></dt>
<dd>Une fonction est injective si aucune paire de valeurs de <var>S</var> ne peut produire la même valeur de <var>T</var>.
<div class="example"><p><b>Exemple:</b>
la conversion <code>Integer</code> → <code>String</code> effectuée par <code>Integer​.toString()</code>
est une fonction <cite>injective</cite> car si deux valeurs de type <code>Integer</code> ne sont pas égales,
alors il est garanti que leurs conversions produiront différentes valeurs de <code>String</code>.
En revanche la conversion <code>String</code> → <code>Integer</code> effectuée par <code>Integer​.valueOf(String)</code>
n’est <strong>pas</strong> une fonction injective
parce que plusieurs valeurs distinctes de type <code>String</code> peuvent être converties vers la même valeur de type <code>Integer</code>.
Par exemple les conversions des chaînes de caractères "42", "+42" et "0042" donnent toutes la même valeur entière 42.
</p></div>
</dd>

<dt><dfn>Surjective</dfn></dt>
<dd>Une fonction est surjective si chaque valeur de <var>T</var> peut être produite à partir d’au moins une valeur de <var>S</var>.
<div class="example"><p><b>Exemple:</b>
la conversion <code>String</code> → <code>Integer</code> effectuée par <code>Integer​.valueOf(String)</code>
est une fonction <cite>surjective</cite> car chaque valeur de type <code>Integer</code> peut être produite
à partir d’un moins une valeur de <code>String</code>.
En revanche la conversion <code>Integer</code> → <code>String</code> effectuée par <code>Integer​.toString()</code>
n’est <strong>pas</strong> une fonction surjective parce qu’elle ne peut pas produire toutes les valeurs possibles de type <code>String</code>.
Par exemple il n’y a aucun moyen de produire la valeur "ABC" avec la méthode <code>Integer​.toString()</code>.
</p></div>
</dd>

<dt><dfn>Bijective</dfn></dt>
<dd>Une fonction est bijective s’il y a une relation de un-à-un entre les valeurs de <var>S</var> et de <var>T</var>.
<div class="example"><p><b>Note:</b>
la propriété <cite>bijective</cite> est définie ici pour des raisons de clarté,
mais en fait n’a pas d’item explicite dans l’énumération <code>FunctionProperty</code> de Apache <abbr>SIS</abbr>.
Ce n’est pas nécessaire puisqu’une fonction qui est à la fois <cite>injective</cite> et <cite>surjective</cite>
est nécessairement bijective.
</p></div>
</dd>

<dt><dfn>Préservant l’ordre</dfn></dt>
<dd>Une fonction préserve l’ordre si toute séquence de valeurs <var>S</var> croissantes correspond à une séquence de valeurs <var>T</var> croissantes.
<div class="example"><p><b>Exemple:</b>
la conversion du type <code>Integer</code> vers <code>Long</code> préserve l’ordre naturel des éléments.
Toutefois la conversion du type <code>Integer</code> vers <code>String</code> ne préserve <strong>pas</strong> l’ordre naturel,
parce que des séquences des nombres entiers croissants ont un ordre différents
lorsque les chaînes de caractères sont classées par ordre lexicographique.
Par exemple 1, 2, 10 devient "1", "10", "2".
</p></div>
</dd>

<dt><dfn>Renversant l’ordre</dfn></dt>
<dd>Une fonction renverse l’ordre si toute séquence de valeurs <var>S</var> croissantes correspond à une séquence de valeurs <var>T</var> décroissantes.
<div class="example"><p><b>Exemple:</b>
une conversion qui inverse le signe des nombres.
</p></div>
</dd>
</dl>
<p>
Ces informations peuvent sembler inutiles lorsque l’on convertit des valeurs sans tenir compte du contexte où elles apparaissent.
Mais lorsque la valeur à convertir fait parti d’un objet plus gros, alors ces informations peuvent impacter la façon dont la valeur convertie sera utilisée.
Par exemple la conversion d’une plage de valeurs représentée par [<var>min</var> … <var>max</var>] est directe lorsque la fonction de conversion préserve l’ordre.
Mais si la fonction de conversion renverse l’ordre, alors les valeurs minimale et maximale doivent être interchangées.
Par exemple si la fonction de conversion inverse le signe des valeurs, alors la plage convertie sera [-<var>max</var> … -<var>min</var>].
Si la fonction de conversion ne préserve ni ne renverse l’ordre, alors la plage de valeurs ne peut pas être convertie du tout
(parce qu’elle ne contiendrait plus le même ensemble de valeurs) même si les valeurs individuelles auraient pu être converties.
</p>
</section>


<section>
<header>
<h2 id="Internationalization"><span class="section-number">6.3.</span> Internationalisation</h2>
</header>
<p>
Dans une architecture où un programme exécuté sur un serveur fournit ses données à plusieurs clients,
les conventions locales du serveur ne sont pas nécessairement les mêmes que celles des clients.
Les conventions peuvent différer par la langue, mais aussi par la façon d’écrire les valeurs numériques
(même entre deux pays parlant la même langue) ainsi que par le fuseau horaire.
Pour produire des messages conformes aux conventions du client, <abbr title="Spatial Information System">SIS</abbr> emploie
deux approches qui diffèrent par leur niveau de granularité: au niveau des messages eux-mêmes,
ou au niveau des objets produisant les messages. L’approche utilisée détermine aussi s’il est
possible de partager une même instance d’un objet pour toutes les langues.
</p>

<h3 id="LocalizedString"><span class="section-number">6.3.1.</span> Chaînes de caractères distinctes pour chaque conventions locales</h3>
<p>
Certaines classes ne sont conçues que pour fonctionner selon une convention locale à la fois.
C’est évidemment le cas des implémentations standards de <code>java.text.Format</code>,
puisqu’elles sont entièrement dédiées au travail d’internationalisation.
Mais c’est aussi le cas de d’autres classes moins évidentes comme
<code>javax.imageio.ImageReader</code> et <code>ImageWriter</code>.
Lorsque une de ces classes est implémentée par <abbr title="Spatial Information System">SIS</abbr>,
nous l’identifions en implémentant l’interface <code class="SIS">org.apache.sis.util.Localized</code>.
La méthode <code class="SIS">getLocale()</code> de cette interface permet alors de déterminer
selon quelles conventions locales l’instance produira ses messages.
</p>
<p>
Une autre classe qui fournit différentes méthodes pour différentes langues est <code>java.lang.Throwable</code>.
L’<abbr title="Application Programming Interface">API</abbr> standard du Java définie deux méthodes pour obtenir un message d’erreur:
<code>getMessage()</code> et <code>getLocalizedMessage()</code>.
Habituellement, ces deux méthodes retournent la même chaîne de caractères.
Toutefois certaines exceptions lancées par Apache <abbr>SIS</abbr> peuvent utiliser différentes langues.
La politique que <abbr>SIS</abbr> tente d’appliquer autant que possible est:
</p>
<ul>
<li><code>getMessage()</code> retourne le message dans la langue par défaut de la <abbr title="Java Virtual Machine">JVM</abbr>.
Dans une architecture client-serveur, c’est souvent la langue du système hébergeant le serveur.
C’est la méthode recommandée pour enregistrer des messages dans le journal des événements,
à l’intention des administrateurs systèmes.</li>
<li><code>getLocalizedMessage()</code> retourne le message dans une langue qui dépend du contexte dans lequel l’exception s’est produite.
C’est souvent la langue qui a été configurée pour une instance particulière de <code class="GeoAPI">Format</code> ou <code class="SIS">DataStore</code>,
que l’on peut présumer être la langue du client se connectant au serveur.
C’est la méthode recommandée pour afficher un message dans une fenêtre sur le poste de l’utilisateur.</li>
</ul>

<div class="example"><p><b>Exemple:</b>
Si une erreur s’est produite alors qu’un client japonais s’est connecté à un serveur européen,
le message fournit par <code>getLocalizedMessage()</code> pourra être envoyé à l’utilisateur au Japon
alors que le message fournit par <code>getMessage()</code> pourra être enregistré dans le journal des événements du serveur.
Ainsi, l’administrateur système pourra plus facilement analyser l’erreur même s’il ne connaît pas la langue du client.
</p></div>
<p>
La classe utilitaire <code class="SIS">org.apache.sis.util.Exceptions</code> fournit
des méthodes de commodité pour obtenir des messages selon des conventions locales spécifiées
lorsque cette information est disponible.
</p>



<h3 id="InternationalString"><span class="section-number">6.3.2.</span> Instance unique pour toutes les conventions locales</h3>
<p>
Les <abbr title="Application Programming Interface">API</abbr> définit par <abbr title="Spatial Information System">SIS</abbr> ou hérités de GeoAPI privilégient plutôt l’utilisation du type
<code class="GeoAPI">InternationalString</code> là où une valeur de type <code>String</code> serait susceptible d’être localisée.
Cette approche permet de différer le processus d’internationalisation au moment d’obtenir
une chaîne de caractères plutôt qu’au moment de construire l’objet qui les contient.
C’est particulièrement utile pour les classes immuables qui serviront à créer des instances uniques
indépendamment des conventions locales.
</p>
<div class="example"><p><b>Exemple:</b>
Il existe dans <abbr>SIS</abbr> une seule instance de type
<code class="GeoAPI">OperationMethod</code> représentant la projection de Mercator, quelle que soit la langue du client.
Mais sa méthode <code class="GeoAPI">getName()</code> fournit (indirectement)
une instance de <code class="GeoAPI">InternationalString</code> telle que
<code>toString(Locale.ENGLISH)</code> retourne <cite>Mercator Projection</cite>
alors que <code>toString(Locale.FRENCH)</code> retourne <cite>Projection de Mercator</cite>.
</p></div>
<p>
En définissant des objets spatiaux indépendemment des conventions locales, on réduit les risques de sur-coûts de calculs.
Par exemple il est plus facile de détecter que deux cartes emploient la même projection cartographique si cette dernière
est représentée par la même instance de <code class="GeoAPI">CoordinateOperation</code>, même si la projection
porte différents noms selon les pays. En outre, certain types de <code class="GeoAPI">CoordinateOperation</code>
peuvent nécessiter des grilles de transformation de coordonnées, ce qui accroît l’intérêt de partager une instance unique
pour des raisons d’économie de mémoire.
</p>



<h3 id="Locale.ROOT"><span class="section-number">6.3.3.</span> Convention <code>Locale.ROOT</code></h3>
<p>
Toutes les méthodes <abbr title="Spatial Information System">SIS</abbr> recevant ou retournant une valeur de type <code>Locale</code>
acceptent la valeur <code>Locale.ROOT</code>. Cette valeur est interprétée comme signifiant de ne pas localiser le texte.
La notion de <cite>texte non-localisé</cite> est un peu fausse, puisqu’il faut bien choisir une convention de format.
Mais cette convention, bien que très proche de l’anglais, sera généralement légèrement différente.
Par exemple:
</p>
<ul>
<li>
Les identifiants sont écrits tels qu’ils apparaissent dans les diagrammes <abbr title="Unified Modeling Language">UML</abbr>,
par exemple <cite>blurredImage</cite> au lieu de <cite>Blurred image</cite>.
</li>
<li>
Les dates sont écrites selon le format <abbr title="International Organization for Standardization">ISO</abbr> 8601,
qui ne correspond pas aux conventions anglaises.
</li>
<li>
Les nombres sont écrits à l’aide de leurs méthodes <code>toString()</code> plutôt qu’à l’aide d’un <code>java.text.NumberFormat</code>.
Il en résulte des différences dans le nombre de chiffres significatifs, l’utilisation de la notation exponentielle et l’absence de séparateur des milliers.
</li>
</ul>



<h3 id="UnicodePoint"><span class="section-number">6.3.4.</span> Traitement des caractères</h3>
<p>
Les chaînes de caractères en Java utilisent l’encodage UTF-16. Il existe une correspondance directe
entre les valeurs de type <code>char</code> et la très grande majorité des caractères, ce
qui facilite l’utilisation des chaînes lorsque ces caractères suffisent.
Mais certains caractères Unicode ne sont pas représentables par un seul <code>char</code>.
Ces <i>caractères supplémentaires</i> comprennent certains idéogrammes,
mais aussi des symboles routiers et géographiques dans la plage 1F680 à 1F700.
Le support de ces caractères supplémentaires nécessite des itérations un peu plus complexes
que le cas classique où l’on supposait une correspondance directe.
Ainsi, au lieu de la boucle de gauche ci-dessous, les applications internationales devraient
généralement utiliser la boucle de droite:
</p>

<div class="row-of-boxes">
<div>
<div class="caption">Boucle à éviter</div>
<pre style="margin-top: 6pt"><code><b>for</b> (<b>int</b> i=0; i&lt;string.length(); i++) {
    <b>char</b> c = string.charAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// Un espace blanc a été trouvé.
</code>    }
}</code></pre>
</div>
<div>
<div class="caption">Boucle recommandée</div>
<pre style="margin-top: 6pt"><code><b>for</b> (<b>int</b> i=0; i&lt;string.length();) {
    <b>int</b> c = string.codePointAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// Un espace blanc a été trouvé.
</code>    }
    i += Character.charCount(c);
}</code></pre>
</div>
<div>
<div class="caption">Exemples de caractères supplémentaires</div>
<center>(l’affichage dépend des capacités du navigateur)</center>
<p style="font-size: 40px">&#128649; &#128677; &#128679; &#128683;
&#128687; &#128696; &#128698; &#128697; &#128708; &#128685;</p>
</div>
</div>

<p>
<abbr title="Spatial Information System">SIS</abbr> supporte les caractères supplémentaires en utilisant la boucle de droite lorsque nécessaire.
Mais la boucle de gauche reste occasionnellement utilisée lorsqu’il est connu que les caractères recherchés ne sont
pas des caractères supplémentaires, même si la chaîne dans laquelle on fait la recherche peut en contenir.
</p>



<h4 id="Whitespaces"><span class="section-number">6.3.4.1.</span> Interprétation des espaces blancs</h4>
<p>
Le Java standard fournit deux méthodes pour déterminer si un caractères est un espace blanc:
<code>Character​.isWhitespace(…)</code> et <code>Character​.isSpaceChar(…)</code>.
Ces deux méthodes diffèrent dans leurs interprétations des espaces insécables, des tabulations et des retours à la ligne.
La première méthode est conforme à l’interprétation couramment utilisée dans des langages telles que le Java, C/C++ et <abbr>XML</abbr>,
qui considère les tabulations et retours à la ligne comme des espaces blancs,
alors que les espaces insécables sont interprétés comme des caractères non-blanc.
La seconde méthode — strictement conforme à la définition Unicode — fait l’interprétation inverse.
</p>
<p>
<abbr title="Spatial Information System">SIS</abbr> emploie ces deux méthodes dans des contextes différents.
<code>isWhitespace(…)</code> est utilisée pour <em>séparer</em> les éléments d’une liste (nombres, dates, mots, <i>etc.</i>),
tandis que <code>isSpaceChar(…)</code> est utilisée pour ignorer les espaces blancs <em>à l’intérieur</em> d’un seul élément.
</p>
<div class="example"><p><b>Exemple:</b>
Supposons une liste de nombres représentés selon les conventions françaises.
Chaque nombre peut contenir des <em>espace insécables</em> comme séparateurs des milliers,
tandis que les différents nombres de la liste peuvent être séparés par des espaces ordinaires, des tabulations ou des retours à la ligne.
Pendant l’analyse d’un nombre, on veut considérer les espaces insécables comme faisant partie du nombre,
alors qu’une tabulation ou un retour à la ligne indique très probablement une séparation entre ce nombre et le nombre suivant.
On utilisera donc <code>isSpaceChar(…)</code>.
Inversement, lors de la séparation des nombres de la liste, on veut considérer les tabulations et
les retours à la ligne comme des séparateurs mais pas les espaces insécables.
On utilisera donc <code>isWhitespace(…)</code>.
Le rôle des espaces ordinaires, qui pourraient s’appliquer aux deux cas, doit être décidé en amont.
</p></div>
<p>
Dans la pratique, cette distinction se traduit pas une utilisation de <code>isSpaceChar(…)</code>
dans les implémentations de <code>java.text.Format</code>,
et une utilisation de <code>isWhitespace(…)</code> dans pratiquement tout le reste
de la bibliothèque <abbr>SIS</abbr>.
</p>
</section>
</section>


<section>
<header>
<h1 id="GeoAPI-details"><span class="section-number">7.</span> Relation entre GeoAPI et les standards</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Utilities">Chapitre précédent</a></div><div class="next-chapter"><a href="#Tests">Chapitre suivant</a> ➡</div></div></nav>
</header>

<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#GeoAPI-modules">Les modules de GeoAPI</a></li>
<li><a href="#SpecificationToInterfaces">Des spécifications de l’OGC aux interfaces Java</a><ul>
<li><a href="#UML-annotation">Correspondances explicites entre GeoAPI et les spécifications abstraites</a></li>
<li><a href="#MappingToJDK">Correspondances implicites avec le JDK standard</a></li></ul></li>
<li><a href="#ReduceDependency">Réduire la dépendance directe envers Apache SIS</a><ul>
<li><a href="#UML-annotation-indep">Correspondances entre GeoAPI et les spécifications abstraites</a></li>
<li><a href="#ServiceLoader">Obtenir une implémentation des interfaces de GeoAPI</a><ul>
<li><a href="#GeoAPI-simple">Fournir sa propre implémentation</a></li></ul></li></ul></li></ul></nav>
<p>
Le projet GeoAPI a été brièvement présenté <a href="#GeoAPI">en introduction</a> de ce document.
Cet annexe donne plus de détails à propos de la relation entre GeoAPI et les standards internationaux.
L’objectif est de permettre aux développeurs qui le souhaite de prendre un peu plus d’indépendance
par rapport aux spécificités de GeoAPI ou de l’implémentation d’Apache SIS.
</p>






<section>
<header>
<h2 id="GeoAPI-modules"><span class="section-number">7.1.</span> Les modules de GeoAPI</h2>
</header>
<p>
Le projet GeoAPI est composé d’une partie standardisée (<code class="GeoAPI">geoapi</code>) et
d’une partie expérimentale (<code class="GeoAPI">geoapi-pending</code>). Ces deux parties étant
mutuellement exclusives, les utilisateurs doivent veiller à ne pas les mélanger dans un même projet.
Cette séparation est garantie pour tous les projets qui ne dépendent que du dépôt central de Maven
(incluant les versions finales de Apache <abbr title="Spatial Information System">SIS</abbr>),
car le module <code class="GeoAPI">geoapi-pending</code> n’est jamais déployé sur ce dépôt central.
En revanche certaines branches de développement de <abbr>SIS</abbr> peuvent dépendre de <code class="GeoAPI">geoapi-pending</code>.
</p><p>
Les modules de GeoAPI sont:
</p>
<ul>
<li><p>
<b><code class="GeoAPI">geoapi</code></b> — contient les interfaces couvertes par le
<a href="http://www.opengeospatial.org/standards/geoapi">standard GeoAPI de l’<abbr title="Open Geospatial Consortium">OGC</abbr></a>.
Les versions finales de Apache <abbr>SIS</abbr> dépendent de ce module.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-pending</code></b> — contient une
<em>copie</em> de toutes les interfaces du module <code class="GeoAPI">geoapi</code>
(non pas une dépendance) avec des ajouts qui n’ont pas encore été approuvés comme un standard <abbr>OGC</abbr>.
Certains ajouts apparaissent dans des interfaces normalement définies par le module <code class="GeoAPI">geoapi</code>,
d’où la nécessité de les copier.
Les branches de développement
<code>jdk7</code> et <code>jdk8</code> de Apache <abbr>SIS</abbr> dépendent de ce module,
mais cette dépendance est transformée en une dépendance vers le module <code class="GeoAPI">geoapi</code>
standard au moment de fusionner les branches avec le tronc.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-conformance</code></b> — contient
une suite de tests JUnit que les développeurs peuvent utiliser pour tester leurs implémentations.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-examples</code></b> — contient des
exemples d’implémentations relativement simples. Ces exemples sont placés dans le domaine public
afin d’encourager les utilisateurs à les copier et les adapter à leurs besoins si les services
de Apache <abbr>SIS</abbr> ne conviennent pas.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-proj4</code></b> — contient une
implémentation partielle des paquets <code class="GeoAPI">org.opengis.referencing</code>
sous forme d’adaptateurs basés sur la bibliothèque C/C++ Proj.4.
Ce module peut être utilisé comme alternative au module <code class="SIS">sis-referencing</code>
pour certaines fonctions.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-netcdf</code></b> — contient une implémentation partielle des paquets
<code class="GeoAPI">org.opengis.referencing</code> et <code class="GeoAPI">org.opengis.coverage</code>
sous forme d’adaptateurs basés sur la bibliothèque <abbr title="Network Common Data Form">netCDF</abbr> de l’<abbr title="University Corporation for Atmospheric Research">UCAR</abbr>.
La suite de tests de ce module a été conçue de manière à être réutilisable par d’autres projets.
Apache <abbr>SIS</abbr> l’utilise pour tester son propre module <code class="SIS">sis-netcdf</code>.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-openoffice</code></b> — contient
un <i>add-in</i> pour les suites bureautiques Libre/OpenOffice.org.
Note: Apache <abbr>SIS</abbr> offre son propre <i>add-in</i> dans le module <code class="SIS">sis-openoffice</code>.
</p></li>
</ul>
</section>


<section>
<header>
<h2 id="SpecificationToInterfaces"><span class="section-number">7.2.</span> Des spécifications de l’<abbr title="Open Geospatial Consortium">OGC</abbr> aux interfaces Java</h2>
</header>
<p>
Les interfaces Java du projet GeoAPI sont parfois générées à partir d’autres fichiers fournis par l’<abbr>OGC</abbr>,
tels que les fichiers <abbr title="XML Schema Definition">XSD</abbr>. Mais il y a toujours une révision manuelle, et très souvent des modifications
par rapport aux fichiers générés par des processus automatiques.
Il aurait été possible de générer automatiquement des interfaces Java à partir des standards de l’<abbr>OGC</abbr> à l’aide d’outils existants.
Par exemple une des approches les plus utilisées est de transformer les <a href="http://schemas.opengis.net/gml/3.3/">schémas <abbr>XSD</abbr></a>
en interfaces Java à l’aide de l’utilitaire en ligne de commande <code>xjc</code>.
Cet utilitaire étant fournit avec la plupart des distributions du Java (il fait partie des outils de <a href="http://jaxb.java.net"><abbr title="Java Architecture for XML Binding">JAXB</abbr></a>),
cette approche est choisie par plusieurs projets que l’on trouve sur internet.
D’autres approches utilisent des outils intégrés à l’environnement de développement Eclipse,
ou prennent comme point de départ les schémas <abbr title="Unified Modeling Language">UML</abbr> plutôt que <abbr>XSD</abbr>.
Une approche similaire avait été tentée dans les débuts du projet GeoAPI, mais a été rapidement abandonnée.
Nous avons privilégié une approche manuelle pour les raisons suivantes:
</p>
<ul>
<li>
<p>
Certains schémas <abbr>XSD</abbr> sont beaucoup plus verbeux que les schémas <abbr>UML</abbr> d’origines.
Une conversion à partir des schémas <abbr>XSD</abbr> introduit, au moins dans le cas des méta-données,
près du double du nombre d’interfaces réellement définies par le standard, sans que cela n’apporte de nouvelles fonctionnalités.
Les schémas <abbr>XSD</abbr> définissent aussi des attributs propres aux documents <abbr>XML</abbr>
(<code class="OGC">id</code>, <code class="OGC">uuid</code>, <code>xlink:href</code>, <i>etc.</i>),
qui n’existent pas dans les diagrammes <abbr>UML</abbr> originaux et que l’on ne souhaite pas forcément exposer dans un <abbr title="Application Programming Interface">API</abbr> Java.
Une conversion à partir des schémas <abbr>UML</abbr> évite ce problème, mais les outils capable d’effectuer cette opération sont plus rares.
</p>
<div class="example"><p><b>Exemple:</b>
Les schémas <abbr>XSD</abbr> des méta-données insèrent
un élément <code class="OGC">&lt;gmd:CI_Citation&gt;</code> à l’intérieur de <code class="OGC">&lt;gmd:citation&gt;</code>,
un élément <code class="OGC">&lt;gmd:CI_OnlineResource&gt;</code> à l’intérieur de <code class="OGC">&lt;gmd:onlineResource&gt;</code>,
et ainsi de suite pour la centaine de classes définies dans le standard <abbr title="International Organization for Standardization">ISO</abbr> 19115.
Cette redondance n’est absolument pas nécessaire à un programme Java.
</p></div>
</li>
<li>
<p>
Les standards de l’<abbr>OGC</abbr> utilisent des conventions de nommage qui sont différentes de celles du Java.
En particulier les noms de presque toutes les classes de l’<abbr>OGC</abbr> commencent par un préfixe de deux lettres,
comme dans <code class="OGC">MD_Identifier</code>. Ces préfixes jouent le même rôle que les noms de paquets en Java.
GeoAPI adapte cette pratique en utilisant des noms d’interfaces sans préfixes,
et en plaçant ces interfaces dans des paquets correspondants aux préfixes mais avec des noms plus descriptifs.
Occasionnellement nous changeons aussi les noms, par exemple pour éviter des acronymes
ou pour se conformer à une convention établie telle que <i>Java beans</i>.
</p>
<div class="example"><p><b>Exemple:</b>
la classe <code class="OGC">MD_Identifier</code> de l’<abbr>OGC</abbr> devient
l’interface <code class="GeoAPI">Identifier</code> dans le paquet <code class="GeoAPI">org.opengis.metadata</code>.
La classe <code class="OGC">SC_CRS</code> de l’<abbr>OGC</abbr> devient l’interface <code class="GeoAPI">CoordinateReferenceSystem</code>,
et l’association <code class="OGC">usesDatum</code> devient une méthode <code class="GeoAPI">getDatum()</code> — et non pas
« <code>getUsesDatum()</code> » comme aurait fait un outil de conversion automatique.
Nous ne laissons pas des programmes appliquer aveuglement des règles qui ignorent les conventions de la communauté dont on traduit les schémas.
</p></div>
</li>
<li>
<p>
Les standards contiennent parfois des structures qui n’ont pas d’équivalent direct en Java,
notamment les unions telles qu’on peut trouver en C/C++.
La stratégie employée pour obtenir une fonctionnalité équivalente en Java dépend du contexte:
multi-héritage des interfaces, modification de la hiérarchie ou simplement omettre l’union.
Les décisions se font au cas-par-cas en fonction de l’analyse des besoins.
</p>
<div class="example"><p><b>Exemple:</b>
Le standard <abbr>ISO</abbr> 19111 définit différents types de systèmes de coordonnées, tels que sphérique, cylindrique, polaire ou cartésien.
Puis, il définit différents <em>sous-ensembles</em> de ces types de systèmes de coordonnées.
Ces sous-ensembles, représentés par des unions, servent à spécifier qu’une classe peut être associée à seulement tel ou tel type de système de coordonnées.
Par exemple l’union des types pouvant être associés à une image, nommée <code class="OGC">CS_ImageCS</code>,
ne contient que <code class="OGC">CS_CartesianCS</code> et <code class="OGC">CS_AffineCS</code>.
Dans ce cas particulier, nous obtenons en Java l’effet souhaité par une modification de la hiérarchie des classes:
nous définissons l’interface <code class="GeoAPI">CartesianCS</code> comme une spécialisation de <code class="GeoAPI">AffineCS</code>, ce qui est sémantiquement correct.
Mais il n’est pas possible d’appliquer une stratégie similaire pour les autres unions sans violer la sémantique.
</p></div>
</li>
<li>
<p>
Plusieurs spécifications se chevauchent. GeoAPI effectue un travail d’intégration en remplaçant certaines
structures qui font doublons par des références vers les structures équivalentes du standard qui les définies le mieux.
</p>
<div class="example"><p><b>Exemple:</b>
Le standard <abbr>ISO</abbr> 19115, qui définit des structures de méta-données, s’aventure aussi à décrire quelques
structures représentant les systèmes de références des coordonnées (<abbr title="Coordinate Reference System">CRS</abbr>).
Or ces derniers sont le sujet à part entière d’un autre standard: <abbr>ISO</abbr> 19111.
D’ailleurs le standard <abbr>ISO</abbr> 19111:2007 stipule, dans sa section 3, qu’il réutilise tous les éléments
de <abbr>ISO</abbr> 19115 à l’exclusion de <code class="OGC">MD_CRS</code> et de ses composantes.
Les interfaces de GeoAPI réduisent la redondance en appliquant à l’ensemble du projet l’exclusion recommandée par <abbr>ISO</abbr> 19111.
</p></div>
</li>
<li>
<p>
Certains standards ont vu leur complexité s’accroître pour des raisons historiques plutôt que techniques,
liées au processus de standardisation. GeoAPI réduit la dette technique en concevant les interfaces comme
si chaque élément avait pu être intégré à sa place, sans les contraintes liées à l’ordre chronologique
dans lequel les standards ont été publiés.
</p>
<div class="example"><p><b>Exemple:</b>
Le standard <abbr>ISO</abbr> 19115-2 est une extension du standard <abbr>ISO</abbr> 19115-1 ajoutant des structures de méta-données d’images.
Ces méta-données ont été définies dans un standard séparé parce qu’elles n’ont pas été prêtes à temps pour la publication de la première partie du standard.
Comme il n’était pas possible, pour des raisons administratives, d’ajouter des attributs dans les classes déjà publiées,
les nouveaux attributs ont été ajoutées dans une sous-classe portant quasiment le même nom.
Ainsi, le standard <abbr>ISO</abbr> 19115-2 définit une classe <code class="OGC">MI_Band</code> qui étend la
classe <code class="OGC">MD_Band</code> du standard <abbr>ISO</abbr> 19115-1 en y ajoutant les attributs qui
auraient dû apparaître directement dans la classe parente s’ils avaient été prêts à temps.
Dans GeoAPI, nous avons choisis de « réparer » ces anomalies en fusionnant ces deux classes en une seule interface.
</p></div>
</li>
</ul>
<p>
Les écarts par rapport aux normes sont documentés dans chaque classe et chaque méthode concernées.
Chaque mention d’un écart est aussi recopiée dans <a href="http://www.geoapi.org/3.0/javadoc/departures.html">une page unique</a>,
pour donner une vue d’ensemble.
Étant donné que ces écarts brouillent les liens qui existent entre les standards et certaines interfaces Java,
la correspondance entre ces langages est explicitée par des annotations <code class="GeoAPI">@UML</code>
et des fichiers de propriétés, décrits dans la section suivante.
</p>



<h3 id="UML-annotation"><span class="section-number">7.2.1.</span> Correspondances explicites entre GeoAPI et les spécifications abstraites</h3>
<p>
Pour chaque classe, méthode et constante définie à partir d’un standard <abbr title="Open Geospatial Consortium">OGC</abbr> ou <abbr title="International Organization for Standardization">ISO</abbr>,
GeoAPI indique sa provenance à l’aide d’annotations définies dans le paquet <code class="GeoAPI">org.opengis.annotation</code>.
En particulier l’annotation <code class="GeoAPI">@UML</code> indique le standard,
le nom de l’élément dans ce standard ainsi que son niveau d’obligation.
Par exemple dans l’extrait de code suivant, la première annotation <code class="GeoAPI">@UML</code> indique
que l’interface Java qui la suit (<code class="GeoAPI">ProjectedCRS</code>) est définie à partir du type
<code class="OGC">SC_ProjectedCRS</code> du standard <abbr>ISO</abbr> 19111.
La seconde annotation <code class="GeoAPI">@UML</code>, appliquée cette fois à la méthode
<code class="GeoAPI">getCoordinateSystem()</code>, indique que la méthode est définie
à partir de l’association <code class="OGC">coordinateSystem</code> du standard <abbr>ISO</abbr> 19111,
et que cette association est obligatoire — ce qui, traduit en Java, signifie que la méthode n’est
pas autorisée à retourner la valeur <code>null</code>.
</p>

<pre><code><b>package</b> <code class="GeoAPI">org.opengis.referencing.crs</code>;

<code class="comment">/**
 * A 2D coordinate reference system used to approximate the shape of the earth on a planar surface.
 */</code>
@<code class="GeoAPI">UML</code>(specification=ISO_19111, identifier=<i>"<code class="OGC">SC_ProjectedCRS</code>"</i>)
<b>public</b> <b>interface</b> <code class="GeoAPI">ProjectedCRS</code> <b>extends</b> <code class="GeoAPI">GeneralDerivedCRS</code> {
    <code class="comment">/**
     * Returns the coordinate system, which must be Cartesian.
     */</code>
    @<code class="GeoAPI">UML</code>(obligation=MANDATORY, specification=ISO_19111, identifier=<i>"<code class="OGC">coordinateSystem</code>"</i>)
    <code class="GeoAPI">CartesianCS</code> <code class="GeoAPI">getCoordinateSystem()</code>;
}</code></pre>

<p>
Les méthodes d’introspections du Java permettent d’accéder à ces informations pendant l’exécution d’une application.
C’est utile pour obtenir les noms à afficher à des utilisateurs familiers avec les normes de l’<abbr>OGC</abbr>,
ou pour écrire des éléments dans un document <abbr>XML</abbr>.
La classe <code class="SIS">org.apache.sis.util.iso.Types</code> fournit des méthodes de commodité
telles que <code class="SIS">getStandardName(Class)</code> pour effectuer cette opération.
Par exemple le code suivant affichera
« Le nom standard du type <code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> est <code class="OGC">SC_ProjectedCRS</code> »:
</p>

<pre><code>Class&lt;?&gt; type = <code class="GeoAPI">ProjectedCRS</code>.<b>class</b>;
System.out.println(<i>"Le nom standard du type "</i> + type.getName() + <i>" est "</i> + Types.getStandardName(type));</code></pre>

<p>
La méthode de commodité <code class="SIS">Types​.forStandardName(String)</code> effectue l’opération inverse.
Les applications qui souhaiteraient effectuer ces opérations sans utiliser les méthodes de commodités de Apache SIS
trouveront des indications dans un <a href="#UML-annotation-geoapi">chapitre séparé</a>.
</p>


<h3 id="MappingToJDK"><span class="section-number">7.2.2.</span> Correspondances implicites avec le <abbr>JDK</abbr> standard</h3>
<p>
Certaines classes et méthodes n’ont ni annotation <code class="GeoAPI">@UML</code>,
ni entrée dans le fichier <code class="GeoAPI">class-index.properties</code>.
Il s’agit soit d’extensions de GeoAPI, ou soit de types définis dans d’autres bibliothèques,
notamment le <abbr title="Java Development Kit">JDK</abbr> standard.
Pour ce dernier cas, la correspondance avec les standards <abbr title="International Organization for Standardization">ISO</abbr> est implicite.
Le tableau suivant décrit cette correspondance pour les types de la norme <abbr>ISO</abbr> 19103.
Les types primitifs du Java standard sont préférés lorsqu’ils sont applicables,
mais parfois leurs équivalents sous forme d’objets sont employés lorsqu’il est nécessaire d’autoriser des valeurs nulles.
</p>
<table>
<caption>Correspondances entre <abbr>ISO</abbr> 19103 et <abbr>JDK</abbr></caption>
<tr>
<th>Type <abbr>ISO</abbr></th>
<th>Type <abbr>JDK</abbr></th>
<th>Remarques</th>
</tr>
<tr>
<td class="separator" colspan="2">Nombres</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Integer</code></td>
<td><code>int</code></td>
<td class="leftBorder">Parfois <code>java.lang.Integer</code> pour les attributs optionnels.</td>
</tr>
<tr>
<td><code class="OGC">Integer</code> (certains cas)</td>
<td><code>long</code></td>
<td class="leftBorder">Parfois <code>java.lang.Long</code> pour les attributs optionnels.</td>
</tr>
<tr>
<td><code class="OGC">Real</code></td>
<td><code>double</code></td>
<td class="leftBorder">Parfois <code>java.lang.Double</code> pour les attributs optionnels.</td>
</tr>
<tr>
<td><code class="OGC">Decimal</code></td>
<td><code>java.math.BigDecimal</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Number</code></td>
<td><code>java.lang.Number</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Textes</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">FreeText</code></td>
<td>(pas d’équivalent)</td>
<td class="leftBorder">Voir <code class="GeoAPI">org.opengis.util.InternationalString</code> ci-dessous.</td>
</tr>
<tr>
<td><code class="OGC">CharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder">Souvent <code class="GeoAPI">org.opengis.util.InternationalString</code> (voir ci-dessous).</td>
</tr>
<tr>
<td><code class="OGC">LocalisedCharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence&lt;Character&gt;</code></td>
<td><code>java.lang.CharSequence</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Character</code></td>
<td><code>char</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Dates et heures</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Date</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Time</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">DateTime</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Collections</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Collection</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Bag</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder">Un <code class="OGC">Bag</code> est similaire à un
<code class="OGC">Set</code> sans la restriction d’unicité.</td>
</tr>
<tr>
<td><code class="OGC">Set</code></td>
<td><code>java.util.Set</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence</code></td>
<td><code>java.util.List</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Dictionary</code></td>
<td><code>java.util.Map</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">KeyValuePair</code></td>
<td><code>java.util.Map.Entry</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Énumérations</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Enumeration</code></td>
<td><code>java.lang.Enum</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">CodeList</code></td>
<td>(pas d’équivalent)</td>
<td class="leftBorder">Voir <code class="GeoAPI">org.opengis.util.CodeList</code> ci-dessous.</td>
</tr>
<tr>
<td class="separator" colspan="2">Divers</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Boolean</code></td>
<td><code>boolean</code></td>
<td class="leftBorder">Parfois <code>java.lang.Boolean</code> pour les attributs optionnels.</td>
</tr>
<tr>
<td><code class="OGC">Any</code></td>
<td><code>java.lang.Object</code></td>
<td class="leftBorder"/>
</tr>
</table>

<p>
L’équivalent le plus direct de <code class="OGC">CharacterString</code> est la classe <code>String</code>,
mais GeoAPI emploie souvent l’interface <code class="GeoAPI">InternationalString</code> pour permettre au client de choisir la langue.
C’est utile par exemple sur un serveur fournissant simultanément des pages dans plusieurs langues.
En reportant les traductions à l’utilisation des objets plutôt qu’au moment de leur création, on permet à la bibliothèque
<abbr title="Spatial Information System">SIS</abbr> de fournir les mêmes instances de <code class="GeoAPI">Metadata</code>
ou <code class="GeoAPI">Coverage</code> (par exemple) pour les mêmes données peu importe la langue du client.
Les traductions peuvent être faites à la volée à l’aide d’un <code>ResourceBundle</code> de l’application,
ou être fournies directement avec les données (cas des <code class="GeoAPI">Metadata</code> notamment).
</p>
<p>
Les <code class="OGC">Enumeration</code> correspondent aux <code>Enum</code> du Java.
Ils ont en commun de définir toutes les valeurs autorisées, sans permettre à l’utilisateur d’en ajouter.
Les <code class="OGC">CodeList</code> sont similaires à ces énumérations, excepté que les utilisateurs peuvent y ajouter leurs propres éléments.
Le <abbr>JDK</abbr> standard n’offrant pas cette possibilité,
GeoAPI définit une classe abstraite <code class="GeoAPI">CodeList</code> reproduisant certaines fonctionnalités de <code>Enum</code> tout en étant extensible.
Les extensions s’obtiennent par les méthodes statiques <code class="GeoAPI">valueOf(String)</code> qui,
contrairement à celle de <code>Enum</code>, créeront de nouvelles instances si le nom donné ne correspond pas au nom d’une instance existante.
</p>

<pre><code><code class="GeoAPI">MediumName</code> cdRom  = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">CD_ROM;</code>
<code class="GeoAPI">MediumName</code> usbKey = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>); <code class="comment">// Aucune constante n’existe pour cette valeur.
</code><b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">CD_ROM</code>"</i>)  == cdRom  : <i>"valueOf doit retourner les constantes existantes."</i>;
<b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>) == usbKey : <i>"valueOf doit cacher les valeurs précédemment demandées."</i>;</code></pre>
</section>


<section>
<header>
<h2 id="ReduceDependency"><span class="section-number">7.3.</span> Réduire la dépendance directe envers Apache SIS</h2>
</header>
<p>
Les chapitres précédents utilisaient des méthodes statiques de Apache SIS par commodité.
Dans certains cas, il est possible de remplacer ces méthodes statiques par du code ne faisant appel qu’à des méthodes de GeoAPI.
Ces remplacements peuvent être intéressants pour les applications qui souhaiteraient limiter les dépendances directes envers Apache SIS,
par exemple afin de faciliter d’éventuelles migrations entre SIS et d’autres implémentations de GeoAPI.
Mais cela peut amener ces applications à écrire leur propres méthodes de commodités.
Les sections suivantes donnent quelques pistes pour faciliter cette tâche.
</p>

<h3 id="UML-annotation-indep"><span class="section-number">7.3.1.</span> Correspondances entre GeoAPI et les spécifications abstraites</h3>
<p>
Pour chaque classe, méthode et constante définie à partir d’un standard <abbr title="Open Geospatial Consortium">OGC</abbr> ou <abbr title="International Organization for Standardization">ISO</abbr>,
GeoAPI indique sa provenance à l’aide d’annotations définies dans le paquet <code class="GeoAPI">org.opengis.annotation</code>.
Cette correspondante est décrite dans le <a href="#UML-annotation">chapitre à propos de GeoAPI</a>.
Les méthodes d’introspections du Java permettent d’accéder à ces informations pendant l’exécution d’une application.
La classe <code class="SIS">org.apache.sis.util.iso.Types</code> fournit des méthodes de commodités telles que
<code class="SIS">getStandardName(Class)</code> à cette fin, mais on peut éviter ces méthodes.
L’exemple suivant affiche le nom standard de la méthode <code class="GeoAPI">getTitle()</code> de l’interface <code class="GeoAPI">Citation</code>:
</p>

<pre><code>Class&lt;?&gt; type   = <code class="GeoAPI">Citation</code>.<b>class</b>;
Method   method = type.getMethod(<i>"<code class="GeoAPI">getTitle</code>"</i>, (Class&lt;?&gt;[]) <b>null</b>);
<code class="GeoAPI">UML</code>      annot  = method.getAnnotation(<code class="GeoAPI">UML</code>.<b>class</b>);
String   id     = annot.identifier();
System.out.println(<i>"Le nom standard de la méthode "</i> + method.getName() + <i>" est "</i> + id);</code></pre>

<p>
L’opération inverse — obtenir la classe et méthode Java d’un nom standard — est un peu plus lourde.
Elle nécessite la lecture du fichier <code class="GeoAPI">class-index.properties</code> fournit dans le
paquet <code class="GeoAPI">org.opengis.annotation</code>. L’exemple suivant lit ce fichier juste avant
de rechercher le nom de l’interface correspondant à <code class="OGC">CI_Citation</code>.
Toutefois les utilisateurs sont encouragés à ne lire ce fichier qu’une fois et de conserver son contenu dans
une cache de leur application.
</p>

<pre><code>Properties isoToGeoAPI = <b>new</b> Properties();
<b>try</b> (InputStream in = <code class="GeoAPI">UML</code>.<b>class</b>.getResourceAsStream(<i>"<code class="GeoAPI">class-index.properties</code>"</i>)) {
    isoToGeoAPI.load(in);
}
String isoName = <i>"<code class="OGC">CI_Citation</code>"</i>;
String geoName = isoToGeoAPI.getProperty(isoName);
Class&lt;?&gt;  type = Class.forName(geoName);
System.out.println(<i>"L’interface GeoAPI pour le type <abbr>ISO</abbr> "</i> + isoName + <i>" est "</i> + type);</code></pre>

<p>
La méthode de commodité de <code class="SIS">org.apache.sis.util.iso.Types</code> correspondante à cette operation est
<code class="SIS">forStandardName(String)</code>.
</p>



<h3 id="ServiceLoader"><span class="section-number">7.3.2.</span> Obtenir une implémentation des interfaces de GeoAPI</h3>
<p>
GeoAPI définit des fabriques (<code class="GeoAPI">Factory</code>) permettant de créer des implémentations de ses interfaces.
Par exemple <code class="GeoAPI">DatumFactory</code> fournit des méthodes permettant de créer des instances
implémentant les interfaces du paquet <code class="GeoAPI">org.opengis.referencing.datum</code>.
Ces <code class="GeoAPI">Factory</code> doivent être implémentées par les bibliothèques géospatiales
et déclarées comme <i>services</i> tel que défini par la classe standard <code>java.util.ServiceLoader</code>.
La javadoc de <code>ServiceLoader</code> explique la façon de procéder.
Mais pour résumer, les bibliothèques doivent créer dans le répertoire <code>META-INF/services/</code>
un fichier dont le nom correspond au nom complet de l’interface de la fabrique
(<code class="GeoAPI">org.opengis.referencing.datum.DatumFactory</code> dans l’exemple précédent).
Ce fichier texte doit contenir sur une ligne le nom complet de la classe implémentant cette interface.
Il peut s’agir d’une classe cachée aux yeux des utilisateurs, car ils n’ont pas besoin de connaître son existence.
</p>
<p>
Si la bibliothèque a bien déclaré ses fabriques comme des services, alors
les utilisateurs peuvent les obtenir en utilisant <code>ServiceLoader</code> comme dans l’exemple ci-dessous.
Cet exemple ne prend que la première fabrique trouvée; s’il existe plusieurs fabriques,
par exemple lorsque plusieurs bibliothèques cohabitent, alors le choix est laissé à l’utilisateur.
</p>

<pre><code><b>import</b> org.opengis.referencing.<code class="GeoAPI">GeodeticDatum</code>;
<b>import</b> org.opengis.referencing.<code class="GeoAPI">DatumFactory</code>;
<b>import</b> java.util.ServiceLoader;

<b>public</b> <b>class</b> MyApplication {
    <b>public</b> <b>void</b> createMyDatum() {
        ServiceLoader  loader = ServiceLoader.load(<code class="GeoAPI">DatumFactory</code>.<b>class</b>);
        <code class="GeoAPI">DatumFactory</code>  factory = loader.iterator().next();
        <code class="GeoAPI">GeodeticDatum</code> myDatum = factory.<code class="GeoAPI">createGeodeticDatum</code>(…);
    }
}</code></pre>



<h4 id="GeoAPI-simple"><span class="section-number">7.3.2.1.</span> Fournir sa propre implémentation</h4>
<p>
Implémenter soi-même GeoAPI n’est pas si difficile si on se contente de besoins bien précis.
Un développeur peut se concentrer sur une poignée d’interfaces parmi les centaines de disponibles,
tout en disposant des autres interfaces comme autant de points d’extensions à éventuellement implémenter
au gré des besoins.
</p>
<p>
Le modèle conceptuel représenté par les interfaces est complexe. Mais cette complexité peut être réduite en combinant certaines interfaces.
Par exemple plusieurs bibliothèques, même réputées, ne font pas la distinction entre <cite>Système de coordonnées</cite> (<abbr>CS</abbr>)
et <cite>Système de <u>référence</u> des coordonnées</cite> (<abbr title="Coordinate Reference System">CRS</abbr>).
Un développeur qui lui non-plus ne souhaite pas faire cette distinction peut implémenter ces deux interfaces par la même classe.
Il peut en résulter une implémentation dont la hiérarchie de classes est plus simple que la hiérarchie des interfaces de GeoAPI.
Le module <code class="GeoAPI">geoapi-examples</code>, discuté plus loin, fournit de telles combinaisons.
Le tableau suivant énumère quelques combinaisons possibles:
</p>
<table>
<tr>
<th>Interface principale</th>
<th>Interface auxiliaire</th>
<th>Usage</th>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateReferenceSystem</code></td>
<td><code class="GeoAPI">CoordinateSystem</code></td>
<td>Description d’un système de référence spatial (<abbr>CRS</abbr>).</td>
</tr>
<tr>
<td><code class="GeoAPI">GeodeticDatum</code></td>
<td><code class="GeoAPI">Ellipsoid</code></td>
<td>Description d’un référentiel geodétique.</td>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateOperation</code></td>
<td><code class="GeoAPI">MathTransform</code></td>
<td>Opération de transformation de coordonnées.</td>
</tr>
<tr>
<td><code class="GeoAPI">IdentifiedObject</code></td>
<td><code class="GeoAPI">ReferenceIdentifier</code></td>
<td>Objet (typiquement un <abbr>CRS</abbr>) que l’on peut identifier par un code.</td>
</tr>
<tr>
<td><code class="GeoAPI">Citation</code></td>
<td><code class="GeoAPI">InternationalString</code></td>
<td>Référence bibliographique composée d’un simple titre.</td>
</tr>
<tr>
<td><code class="GeoAPI">GeographicBoundingBox</code></td>
<td><code class="GeoAPI">Extent</code></td>
<td>Étendue spatiale en degrés de longitude et de latitude.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValue</code></td>
<td><code class="GeoAPI">ParameterDescriptor</code></td>
<td>Description d’un paramètre (nom, type) associée à sa valeur.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValueGroup</code></td>
<td><code class="GeoAPI">ParameterDescriptorGroup</code></td>
<td>Description d’un ensemble de paramètres associés à leurs valeurs.</td>
</tr>
</table>
<p id="GeoAPI-examples">
Le module <code class="GeoAPI">geoapi-examples</code> fournit des exemples d’implémentations simples.
Plusieurs de ces classes implémentent plus d’une interface à la fois afin de proposer un modèle conceptuel plus simple.
La <a href="http://www.geoapi.org/geoapi-examples/apidocs/overview-summary.html">Javadoc de ce module</a>
énumère les paquets et classes clés avec les combinaisons effectuées.
Ce module illustre non-seulement comment GeoAPI peut-être implémenté, mais aussi comment l’implémentation
peut être testée en utilisant <code class="GeoAPI">geoapi-conformance</code>.
</p>
<p>
Bien que sa mission première soit de servir d’inspiration aux implémenteurs,
<code class="GeoAPI">geoapi-examples</code> a tout-de-même été conçu de manière à être utilisable
par des applications ayant des besoins très simples. Tous les exemples étant dans le domaine publique,
les développeurs sont invités à adapter librement des copies de ces classes si nécessaires.
Toutefois si des modifications sont apportées hors du cadre du projet GeoAPI, le bon usage veut que les copies
modifiées soient placées dans un paquet portant un autre nom que <code class="GeoAPI">org.opengis</code>.
</p>
<p>
Pour des besoins un peu plus poussés, les développeurs sont invités à examiner les modules
<code class="GeoAPI">geoapi-proj4</code> et <code class="GeoAPI">geoapi-netcdf</code>.
Ces deux modules fournissent des exemples d’adaptateurs permettant d’utiliser, via les interfaces de GeoAPI,
une partie des fonctionnalités de bibliothèques externes (Proj.4 et <abbr title="Network Common Data Form">netCDF</abbr>).
L’avantage de passer par ces interfaces est de disposer d’un modèle unifié pour exploiter deux <abbr title="Application Programming Interface">API</abbr> très différents,
tout en se gardant la possibilité de basculer plus facilement à une autre bibliothèque si désiré.
</p>
</section>
</section>


<section>
<header>
<h1 id="Tests"><span class="section-number">8.</span> Les suites de tests</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#GeoAPI-details">Chapitre précédent</a></div><div class="next-chapter"><a href="#DesignNotes">Chapitre suivant</a> ➡</div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#GeoAPI-conformance">Conformance avec GeoAPI</a><ul>
<li><a href="#GeoAPI-validators">Validations des instances</a></li>
<li><a href="#GeoAPI-tests">Exécution des tests pré-définis</a></li></ul></li></ul></nav>
<p>
En plus des tests propres au projet, Apache SIS utilise aussi des tests définis par GeoAPI.
Ces tests ont l’avantage d’utiliser une source externe définissant ce que doivent être les résultats
(par exemple les valeurs des coordonnées obtenues par une projection cartographique).
On réduit ainsi le risque que des tests soient davantage des tests anti-régression que des tests de validité.
Ces tests peuvent aussi être utilisés par des projets autres que Apache SIS.
</p>




<section>
<header>
<h2 id="GeoAPI-conformance"><span class="section-number">8.1.</span> Conformance avec GeoAPI</h2>
</header>
<p>
Le module <code class="GeoAPI">geoapi-conformance</code> fournit des <i>validateurs</i>, une <i>suite de tests</i> JUnit
et des <i>générateurs de rapports</i> sous forme de pages <abbr title="Hypertext Markup Language">HTML</abbr>.
Ce module peut être utilisé avec n’importe quelle implémentation de GeoAPI.
Pour les développeurs d’une bibliothèque géospatiale, il offre les avantages suivants:
</p>
<ul>
<li>Réduire la fastidieuse tâche d’écriture des tests, en réutilisant des tests existants.</li>
<li>Accroître la confiance en la validité des tests, du fait que <code class="GeoAPI">geoapi-conformance</code>
a lui-même sa propre suite de tests et est appliqué à d’autres implémentations.</li>
<li>Faciliter la comparaison avec les autres implémentations.</li>
</ul>



<h3 id="GeoAPI-validators"><span class="section-number">8.1.1.</span> Validations des instances</h3>
<p>
GeoAPI peut valider une instance de ses interfaces en vérifiant que certaines contraintes sont respectées.
Certaines contraintes ne peuvent pas être exprimées dans la signature de la méthode. Ces contraintes sont
généralement décrites textuellement dans les spécifications abstraites ou dans la javadoc.
</p>
<div class="example"><p><b>Exemple:</b>
La conversion ou transformation d’une coordonnée (<code class="OGC">CC_CoordinateOperation</code>) peut nécessiter l’enchaînement de plusieurs étapes.
Dans une telle chaîne d’opérations (<code class="OGC">CC_ConcatenatedOperation</code>),
pour chaque étape (<code class="OGC">CC_SingleOperation</code>) le nombre de dimensions
en sortie doit être égal au nombre de dimensions attendu en entré par l’opération suivante.
Exprimée en langage Java, cette contrainte stipule que pour tout index
0 &lt; <var>i</var> &lt; <var>n</var> où <var>n</var> est le nombre d’opérations, on a
<code>coordOperation[i].targetDimensions == coordOperation[i-1].sourceDimensions</code>.
</p></div>

<p>
La façon la plus simple d’effectuer ces vérifications est d’appeler les méthodes statiques
<code class="GeoAPI">validate(…)</code> de la classe <code class="GeoAPI">org.opengis.test.Validators</code>.
Ces méthodes portant toutes le même nom, il suffit d’écrire “<code>validate(<var>valeur</var>)</code>”
et de laisser le compilateur choisir la méthode la plus appropriée en fonction du type d’objet donné en argument.
Si le type d’objet n’est pas connu au moment de la compilation, alors la méthode <code class="GeoAPI">dispatch(Object)</code>
peut se charger de rediriger le travail à la méthode <code class="GeoAPI">validate(…)</code> appropriée.
</p>
<p>
Toutes les fonctions <code class="GeoAPI">validate(…)</code> suivent le fil des dépendances,
c’est-à-dire qu’elles valideront aussi chaque composantes de l’objet à valider.
Par exemple la validation d’un objet <code class="GeoAPI">GeographicCRS</code> impliquera
la validation de sa composante <code class="GeoAPI">GeodeticDatum</code>, qui impliquera elle-même
la validation de sa composante <code class="GeoAPI">Ellipsoid</code>, et ainsi de suite.
Il est donc inutile de valider soi-même les composantes, à moins de vouloir isoler le test d’un élément souvent problématique.
</p>
<p>
Par défaut, les validations sont aussi strictes que possible. Il est possible toutefois d’assouplir certaines règles.
L’assouplissement le plus fréquent consiste à tolérer l’absence d’attributs qui étaient sensés être obligatoires.
Cette règle et quelques autres peuvent être modifiées globalement pour tous les tests exécutés dans la
<abbr title="Java Virtual Machine">JVM</abbr> courante comme dans l’exemple suivant:
</p>

<pre><code><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">Validators</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <code class="comment">/*
     * Tolérer l’absence d’attributs obligatoires dans les paquets metadata et citation.
     * Cette modification s’appliquera à tous les tests exécutés dans la <abbr>JVM</abbr> courante.
     * S’il existe plusieurs classes de tests, cette initialisation peut être effectuée
     * dans une classe parente à toutes les classes de tests.
     */</code>
    <b>static</b> {
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.metadata.requireMandatoryAttributes</code> = <b>false</b>;
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Construisez un objet ici.
</code>        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">validate</code>(myObject);
    }
}</code></pre>

<p>
Les règles peuvent aussi être modifiées pour une suite de tests particulière,
sans affecter la configuration par défaut de la <abbr>JVM</abbr> courante.
Cette approche nécessite de créer une nouvelle instance du validateur dont on souhaite modifier la configuration.
</p>

<pre><code><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">ValidatorContainer</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <b>private</b> <b>final</b> <code class="GeoAPI">ValidatorContainer</code> validators;

    <b>public</b> MyTest() {
        validators = <b>new</b> <code class="GeoAPI">ValidatorContainer</code>();
        validators.<code class="GeoAPI">metadata.requireMandatoryAttributes</code> = <b>false</b>;
        validators.<code class="GeoAPI">citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Construisez un objet ici.
</code>        validators.<code class="GeoAPI">validate</code>(myObject);
    }
}</code></pre>



<h3 id="GeoAPI-tests"><span class="section-number">8.1.2.</span> Exécution des tests pré-définis</h3>
<p>
Des classes de tests JUnit sont définies dans des sous-paquets de <code class="GeoAPI">org.opengis.test</code>.
Toutes les classes de tests portent un nom se terminant en "<code>Test</code>".
GeoAPI définie aussi une classe <code class="GeoAPI">org.opengis.test.TestSuite</code> englobant l’ensemble
des tests définis dans le module <code class="GeoAPI">geoapi-conformance</code>, mais Apache <abbr title="Spatial Information System">SIS</abbr> ne l’utilise pas.
Apache <abbr>SIS</abbr> hérite plutôt des classes <code class="GeoAPI">*Test</code> de GeoAPI au cas-par-cas, dans les modules appropriés.
L’exemple ci-dessous donne un exemple de test de GeoAPI personnalisé.
La <a href="http://www.geoapi.org/geoapi-conformance/apidocs/org/opengis/test/referencing/ParameterizedTransformTest.html">Javadoc
de la classe parente</a> documente en détails les tests effectués.
Dans cet exemple, un seul test est modifié et tous les autres tests sont hérités tels quels
(il n’est pas nécessaire de les répéter dans la sous-classe).
Toutefois, cet exemple ajoute une vérification supplémentaire, annotée <code>@After</code>,
qui sera exécutée après chacun des tests.
</p>

<pre><code><b>import</b> org.junit.*;
<b>import</b> org.junit.runner.RunWith;
<b>import</b> org.junit.runners.JUnit4;
<b>import</b> org.opengis.test.referencing.<code class="GeoAPI">ParameterizedTransformTest</code>;
<b>import</b> <b>static</b> org.junit.Assert.*;

@RunWith(JUnit4.<b>class</b>)
<b>public</b> <b>class</b> MyTest <b>extends</b> <code class="GeoAPI">ParameterizedTransformTest</code> {
    <code class="comment">/**
     * Spécifie aux tests de GeoAPI notre propre fabrique de transformations de coordonnées.
     * GeoAPI testera les objets construits par cette fabrique.
     */</code>
    <b>public</b> MyTest() {
        <b>super</b>(<b>new</b> MyMathTransformFactory());
    }

    <code class="comment">/**
     * Modifie le comportement d’un test. Cet exemple assouplit un peu les exigences de ce test,
     * en acceptant des erreurs jusqu’à 10 centimètres plutôt que la valeur par défaut de 1 cm.
     * Ce changement ne s’applique qu’à cette méthode est n’affecte pas les autres tests hérités.
     */</code>
    @Test
    @Override
    <b>public</b> <b>void</b> testLambertAzimuthalEqualArea() <b>throws</b> <code class="GeoAPI">FactoryException</code>, <code class="GeoAPI">TransformException</code> {
        <code class="GeoAPI">tolerance</code> = 0.1;                    <code class="comment">// Tolérance de 10 cm.
</code>        <b>super</b>.<code class="GeoAPI">testLambertAzimuthalEqualArea()</code>;
    }

    <code class="comment">/**
     * Vérification supplémentaire effectuée après chaque test, hérité ou non.
     * Dans cet exemple, nous vérifions que la transformation qui a été testée
     * travaillait bien dans des espaces bi-dimensionnels.
     */</code>
    @After
    <b>public</b> <b>void</b> ensureAllTransformAreMath2D() {
        assertTrue(<code class="GeoAPI">transform</code> <b>instanceof</b> <code class="GeoAPI">MathTransform2D</code>);
    }
}</code></pre>
</section>
</section>


<section>
<header>
<h1 id="DesignNotes"><span class="section-number">9.</span> Notes de design</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Tests">Chapitre précédent</a></div></div></nav>
</header>
<nav>Dans ce chapitre:<ul class="toc">
<li><a href="#AffineTransform">Utilisation des transformations affines</a><ul>
<li><a href="#AffineTransformAPI">Intégration avec les bibliothèques graphiques</a></li></ul></li>
<li><a href="#MatrixLibrary">Particularités d’une bibliothèque de calculs matriciels pour un SIG</a><ul>
<li><a href="#NonSquareMatrix">Que faire des matrices qui ne sont pas carrées (et pourquoi)</a></li>
<li><a href="#MatrixLibrarySummary">La bibliothèque matricielle de Apache SIS</a></li></ul></li></ul></nav>
<p>Les chapitres suivants expliquent les raisons derrières certains choix d’implémentation de Apache <abbr title="Spatial Information System">SIS</abbr>.</p>





<section>
<header>
<h2 id="AffineTransform"><span class="section-number">9.1.</span> Utilisation des transformations affines</h2>
</header>
<p>
Parmi les sortes d’opérations qu’un <abbr>SIG</abbr> doit effectuer sur les coordonnées spatiales,
les <cite>transformations affines</cite> sont à la fois relativement simples et très fréquentes.
Les transformations affines peuvent représenter n’importe quelle combinaison d’échelles, de cisaillements,
de retournements, de rotations ou de translations, qui sont toutes des <cite>opérations linéaires</cite>.
Les transformations affines ne peuvent pas effectuer des opérations <cite>non-linéaires</cite>
telles que les projections cartographiques, mais couvrent néanmoins de nombreux autres cas:
</p>
<ul>
<li>Changer l’ordre des axes,        par exemple de (<var>latitude</var>, <var>longitude</var>) vers (<var>longitude</var>, <var>latitude</var>).</li>
<li>Changer la direction des axes,   par exemple l’axe des <var>y</var> qui pointe habituellement vers le bas dans les images.</li>
<li>Changer le méridien d’origine,   par exemple du méridien de <cite>Paris</cite> vers celui de <cite>Greenwich</cite>.</li>
<li>Changer le nombre de dimensions, par exemple passer des coordonnées 3D vers 2D en supprimant la hauteur.</li>
<li>Convertir des unités de mesures, par exemple convertir des pieds en mètres.</li>
<li>Convertir des coordonnées pixels en coordonnées géographiques,
par exemple la conversion exprimée dans les fichiers <code>.tfw</code> qui accompagnent certaines images <abbr>TIFF</abbr>.</li>
<li>Prendre en charge une petite partie des projections cartographiques,
par exemple les paramètres <cite>False Easting</cite>, <cite>False Northing</cite> et <cite>Scale factor</cite>.</li>
</ul>
<p>
Les transformations affines peuvent se combiner efficacement.
Peu importe le nombre de transformations affines que l’on enchaîne, le résultat sera exprimable par une seule transformation affine.
Cette propriété est plus facilement visible lorsque les transformations affines sont exprimées sous forme de matrices:
pour combiner les opérations, il suffit de multiplier les matrices.
Le cas des conversions des coordonnées pixels en coordonnées géographiques ci-dessous donne un exemple.
</p>

<div class="example">
<p><b>Exemple:</b>
supposons que nous disposons d’une image dont les coordonnées des pixels sont représentées par (<var>x</var>,<var>y</var>).
Supposons aussi que les contraintes suivantes sont respectées:
</p>
<ul>
<li>Il n’y a ni cisaillement, ni rotation, ni retournement de l’image.</li>
<li>Tous les pixels ont la même largeur en degrés de longitude.</li>
<li>Tous les pixels ont la même hauteur en degrés de latitude.</li>
<li>Les coordonnées des pixels commencent à (0,0) inclusivement.</li>
</ul>
<p>Alors la conversion des coordonnées pixels (<var>x</var>,<var>y</var>)
vers les coordonnées géographiques (<var>λ</var>,<var>φ</var>)
peut être représentée par les équations suivantes,
où <var>N</var><sub><var>x</var></sub> est la largeur
et <var>N</var><sub><var>y</var></sub> la hauteur de l’image en nombre de pixels.
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mtable>
<mtr>
<mtd><mo>λ</mo></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub><mi>x</mi><mo>+</mo><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
<mtd><mtext>        where        </mtext></mtd>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd>
<mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac>
</mtd>
<mtd><mtext>    and    </mtext></mtd>
<mtd><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mo>φ</mo></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub><mi>y</mi><mo>+</mo><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
<mtd><mtext>        where        </mtext></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd>
<mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac>
</mtd>
<mtd><mtext>    and    </mtext></mtd>
<mtd><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>φ</mi><mrow>min</mrow></msub></mtd>
</mtr>
</mtable>
</math>
</p><p>
Les équations ci-dessus peuvent être représentées sous forme de matrices comme ci-dessous:
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>λ</mi></mtd></mtr>
<mtr><mtd><mi>φ</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub></mtd>
<mtd><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
<mo>×</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>x</mi></mtd></mtr>
<mtr><mtd><mi>y</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
</math>
</p><p>
Dans ce cas particulier, les facteurs d’échelles <var>S</var> correspondent à la taille des pixels en degrés
et les termes de translations <var>T</var> correspondent aux coordonnées géographiques d’un coin de l’image
(pas nécessairement le coin inférieur gauche si certains axes ont été retournés).
Cette interprétation directe n’est possible que lorsque les contraintes énumérées plus haut sont respectées.
Les coefficients des matrices deviennent plus complexes si l’image a un cisaillement ou une rotation,
ou si les coordonnées des pixels ne commencent pas à (0,0).
Toutefois il n’est pas nécessaire d’utiliser des équations plus complexes pour gérer des cas plus génériques.
L’exemple ci-dessous prend comme point de départ la matrice d’une « conversion initiale »
dans laquelle les coefficients <var>S</var> et <var>T</var> sont les valeurs relativement simples données ci-dessus.
Ensuite la direction de l’axe des <var>y</var> est inversée de manière à correspondre
à la convention habituelle des systèmes de coordonnées des images (changement 1),
et les axes sont intervertis de manière à avoir la latitude avant la longitude (changement 2).
Notez que les concaténations de transformations affines écrites sous forme de multiplications matricielles
se lisent de droite à gauche:
<var>A</var>×<var>B</var>×<var>C</var> est équivalent à d’abord appliquer l’opération <var>C</var>,
suivit de l’opération <var>B</var> et finalement l’opération <var>A</var>.
</p>
<div style="display:table; margin:auto">
<div style="display:table-row">
<div class="caption" style="display:table-cell">Changement 2</div>
<div class="caption" style="display:table-cell"> </div>
<div class="caption" style="display:table-cell">Changement 1</div>
<div class="caption" style="display:table-cell"> </div>
<div class="caption" style="display:table-cell">Conversion initiale</div>
<div class="caption" style="display:table-cell"> </div>
<div class="caption" style="display:table-cell">Opérations combinées</div>
</div>
<div style="display:table-row">
<div style="display:table-cell; vertical-align:middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</div>
<div style="display:table-cell; vertical-align:middle; padding-left: 15px; padding-right: 15px">×</div>
<div style="display:table-cell; vertical-align:middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>-1</mn></mtd>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</div>
<div style="display:table-cell; vertical-align:middle; padding-left: 15px; padding-right: 15px">×</div>
<div style="display:table-cell; vertical-align:middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><msub><mi>φ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</div>
<div style="display:table-cell; vertical-align:middle; padding-left: 15px; padding-right: 15px">=</div>
<div style="display:table-cell; vertical-align:middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mo>-</mo><mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><msub><mi>φ</mi><mrow>max</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</div>
</div>
</div>
<p>
Un principe clé est qu’il n’y a pas besoin d’écrire un code dédié à ce type d’opérations sur les axes.
Ces opérations, et bien d’autres, sont prises en compte naturellement par l’algèbre matricielle.
On y gagne en généricité du code et en performance.
Apache <abbr title="Spatial Information System">SIS</abbr> suit ce principe en utilisant les tranformations affine pour toutes les opérations
où elles peuvent s’appliquer.
Il n’y a par exemple aucun code dédié au changement de l’ordre des ordonnées dans une coordonnée.
</p>
</div>

<h3 id="AffineTransformAPI"><span class="section-number">9.1.1.</span> Intégration avec les bibliothèques graphiques</h3>
<p>
A peu près toutes les bibliothèques graphiques supportent une forme de transformation de coordonnées,
souvent les <cite>transformations affines</cite> ou une légère généralisation.
Chaque bibliothèque défini son propre <abbr title="Application Programming Interface">API</abbr>.
Quelques exemples sont:
</p>
<table>
<caption>Implémentations des transformations affines dans des bibliothèques graphiques</caption>
<tr><th>Bibliothèque</th>                             <th>Implementation de la transformation</th>               <th>Dimensions</th></tr>
<tr><td>Java2D</td>                                   <td><code>java.awt.geom.AffineTransform</code></td>        <td>2</td></tr>
<tr><td>Java3D</td>                                   <td><code>javax.media.j3d.Transform3D</code></td>          <td>3</td></tr>
<tr><td>JavaFX</td>                                   <td><code>javafx.scene.transform.Affine</code></td>        <td>2 ou 3</td></tr>
<tr><td>Java Advanced Imaging (<abbr>JAI</abbr>)</td> <td><code>javax.media.jai.PerspectiveTransform</code></td> <td>2</td></tr>
<tr><td>Android</td>                                  <td><code>android.graphics.Matrix</code></td>              <td>2</td></tr>
</table>
<p>
Toutefois dans plusieurs cas, les transformations affines sont les seuls types d’opérations supportées par la bibliothèque graphique.
Apache <abbr title="Spatial Information System">SIS</abbr> a besoin de gérer un plus grand nombre de type d’opérations,
parmi lesquelles les transformations affines ne sont que des cas particuliers.
Les projections cartographiques et les changements de référentiels notamment,
ne peuvent pas être représentés par des transformations affines.
<abbr>SIS</abbr> a aussi besoin de transformer des points ayant un nombre arbitraire de dimensions,
alors que les <abbr>API</abbr> cités ci-haut restreignent leur usage à un nombre fixe de dimensions.
Pour ces raisons, <abbr>SIS</abbr> ne peut pas utiliser directement ces <abbr>API</abbr>.
<abbr>SIS</abbr> utilise plutôt une interface plus abstraite, <code class="GeoAPI">org.opengis.referencing.transform.MathTransform</code>.
Mais dans le cas particulier où la transformation est réellement affine, <abbr>SIS</abbr> peut essayer d’utiliser
une implémentation existante, surtout Java2D.
Par exemple le code suivant peut être utilisé dans les situations où un objet Java2D est désiré:
</p>

<pre><code><code class="GeoAPI">MathTransform</code> mt = ...;    <code class="comment">// N’importe quelle instance créée par Apache SIS.
</code><b>if</b> (mt <b>instanceof</b> AffineTransform) {
    AffineTransform at = (AffineTransform) mt;
    <code class="comment">// Utiliser l’API de Java2D API à partir d’ici.
</code>}</code></pre>

<p>
Toutefois <abbr>SIS</abbr> n’utilisera Java2D que sur une base opportuniste.
Le forçage de type ci-haut n’est pas garantit de réussir, même si l’instance de
<code class="GeoAPI">MathTransform</code> répond aux conditions qui devrait permettre un usage de Java2D.
</p>
</section>


<section>
<header>
<h2 id="MatrixLibrary"><span class="section-number">9.2.</span> Particularités d’une bibliothèque de calculs matriciels pour un <abbr>SIG</abbr></h2>
</header>
<p>
Les <abbr>SIG</abbr> font un usage intensif de matrices afin d’afficher leurs cartes ou transformer des coordonnées.
On pourrait croire que le marché est suffisamment bien pourvu en excellentes bibliothèques de calculs matriciels, libres ou commerciales.
Pourtant, les <abbr>SIG</abbr> ont des besoins spécifiques qui divergent un peu des objectifs de plusieurs bibliothèques existantes.
Des manipulations de matrices comme celles décrites dans <a href="#AffineTransform">le chapitre sur les transformations affines</a>
interviennent dans quasiment toutes les opérations appliquées par Apache <abbr title="Spatial Information System">SIS</abbr> sur des coordonnées.
Mais l’analyse de ces opérations révèle quelques patterns:
</p>
<ul>
<li><p>Ces matrices sont presque toujours de petites tailles, dépassant rarement 5 lignes par 5 colonnes.</p></li>
<li><p>Les opérations matricielles « lourdes » (multiplications ou inversions de matrices) ne surviennent pas dans des endroits où la performance est importante.
Dans la quasi-totalité des cas, elles ne sont effectuées qu’une fois pour toute, à la lecture d’un fichier,
ou lors des étapes de préparation avant de convertir des coordonnées.
Elles ne surviennent quasiment jamais dans la boucle convertissant chacune des coordonnées.</p></li>
<li><p>Dans une succession de multiplications et d’inversions de matrices, les erreurs d’arrondissement s’accumulent et grandissent rapidement
au point de se confondre avec certaines opérations légitimes, notamment les changements de référentiel.
Ces dernières s’expriment souvent par un changement de la taille, position et orientation de l’ellipsoïde
choisi comme approximation de la forme de la Terre.
Or ces changements de taille s’expriment en parties par million et les rotations en arc-secondes.
Retranscrites dans une matrice, ces valeurs sont donc assez petites.</p></li>
<li><p>Il arrive fréquemment que des matrices s’annulent en tout ou en partie lorsqu’elles sont combinées,
c’est-à-dire que leurs multiplications ramènent des facteurs d’échelles à 1 et des translations à 0.
Toutefois les erreurs d’arrondissements font que les valeurs obtenues sont rarement exactes,
mais plutôt des valeurs s’en rapprochant telles que 0,9999…97 à la place de 1.
L’approche habituelle pour contourner ce problème est d’effectuer les comparaisons de nombres à virgule flottante en tolérant un léger écart.
Mais il est difficile de choisir un seuil de tolérance qui gommera la plupart des erreurs d’arrondissement
sans considérer à tord un changement de référentiel comme un artefact (voir point précédent).</p></li>
</ul>
<p>
Ces points font que, pour un <abbr>SIG</abbr> comme Apache <abbr>SIS</abbr>, la précision d’une bibliothèque de calculs matriciels
est plus importante que la performance. Paradoxalement, un bon moyen de gagner en performance est justement d’investir davantage de temps de CPU
pour effectuer des opérations matricielles plus précises dans la phase de <em>préparation</em> (non d’<em>exécution</em>) de la transformation de coordonnées,
car on augmente ainsi les chances de détecter correctement quelles opérations s’annulent.
L’effort investit dans cette détection permet de sauver du temps là où ça compte: quand viendra le moment de boucler sur des millions de coordonnées à transformer.
</p><p>
Mais les bibliothèques dédiées aux calculs matriciels sont souvent conçues pour opérer de manière très performante
sur des matrices de grandes tailles, ayant par exemple des milliers de lignes et colonnes.
Elles sont ainsi conçues pour être capable de résoudre efficacement des systèmes d’équations linéaires comportant des centaines d’inconnues.
Les problèmes qu’elles résolvent sont certes difficiles, mais assez différents de ceux qui intéressent Apache <abbr>SIS</abbr>.
Pour cette raison, et aussi à cause d’un autre besoin spécifique détaillé dans les paragraphes suivants,
Apache <abbr>SIS</abbr> utilise ses propres fonctions de calculs matriciels.
Ces fonctions tentent de résoudre le problème de précision en utilisant l’arithmétique « double-double »
(une technique permettant de simuler une précision d’environ 120 bits)
au prix de la performance pendant une étape (la <em>préparation</em> de la transformation) où elle n’est pas jugée critique.
</p>

<h3 id="NonSquareMatrix"><span class="section-number">9.2.1.</span> Que faire des matrices qui ne sont pas carrées (et pourquoi)</h3>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> a très souvent besoin d’inverser des matrices,
afin d’obtenir une conversion de coordonnées dans la direction inverse de la conversion originale.
Mais on n’inverse habituellement que des matrices carrées.
Or, <abbr>SIS</abbr> a besoin d’effectuer des inversions de matrices non-carrées.
Selon que l’on ait plus de lignes ou plus de colonnes:
</p>
<ul>
<li>Pour <abbr>SIS</abbr>, une matrice non-carrée est une conversion qui ajoute ou supprime une dimension aux coordonnées.</li>
<li>Pour les bibliothèques d’algèbre linéaire, une matrice non-carrée est un système d’équations sous-déterminé ou surdéterminé.</li>
</ul>
<p>
Pour mieux comprendre les difficultés que causerait une transposition trop directe des bibliothèques d’algèbre linéaire aux <abbr>SIG</abbr>,
imaginons une conversion (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>) → (<var>φ₂</var>, <var>λ₂</var>)
qui projetterait les points d’un espace 3D vers une surface 2D.
Les termes <var>φ</var> sont des latitudes, <var>λ</var> des longitudes et
(<var>φ₂</var>, <var>λ₂</var>) n’égale pas forcement (<var>φ₁</var>, <var>λ₁</var>) si la hauteur <var>h</var> n’est pas perpendiculaire à la surface.
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><msub><mi>φ</mi><mrow><mn>2</mn></mrow></msub></mtd></mtr>
<mtr><mtd><msub><mi>λ</mi><mrow><mn>2</mn></mrow></msub></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
<mo>×</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><msub><mi>φ</mi><mrow><mn>1</mn></mrow></msub></mtd></mtr>
<mtr><mtd><msub><mi>λ</mi><mrow><mn>1</mn></mrow></msub></mtd></mtr>
<mtr><mtd><mi>h</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
</math>
</p><p>
Pour des bibliothèques d’algèbre linéaire, la matrice ci-dessus représente un système d’équations sous-déterminé, et donc insoluble.
C’est-à-dire qu’on ne peut pas inverser cette conversion pour obtenir (<var>φ₂</var>, <var>λ₂</var>) → (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>)
puisqu’on ne sait pas quelle valeur donner à <var>h</var>,
ce qui implique qu’on ne peut pas trouver (<var>φ₁</var>, <var>λ₁</var>) non-plus car ces valeurs dépendent peut-être de <var>h</var>.
Toutefois dans le cas des <abbr>SIG</abbr>, l’axe des hauteurs ellipsoïdales <var>h</var> est perpendiculaire à la surface de l’ellipsoïde
sur laquelle les latitudes et longitudes <em>géodésiques</em> (<var>φ</var>, <var>λ</var>) sont représentées
(notez que cette affirmation ne s’applique pas aux latitudes et longitudes <em>géocentriques</em>).
Cette perpendicularité rend <var>φ₁</var> et <var>λ₁</var> indépendants de <var>h</var>.
Dans ce genre de cas, on peut encore sauver les meubles.
</p><p>
Apache <abbr>SIS</abbr> procède en vérifiant si les valeurs de <var>h</var> sont indépendantes des valeurs de <var>φ</var> et <var>λ</var>.
Nous reconnaissons ce cas en vérifiant quels coefficients de la matrice ont la valeur zéro.
Si <abbr>SIS</abbr> arrive à identifier des dimensions indépendantes,
il peut les exclure temporairement de manière à inverser sans ambiguïté la conversion dans les dimensions restantes.
S’il ne trouve pas de dimension indépendante, alors une exception est levée.
Mais si une inversion a été possible, alors il reste à décider du sort des dimensions que <abbr>SIS</abbr> avait temporairement exclues.
Par défaut, <abbr>SIS</abbr> assignera la valeur <code>NaN</code> (<cite>Not-a-Number</cite>) à ces dimensions.
Toutefois dans le cas particulier des hauteurs ellipsoïdales <var>h</var> dans une opération (<var>φ₂</var>, <var>λ₂</var>) → (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>),
la valeur zéro peut aussi être appropriée dans l’hypothèse où les coordonnées sont habituellement proches de la surface de l’ellipsoïde.
Mais dans tous les cas, le choix du coefficient à mettre à 0 ou <code>NaN</code> est basé sur la présomption que la matrice représente une transformation affine.
Ce n’est pas une opération qui peut être effectuée sur des matrices arbitraires.
</p><p>
Le traitement particulier décrit ci-haut permet à Apache <abbr>SIS</abbr> de résoudre
certains systèmes d’équations sous-déterminés que l’on rencontre couramment dans les <abbr>SIG</abbr>.
Dans notre exemple utilisant <code>NaN</code> comme valeur par défaut, la coordonnée <var>h</var> reste inconnue
– nous ne faisons pas surgir de l’information du néant – mais au moins les coordonnées (<var>φ</var>, <var>λ</var>) ont pu être récupérées.
Le problème inverse, celui des systèmes surdéterminés, est plus subtil.
Une approche classique des bibliothèques d’algèbre linéaire est de résoudre les systèmes surdéterminés par la méthode des moindres carrées.
Transposée à notre exemple, cette approche proposerait une conversion (<var>φ₂</var>, <var>λ₂</var>, <var>h</var>) → (<var>φ₁</var>, <var>λ₁</var>)
qui semble le meilleur compromis pour diverses valeurs de <var>φ₂</var>, <var>λ₂</var> et <var>h</var>,
tout en n’étant (sauf cas particuliers) une solution exacte pour personne.
De plus, les éventuelles combinaisons linéaires entre ces trois variables sont délicates compte tenu de l’hétérogénéité des unités de mesures,
avec par exemple les <var>h</var> en mètres et (<var>φ</var>, <var>λ</var>) en degrés.
Apache <abbr>SIS</abbr> procède plutôt comme pour les systèmes sous-déterminés: en exigeant que certaines dimensions soient indépendantes des autres,
faute de quoi la matrice sera considérée non-inversible.
En conséquence dans le cas des systèmes surdéterminés <abbr>SIS</abbr> refusera d’effectuer certaines opérations que les bibliothèques d’algèbre linéaire auraient faite,
mais en cas de succès les conversions obtenues seront garanties exactes (aux erreurs d’arrondissement prêts).
</p>

<h3 id="MatrixLibrarySummary"><span class="section-number">9.2.2.</span> La bibliothèque matricielle de Apache <abbr title="Spatial Information System">SIS</abbr></h3>
<p>
En résumé, les besoins qui ont amené Apache <abbr>SIS</abbr> à fournir ses propres fonctions de calculs matriciels sont:
</p>
<ul>
<li>Structure légère pour les petites matrices, particulièrement celles de taille 3×3.</li>
<li>Précision accrue avec l’arithmétique « double-double », quitte à sacrifier un peu de performance dans des endroits où elle n’est pas critique.</li>
<li>Traitement particulier de l’inversion des matrices non-carrées pour des conversions de coordonnées.</li>
</ul>
<p>
Cette bibliothèque est fournie dans le paquet <code class="SIS">org.apache.sis.matrix</code> du module <code class="SIS">sis-referencing</code>.
</p>
</section>
</section>
</main>
</body>
</html>