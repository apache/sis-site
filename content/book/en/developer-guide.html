<?xml version="1.0" encoding="UTF-8" standalone="no"?><!--

  Licensed to the Apache Software Foundation (ASF)

      http://www.apache.org/licenses/LICENSE-2.0

  This is an automatically generated file. DO NOT EDIT.
  See the files in the ../../../book/ directory instead.

--><!DOCTYPE html SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<title>Introduction to Apache SIS</title>
<meta charset="UTF-8"/>
<link href="../book.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p style="margin-top: 30pt"><span style="font-size: 30pt; font-weight: 900">Introduction to Apache SIS®</span></p>
<p style="margin-bottom: 20pt">(English | <a href="../fr/developer-guide.html">Français</a>)</p>
<p><i>Martin Desruisseaux</i><br/>
Partially translated by <i>Christina Hough</i></p>
<p>This work is licensed under the Apache 2 license.</p>
<hr/>

<p><b style="font-size: 20pt">Table of content</b></p>
<nav>
<ul class="toc">
<li><a href="#Standards">Standards and norms</a><ul>
<li><a href="#ConceptualModels">Sources of conceptual models used by Apache SIS</a></li>
<li><a href="#GeoAPI">From conceptual models to Java interfaces: GeoAPI</a><ul>
<li><a href="#GeoAPI-implementation">Implementations provided by Apache SIS</a></li></ul></li>
<li><a href="#AboutBook">Conventions used in this guide</a><ul>
<li><a href="#CodeColors">Code colors</a></li></ul></li></ul></li>
<li><a href="#DataAccess">Geospatial data access</a></li>
<li><a href="#Coverage">Data coverages</a></li>
<li><a href="#Geometry">Geometries</a><ul>
<li><a href="#GeometryBase">Base classes</a><ul>
<li><a href="#DirectPosition">Direct points and positions</a></li>
<li><a href="#Envelope">Envelopes</a><ul>
<li><a href="#AntiMeridian">Envelopes that cross the antimeridian</a></li></ul></li></ul></li></ul></li>
<li><a href="#Referencing">Spatial reference systems</a><ul>
<li><a href="#ComponentsOfCRS">Components of a reference system by coordinates</a><ul>
<li><a href="#Ellipsoid">Geoid et ellipsoid</a></li>
<li><a href="#GeodeticDatum">Geodetic datum</a></li>
<li><a href="#CoordinateSystem">Coordinate systems</a><ul>
<li><a href="#AxisOrder">Axis order</a></li></ul></li>
<li><a href="#GeographicCRS">Geographic reference systems</a><ul>
<li><a href="#GeographicWKT">Well-Known Text format</a></li></ul></li>
<li><a href="#ProjectedCRS">Map projections</a><ul>
<li><a href="#ProjectedWKT">Well-Known Text format</a></li></ul></li>
<li><a href="#CompoundCRS">Vertical and temporal dimensions</a><ul>
<li><a href="#CompoundWKT">Well-Known Text format</a></li></ul></li></ul></li>
<li><a href="#GetCRS">Fetching a spatial reference system</a><ul>
<li><a href="#CRSAuthorityFactory">Looking CRS defined by authorities</a></li>
<li><a href="#CRSParsing">Reading definitions in GML or WKT format</a></li>
<li><a href="#CRSFactory">Constructing programmatically</a></li>
<li><a href="#CRS_UserCode">Adding new CRS definitions</a></li></ul></li>
<li><a href="#CoordinateOperations">Coordinate operations</a><ul>
<li><a href="#MathTransform">Executing an operation on coordinate values</a></li>
<li><a href="#TransformDerivative">Partial derivatives of coordinate operations</a><ul>
<li><a href="#DerivativeAndEnvelope">Transform derivatives applied to envelopes</a></li>
<li><a href="#DerivativeAndRaster">Transform derivatives applied to rasters</a></li>
<li><a href="#GetDerivative">Getting the derivative at a point</a></li></ul></li>
<li><a href="#CoordinateOperationSteps">Conceptual versus real chain of coordinate operations</a></li></ul></li>
<li><a href="#Formats">Date storage formats</a></li>
<li><a href="#XML-ISO">Representing objects in XML</a><ul>
<li><a href="#XML-ISO-19115">Representing metadata according to ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification of already-defined instances</a></li>
<li><a href="#nilReason">Representing missing values</a></li></ul></li></ul></li></ul></li>
<li><a href="#Utilities">Utility classes and methods</a><ul>
<li><a href="#ComparisonModes">Comparison modes of objects</a></li>
<li><a href="#ObjectConverters">Object converters</a></li>
<li><a href="#Internationalization">Internationalization</a><ul>
<li><a href="#LocalizedString">Distinct character sequences for each locale</a></li>
<li><a href="#InternationalString">Single instance for all supported locales</a></li>
<li><a href="#Locale.ROOT">Locale.ROOT convention</a></li>
<li><a href="#UnicodePoint">Treatment of characters</a><ul>
<li><a href="#Whitespaces">Blank spaces interpretation</a></li></ul></li></ul></li></ul></li>
<li><a href="#GeoAPI-details">GeoAPI relationship with standards</a><ul>
<li><a href="#GeoAPI-modules">GeoAPI modules</a></li>
<li><a href="#SpecificationToInterfaces">From OGC specifications to Java interfaces</a><ul>
<li><a href="#UML-annotation">Explicit mapping given by @UML annotations</a></li>
<li><a href="#MappingToJDK">Implicit mapping to standard JDK</a></li></ul></li>
<li><a href="#ReduceDependency">Reduce direct dependency to Apache SIS</a><ul>
<li><a href="#UML-annotation-indep">Mapping given by @UML annotations</a></li>
<li><a href="#ServiceLoader">Fetching implementations of GeoAPI interfaces</a><ul>
<li><a href="#GeoAPI-simple">Defining custom implementations</a></li></ul></li></ul></li></ul></li>
<li><a href="#Tests">Test suites</a><ul>
<li><a href="#GeoAPI-conformance">GeoAPI conformance</a><ul>
<li><a href="#GeoAPI-validators">Instance validations</a></li>
<li><a href="#GeoAPI-tests">Executing pre-defined tests</a></li></ul></li></ul></li>
<li><a href="#DesignNotes">Design notes</a><ul>
<li><a href="#AffineTransform">Affine transform</a><ul>
<li><a href="#AffineTransformAPI">Integration with graphical libraries</a></li></ul></li>
<li><a href="#MatrixLibrary">Specificities of a matrix library for GIS</a><ul>
<li><a href="#NonSquareMatrix">What to do with non-square matrices (and why)</a></li>
<li><a href="#MatrixLibrarySummary">Apache SIS matrix library</a></li></ul></li></ul></li>
</ul>
</nav>

<main>












<section>
<header>
<h1 id="Standards"><span class="section-number">1.</span> Standards and norms</h1>
<nav><div class="chapter-links"><div class="next-chapter"><a href="#DataAccess">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#ConceptualModels">Sources of conceptual models used by Apache SIS</a></li>
<li><a href="#GeoAPI">From conceptual models to Java interfaces: GeoAPI</a><ul>
<li><a href="#GeoAPI-implementation">Implementations provided by Apache SIS</a></li></ul></li>
<li><a href="#AboutBook">Conventions used in this guide</a><ul>
<li><a href="#CodeColors">Code colors</a></li></ul></li></ul></nav>
<p>
A geospatial information community is a collection of systems or individuals capable of exchanging their geospatial data
through the use of common standards, allowing them to communicate with one another.
As there are many ways to represent geospatial information, each community tends to structure this information in light of its areas of interest.
This diversity complicates the task of Spatial Information System (<abbr>SIS</abbr>) users
by confronting them with an apparently chaotic variety of data formats and structures.
The characteristics of these structures vary according to the observed phenomenon and measurement methods,
as well as the habits of the organizations producing the data.
Such a variety represents an obstacle in studies that require heterogeneous combinations of data,
especially when they originate in communities that are traditionally distinct.
For example, a researcher studying cholera might be interested in populations of shrimp as a propagation vector of the disease.
But as doctors and oceanographers may not be used to share their work,
the participants of such a study may be limited by the effort required to convert the data.
</p><p>
We cannot impose a uniform format on all data collections, as the diversity of formats is tied to factors
such as the constraints imposed by the measuring apparatus, and the statistical distribution of values.
A more flexible solution is to ensure the interoperability of data across a common programming interface
(<abbr title="Application Programming Interface">API</abbr>).
This <abbr>API</abbr> is not necessarily defined in a programming language;
the actual tendency is rather to define conventions that use existing web protocols, which we can translate into various programming languages.
But in order for this approach to be viable, the <abbr>API</abbr> must be generally accepted by independent developers.
In other words, the <abbr>API</abbr> must come as near as possible to industrial standards.
</p><p>
For example, one task that benefit from a successful standardization is the accessing of relational databases.
The industry has established a common language — the <abbr title="Structured Query Language">SQL</abbr> standard —
that the creators of Java have embedded in standard <abbr title="Java DataBase Connectivity">JDBC</abbr> programming interfaces.
Today, these interfaces are implemented by many software programs, both free and commercial.
Like databases, methods of accessing geographic information have been standardized.
In this case, however, the efforts have been more recent, and their integration in software — especially in older programs — is incomplete and not always coherent.
At the time of writing, no product to our knowledge has implemented all of the specifications in their entirety.
However, there are many implementations that cover a fairly large spectrum.
One of these is the Apache <abbr>SIS</abbr>® library that is described in this document.
</p><p>
Apache <abbr title="Spatial Information System">SIS</abbr> is characterized by a sustained effort to comply with standards.
In general, complying with standards demands a greater effort than would be required for an isolated development,
but rewards us with a double advantage: not only does it improve the interoperability of our data with that of external projects,
it also points towards a robust way of elaborating the conceptual model reflected in the <abbr>API</abbr>.
In effect, the groups of experts who conceived the standards anticipated difficulties that sometimes escape the engineer at the beginning of a project,
but which risk to hit them before the end.
</p>






<section>
<header>
<h2 id="ConceptualModels"><span class="section-number">1.1.</span> Sources of conceptual models used by Apache SIS</h2>
</header>
<p>
Most standards used by Apache <abbr title="Spatial Information System">SIS</abbr> have been devised by the <a href="http://www.opengeospatial.org">Open Geospatial Consortium</a> (<abbr>OGC</abbr>),
sometimes in collaboration with the <a href="http://www.iso.org">International Organization for Standardization</a> (<abbr>ISO</abbr>).
Some <abbr>ISO</abbr> standards themselves become European standards via the <a href="http://inspire.jrc.ec.europa.eu">INSPIRE Directive</a>.
These standards offer two key features:
</p>
<ul>
<li>
Allowing a community to make its information public in such a way that outside individuals or systems can discover it.
</li>
<li>
Transferring information from one community to another while preserving its semantics,
even if the two communities use very different internal representations.
</li>
</ul>
<p>
These standards are made available to the international community for free,
as <a href="http://www.opengeospatial.org/standards/is">specifications (<abbr title="Portable Document Format">PDF</abbr> files)</a> or
as <a href="http://schemas.opengis.net/gml/3.3/">schemas (<abbr title="XML Schema Definition">XSD</abbr> files)</a>.
Standardization organizations do not create software; to obtain an implementation of these specifications,
users must choose one of the compliant products available on the market, or develop their own solutions.
Such voluntary compliance with these specifications allow independent communities to more easily exchange geographic information.
</p>



<details>
<summary>More about standardization process</summary>
<article id="OGC-process">
<header>
<h2><abbr>OGC</abbr> standardization process</h2>
</header>
<p>
The work of the <abbr title="Open Geospatial Consortium">OGC</abbr> is done by email, teleconferences, and at <a href="http://www.opengeospatial.org/event?category=ogctcpc">in-person meetings</a>.
The <abbr>OGC</abbr> organizes four meetings per year, each lasting five days, and hosted by member organizations that sponsor the event (companies, universities, research centres, <i>etc</i>).
The host continent alternates between Europe and North America, with a growing presence in Asia since 2011.
These meetings are usually attended by between 50 and 100 participants from among the hundreds of members of the <abbr>OGC</abbr>.
Some participants are present at almost all the meetings, forming the pillars of the organization.
The meetings of the <abbr>OGC</abbr> offer opportunities for exchange among members from diverse backgrounds.
</p><p>
The creation of a <abbr>OGC</abbr> standard begins with a gathering of organizations or individuals with a common interest in an issue.
A working group is proposed as a <i>Domain Working Group</i> (<abbr>DWG</abbr>) or as a <i>Standard Working Group</i> (<abbr>SWG</abbr>).
<abbr>DWG</abbr>s are open to all members of the <abbr>OGC</abbr>,
while <abbr>SWG</abbr>s require that their participants enter into an agreement not to hinder the distribution of the standard through intellectual property claims.
</p>

<h3 id="OGC-SWG">Standard Working Group (<abbr>SWG</abbr>) procedures</h3>
<p>
In order to be accepted, a standardization project must be supported by a minimum number of members belonging to distinct organizations.
These founding members draft a charter defining the objectives of the <abbr>SWG</abbr>,
which must be approved by the Technical Committee of the <abbr title="Open Geospatial Consortium">OGC</abbr>.
Each founding member is endowed with the right to vote, with a limit of one voting member per organization.
Each new member that wishes to join the <abbr>SWG</abbr> after its creation is granted the role of observer,
and receives on request the right to vote after several months of observation.
</p><p>
A <abbr>SWG</abbr> may contain several dozen members, but the volunteers performing the bulk of the work are usually fewer.
Their proposals are submitted to the entire membership of the group, who may accept them by unanimous consent.
Any objections must be debated, and an alternative proposed.
<abbr>SWG</abbr>s usually try to debate an issue until a consensus emerges rather than move ahead despite negative votes,
even if those opposed are in a minority.
The decisions of the group are then integrated into the specifications by a member who assumes the role of editor.
</p><p>
As far as possible, the working group must structure the specifications as a core around which various extensions might be built.
A series of tests must accompany the standard, allowing implementations to be classified by the level of test passed.
There must be at least one <i>reference implementation</i> that passes all the tests in order to demonstrate that the standard is usable.
</p><p>
When the standard is considered ready, the <abbr>SWG</abbr> votes on a motion proposing its submission to a vote by the higher authorities of the <abbr>OGC</abbr>.
This process takes several months. There is a faster process for approving <i>de facto</i> standards, but it is applied sparingly.
</p>

<h3 id="OGC-OAB">The Architecture Board (<abbr>OAB</abbr>) and the Technical Committee (<abbr>TC</abbr>)</h3>
<p>
All proposals for standards are first examined by the <abbr title="Open Geospatial Consortium">OGC</abbr> Architecture Board (<abbr>OAB</abbr>).
This board ensures that the standard conforms to the requirements of the <abbr>OGC</abbr> in form,
modularization, and in terms of integration with other standards.
If the <abbr>OAB</abbr> approves it, the standard is next submitted to a vote by the members of the Technical Committee (<abbr>TC</abbr>).
This committee consists of the principal members of the <abbr>OGC</abbr>, and only they are capable of granting final approval.
If approved, the standard is made publicly available for comments during a period of several months.
At the end of this period, the <abbr title="Standard Working Group">SWG</abbr> must examine and respond to each comment.
The eventual modifications of the standard are submitted to the <abbr>OAB</abbr>, then the standard is published in its final form.
This distribution is announced in a press release by the <abbr>OGC</abbr>.
</p><p>
Certain members of the <abbr title="Open Geospatial Consortium">OGC</abbr> and the <abbr title="Technical Committee">TC</abbr>
also act as liaisons with the International Organization for Standardization (<abbr>ISO</abbr>).
Cooperation between the two organizations goes two ways:
the <abbr>OGC</abbr> adopts the <abbr>ISO</abbr> standards as a foundation on which to develop new standards,
and certain <abbr>OGC</abbr> standards become <abbr>ISO</abbr> standards.
</p>

<h3 id="OGC-RFC">Procedure for the submission of proposals for modification</h3>
<p>
All users, whether or not they are members of the Open Geospatial Consortium, may propose modifications to <abbr title="Open Geospatial Consortium">OGC</abbr> standards.
A list of current proposals for changes, along with a form for submitting new proposals, is <a href="http://www.opengeospatial.org/standards/cr">available online</a>.
Each proposal is reviewed by the <abbr title="Standard Working Group">SWG</abbr>.
</p><p>
Some working groups use other parallel systems for submissions, for example GitHub merge requests, hosted outside of the structures of the <abbr>OGC</abbr>.
</p>
</article>
</details>



<p>
Besides these formal standardization organizations, there are organizations that are not officially dedicated
to the creation of standards, but whose work has largely been adopted as <i>de facto</i> standards.
In particular, the <a href="http://www.epsg.org">EPSG</a> database offers numeric codes which allow the easy identification of a
Coordinates Reference System (<abbr>CRS</abbr>) among <a href="../../tables/CoordinateReferenceSystems.html">several thousand</a>.
This database is offered by petroleum companies that have an interest in ensuring their explorations are conducted in the correct place,
even when using map produced by another party.
Other examples of <i>de facto</i> standards include <a href="http://geotiff.osgeo.org">GeoTIFF</a> for data distributed on a grid (such as images),
and <a href="http://en.wikipedia.org/wiki/Shapefile">Shapefile</a> for vector data (such as geometric shapes).
</p><p>
<abbr>OGC</abbr> standards are specified in several dozen documents.
Each document outlines a service — for example, the transformation of coordinates.
The function of each service is described by a collection of object classes and their interactions.
These elements are illustrated by <abbr>UML</abbr> (Unified Modeling Language) diagrams in specifications called “abstracts”.
<a href="http://www.opengeospatial.org/standards/as">Abstract specifications</a> do not refer to any specific computer language.
Their concepts may be applied more or less directly to a programming language, a database or an <abbr>XML</abbr> schema.
There is always an element of arbitrariness in the method of applying an abstract specification,
given that adjustments are often necessary to take into account the constraints or conventions of the target language.
Certain data structures only exist in a few languages — for example, unions that exist in C/C++ but not in Java.
</p>



<details>
<summary>More about “implementation specifications”</summary>
<article id="implementation-standard">
<header>
<h2>Historical note</h2>
</header>
<p>
At the turn of the millennium, the abstract specifications were explicitly concretized in <i>implementation specifications</i>.
The term “implementation” is used here in the sense of all types of interfaces (Java or others) derived from
<abbr title="Unified Modeling Language">UML</abbr> diagrams, and not implementations in the Java sense.
Such specifications existed for <abbr title="Structured Query Language">SQL</abbr>,
<abbr title="Common Object Request Broker Architecture">CORBA</abbr>, <abbr title="Component Object Model">COM</abbr>, and Java languages.
As these languages are capable of executing procedures, the specifications of this period define not only data structures,
but also operations that apply to these structures.
</p><p>
Thereafter, enthusiasm for “Web 2.0” increased interest for <abbr>XML</abbr> over other languages.
Older implementation specifications were deprecated,
and <abbr title="XML Schema Definition">XSD</abbr> schemas became the main concretization of abstract specifications.
Even the way abstract specifications are designed has evolved: they are less likely to define operations, and so what remains is closer to descriptions of database schemas.
Some operations that were defined in older standards now appear, in another form, in web service specifications.
Finally, the term “implementation specification” has been deprecated, to be subsumed under the term “<abbr title="Open Geospatial Consortium">OGC</abbr> standard.”
But despite their depreciation, <a href="http://www.opengeospatial.org/docs/retired">old implementation specifications</a> remain useful to programs in Java, because:
</p>
<ul>
<li>Their simpler models, applied to the same concepts, are helpful in understanding new specifications.</li>
<li>They sometimes define easy ways to perform common tasks, where the newer specifications limit themselves to general cases.</li>
<li>As operations are more often omitted from the newer specifications, the old ones remain a useful supplement when defining <abbr title="Application Programming Interface">API</abbr>s.</li>
</ul>
<p>
The Apache <abbr title="Spatial Information System">SIS</abbr> project is based on the most recent specifications,
drawing from the archives of the <abbr>OGC</abbr> to complete certain abstract standards or make them more usable.
Some old definitions are preserved as “convenience methods”, not always bringing new functionality, but facilitating the practical use of a library.
</p>
</article>
</details>
<p>
The following table lists the main norms used by the project.
Many norms are published both as <abbr>ISO</abbr> standards and as <abbr>OGC</abbr> standards,
and their corresponding names are listed next to one another in the first two columns.
The “implementation specifications” section lists specifications that bring few new concepts compared to abstract specifications,
but detail how to represent those concepts in specific environments like <abbr>XML</abbr> documents.
Standards that are deprecated but still partially used appear <s>struck through</s>.
Finally, GeoAPI packages will be introduced in upcoming chapters.
</p>
<table>
<caption>Main Standards Related to the Apache <abbr>SIS</abbr> project</caption>
<tr>
<th><abbr>ISO</abbr> Norm</th>
<th><abbr>OGC</abbr> Norm</th>
<th>Titre</th>
<th>GeoAPI package</th>
<th>Apache SIS package</th>
</tr><tr>
<td class="separator" colspan="5">Abstract Specifications</td>
</tr><tr>
<td><abbr>ISO</abbr> 19103</td>
<td/>
<td><i>Conceptual schema language</i></td>
<td><code class="GeoAPI">org.opengis.util</code></td>
<td><code class="SIS">org.apache.sis.util.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-1</td>
<td>Topic 11</td>
<td><i>Metadata</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-2</td>
<td/>
<td><i>Metadata — extensions for imagery and gridded data</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111</td>
<td>Topic 2</td>
<td><i>Spatial referencing by coordinates</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111-2</td>
<td/>
<td><i>Referencing — extension for parametric values</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19112</td>
<td/>
<td><i>Spatial referencing by geographic identifier</i></td>
<td><code class="GeoAPI">org.opengis.referencing.gazetteer</code></td>
<td><code class="SIS">org.apache.sis.referencing.gazetteer</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19108</td>
<td/>
<td><i>Temporal Schema</i></td>
<td><code class="GeoAPI">org.opengis.temporal</code></td>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19107</td>
<td>Topic 1</td>
<td><i>Feature geometry</i></td>
<td><code class="GeoAPI">org.opengis.geometry</code></td>
<td><code class="SIS">org.apache.sis.geometry</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19109</td>
<td>Topic 5</td>
<td><i>Rules for application schema</i></td>
<td><code class="GeoAPI">org.opengis.feature</code></td>
<td><code class="SIS">org.apache.sis.feature</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19123</td>
<td>Topic 6</td>
<td><i>Schema for coverage geometry and functions</i></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19156</td>
<td>Topic 20</td>
<td><i>Observations and measurements</i></td>
<td><code class="GeoAPI">org.opengis.observation</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Implementation Specifications</td>
</tr><tr>
<td><abbr>ISO</abbr> 19139</td>
<td/>
<td><i>Metadata <abbr>XML</abbr> schema implementation</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19136</td>
<td>OGC 07-036</td>
<td><i>Geography Markup Language (<abbr>GML</abbr>) Encoding Standard</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19162</td>
<td>OGC 12-063</td>
<td><i>Well-known text representation of coordinate reference systems</i></td>
<td/>
<td><code class="SIS">org.apache.sis.io.wkt</code></td>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-009</s></td>
<td><s><i>Coordinate Transformation Services</i></s></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-004</s></td>
<td><s><i>Grid Coverage</i></s></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td/>
<td><abbr>OGC</abbr> 10-092</td>
<td><i>NetCDF binary encoding: classic and 64-bit offset format</i></td>
<td/>
<td><code class="SIS">org.apache.sis.storage.netcdf</code></td>
</tr><tr>
<td/>
<td><abbr>OGC</abbr> 14-084</td>
<td><i>Moving features Comma Separated Values (CSV) encoding</i></td>
<td/>
<td><code class="SIS">org.apache.sis.storage</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 13249</td>
<td/>
<td><i><abbr>SQL</abbr> spatial</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SLD</abbr></td>
<td><i>Styled Layer Descriptor</i></td>
<td><code class="GeoAPI">org.opengis.style</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Web Services</td>
</tr><tr>
<td/>
<td><abbr>CSW</abbr></td>
<td><i>Catalog Services</i></td>
<td/>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19128</td>
<td><abbr>WMS</abbr></td>
<td><i>Web Map Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WMTS</abbr></td>
<td><i>Web Map Tile Service</i></td>
<td/>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19142</td>
<td><abbr>WFS</abbr></td>
<td><i>Web Feature Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WCS</abbr></td>
<td><i>Web Coverage Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WPS</abbr></td>
<td><i>Web Processing Service</i></td>
<td/>
<td/>
</tr>
<tr>
<td/>
<td>Open<abbr>LS</abbr></td>
<td><i>Location Services</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SWE</abbr></td>
<td><i>Sensor Web Enablement</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SOS</abbr></td>
<td><i>Sensor Observation Service</i></td>
<td/>
<td/>
</tr>
</table>
</section>


<section>
<header>
<h2 id="GeoAPI"><span class="section-number">1.2.</span> From conceptual models to Java interfaces: GeoAPI</h2>
</header>
<p>
The <a href="http://www.geoapi.org">GeoAPI</a> project offers a set of Java interfaces for geospatial applications.
In a series of <code class="GeoAPI">org.opengis.*</code> packages, GeoAPI defines structures representing metadata,
coordinate reference systems and operations that perform cartographic projections.
In a part that is not yet standardized — called <i>pending</i> — GeoAPI defines structures that represent geo-referenced images,
geometries, filters that can be applied to queries, and other features.
These interfaces closely follow the specifications of the <abbr title="Open Geospatial Consortium">OGC</abbr>, while interpreting and adapting them
to meet the needs of Java developers — for example, conforming with naming conventions.
These interfaces benefit both client applications and libraries:
</p>
<ul>
<li><p>
Developers of client applications benefit from the greater knowledge base available on the Internet
(due to the many publications related to <abbr>OGC</abbr> standards), as well as increased interoperability.
Interoperability is facilitated by a better separation between applications that <em>call</em> GeoAPI functions,
and libraries that <em>implement</em> GeoAPI.
The separation is similar to that offered by the <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/"><abbr title="Java DataBase Connectivity">JDBC</abbr></a> (<i>Java Database Connectivity</i>) interfaces of standard Java.
Using the interfaces’ <abbr title="Application Programming Interface">API</abbr>, developers can ignore the underlying implementation.
For example, they can perform cartographic projections with the help of the <a href="http://www.geoapi.org/geoapi-proj4/index.html">Proj.4</a> library, or the Apache <abbr title="Spatial Information System">SIS</abbr> library,
without having to change their programs when they change libraries.
</p></li>
<li><p>
The developers of libraries inherit the expertise of the specifications’ authors, via the models that represent interfaces.
GeoAPI also provides a framework within which developers can prioritize the implementation of the features they most need,
while leaving the remaining features as extension points for future developments.
For example, clients can call a GeoAPI function even if it is not yet supported by the library,
and simply get a null value until a new version of the library returns a relevant value.
</p></li>
</ul>


<details>
<summary>More about the GeoAPI project</summary>
<article id="GeoAPI-history">
<header>
<h2>GeoAPI project history</h2>
</header>
<p>
In 2001, the Open GIS Consortium (the former name of the Open Geospatial Consortium) published
<a href="http://www.opengeospatial.org/standards/ct"><abbr title="Open Geospatial Consortium">OGC</abbr> implementation specification 01-009:
<cite>Coordinate Transformation Services</cite></a>.
This specification, developed by the Computer Aided Development Corporation (Cadcorp),
was accompanied by <abbr title="Component Object Model">COM</abbr>, <abbr title="Common Object Request Broker Architecture">CORBA</abbr>, and Java interfaces.
At this time, the wave of web services had not yet eclipsed classical programming interfaces.
The interfaces of the <abbr>OGC</abbr> did anticipate a networked world,
but invested rather — in the case of Java — in <abbr>RMI</abbr> (<i>Remote Method Invocation</i>) technology.
As the GeoAPI project did not yet exist, we retroactively designate these historical interfaces “<a href="http://www.geoapi.org/0.1/index.html">GeoAPI 0.1</a>”.
These interfaces already used the package name <code class="GeoAPI">org.opengis</code>, which would be adopted by GeoAPI.
</p><p>
In 2002, developers of free projects launched a
<a href="http://web.archive.org/web/20030509104308/http://digitalearth.org/story/2002/10/10/55046/206">call for the creation of a geospatial <abbr title="Application Programming Interface">API</abbr></a>.
The initial proposal attracted the interest of at least five free projects.
The project was created using <a href="http://sourceforge.net/projects/geoapi/">SourceForge</a>,
which has since hosted the source code in a <a href="http://www.geoapi.org/source-repository.html">Subversion repository</a>.
It was then that the project assumed the name “GeoAPI”, and used the interfaces of the <abbr>OGC</abbr> specification 01-009 as a starting point.
</p><p>
A few months later, the <abbr>OGC</abbr> launched the <a href="http://www.opengeospatial.org/standards/go"><abbr>GO</abbr>-1: <i>Geographic Objects</i></a> project,
which pursued goals similar to those of GeoAPI.
In the meantime, the <abbr>OGC</abbr> abandonned some of their specifications in favor of <abbr>ISO</abbr> standards.
GeoAPI and <abbr>GO-1</abbr> worked jointly to rework the GeoAPI interfaces and base them on the new <abbr>ISO</abbr> norms.
Their first interation, <a href="http://www.geoapi.org/1.0/index.html">GeoAPI 1.0</a>,
served as a starting point for the first draft of the <abbr>OGC</abbr> specification 03-064 by the <abbr>GO</abbr>-1 working group.
The final version of this specification became an <abbr>OGC</abbr> standard in 2005,
and <a href="http://www.geoapi.org/2.0/index.html">GeoAPI 2.0</a> was published at that time.
</p><p>
The <abbr>GO</abbr>-1 project was largely supported by a company called <i>Polexis</i>.
Its acquisition by <i>Sys Technology</i>, and the change in priorities under the new owners,
brought a halt to the <abbr>GO</abbr>-1 project, which in turn slowed development on GeoAPI.
In order to resume development, a new working group entitled “GeoAPI 3.0” was created at the <abbr>OGC</abbr>.
This group took a narrower focus compared to GeoAPI 2.0, concentrating on the most stable interfaces, and putting the others
— such as geometries — in a module entitled “<a href="http://www.geoapi.org/geoapi-pending/index.html">pending</a>”, for future consideration.
<a href="http://www.geoapi.org/3.0/index.html">GeoAPI 3.0</a> became an <a href="http://www.opengeospatial.org/standards/geoapi"><abbr>OGC</abbr> standard</a> in 2011.
This version was the first to be deployed in the <a href="http://search.maven.org/#search|ga|1|geoapi">Maven central repository</a>.
</p>
</article>
</details>

<p id="GeoAPI-core">
GeoAPI is composed of many modules.
The <code class="GeoAPI">geoapi</code> and <code class="GeoAPI">geoapi-pending</code> modules
provide interfaces derived from <abbr title="Unified Modeling Language">UML</abbr> schemas of international standards.
The conceptual model will be explained in detail in the chapters describing Apache <abbr title="Spatial Information System">SIS</abbr> implementation.
However, we can get an overview of its content by consulting the page listing the mapping between
<a href="http://www.geoapi.org/3.0/javadoc/content.html">GeoAPI methods and the standards where they come from</a>.
Those modules and the mapping between GeoAPI and international standards are described in more details <a href="#SpecificationToInterfaces">in annex</a>.
</p>



<h3 id="GeoAPI-implementation"><span class="section-number">1.2.1.</span> Implementations provided by Apache SIS</h3>
<p>
Apache SIS implements most GeoAPI interfaces by a class of the same name than the interface
but prefixed by “<code>Abstract</code>”, “<code>Default</code>” or “<code>General</code>”.
Apache SIS classes prefixed by “<code>Default</code>” can be instantiated directly by a
<code>new DefaultXXX(…)</code> statement or by a call to the <code>createXXX(…)</code> method in a factory.
</p>
<div class="example"><b>Example:</b> to represent a projected coordinate reference system (Mercator, Lambert, <i>etc</i>):
<ul>
<li><code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> is the GeoAPI interface derived from ISO 19111 standard, and</li>
<li><code class="SIS">org.apache.sis.referencing.crs.DefaultProjectedCRS</code> is the implementation provided by Apache SIS.</li>
</ul>
An instance can be created by:
<ul>
<li><code>ProjectedCRS crs = new DefaultProjectedCRS(…)</code>, ou</li>
<li><code>ProjectedCRS crs = CRSFactory​.createProjectedCRS(…)</code>.</li>
</ul>
Both approaches expect the same arguments (omitted in this example for brevity).
</div>
<p>
In the default Apache SIS configuration, using <code class="GeoAPI">CRSFactory​.createXXX(…)</code> or <code>new DefaultXXX(…)</code>
is almost the same except that <code class="GeoAPI">Factory</code> may return existing instances instead than creating new instances,
and that exceptions thrown in case of invalid arguments are different types.
In more advanced configurations, using <code class="GeoAPI">Factory</code> reduces the
<a href="#ServiceLoader">direct dependencies toward Apache SIS</a>
and allows inversion of control.
</p><p>
The “<code>General</code>” prefix is sometime used instead than “<code>Default</code>”
to indicate that alternative implementations are available for some specific cases.
For example the <code>Envelope</code> interface is implemented by at least two Apache SIS classes:
<code class="SIS">GeneralEnvelope</code> and <code>Envelope2D</code>.
The first implementation can represent envelopes with any number of dimensions
while the second implementation is specialized for two-dimensional envelopes.
</p><p>
Apache SIS classes prefixed by “<code>Abstract</code>” should not – in principle – be instantiated.
Users should instantiate a non-abstract subclass instead.
But many SIS classes are only conceptually abstract, without <code>abstract</code> Java keyword in class definition.
Such classes can be instantiated by a <code>new AbstractXXX(…)</code> statement
– but not by <code class="GeoAPI">Factory</code> – despite being conceptually abstract.
However such instantiations should be done only in last resort, when it is not possible to determine the exact subtype.
</p>
</section>


<section>
<header>
<h2 id="AboutBook"><span class="section-number">1.3.</span> Conventions used in this guide</h2>
</header>
<p>
Standards sometimes favour the application of certain generic terms to particular contexts,
which may differ from the context in which other communities use these terms.
For example, the terms <i>domain</i> and <i>range</i> may apply to arbitrary functions in order to designate
a set of possible values of inputs and outputs respectively.
But the functions to which they are applied by certain <abbr>ISO</abbr> standards are not the same as the functions to which they are applied by other libraries.
For example, <abbr>ISO</abbr> 19123 applies these terms to <code class="OGC">CV_Coverage</code> objects,
seen as functions in which the <i>domain</i> is the set of spatio-temporal coordinates encompassed by the data,
and the <i>range</i> is the set of values encompassed.
But <abbr title="University Corporation for Atmospheric Research">UCAR</abbr>’s <abbr title="Network Common Data Form">netCDF</abbr> library
applies these terms instead to the function of converting pixel indices (its <i>domain</i>) to spatial-temporal coordinates (its <i>range</i>).
Thus the <abbr>UCAR</abbr> library’s <i>range</i> may be the <i>domain</i> of <abbr>ISO</abbr> 19123.
</p><p>
The Apache <abbr title="Spatial Information System">SIS</abbr> library prefers as much as possible to use terms in the sense of <abbr title="Open Geospatial Consortium">OGC</abbr> and <abbr>ISO</abbr> norms.
Particular care must be taken, however, with the interfaces between <abbr>SIS</abbr> and certain other external libraries,
in order to reduce the risk of confusion.
</p>



<h3 id="CodeColors"><span class="section-number">1.3.1.</span> Code colors</h3>
<p>
The elements defined in a computer language, such as classes and methods in Java or elements in an <abbr>XML</abbr> document,
appear in monospaced font.
In order to facilitate an understanding of the relationships between Apache <abbr title="Spatial Information System">SIS</abbr> and the standards, these elements are also represented using the following colour codes:
</p>
<ul>
<li>
Elements defined in the <abbr title="Open Geospatial Consortium">OGC</abbr> standard
or the <abbr title="International Organization for Standardization">ISO</abbr> standard appear in blue.
Example: <code class="OGC">CD_Ellipsoid</code>.
</li>
<li>
Elements defined in GeoAPI appear in green.
Example: <code class="GeoAPI">Ellipsoid</code>.
</li>
<li>
Elements defined in Apache <abbr title="Spatial Information System">SIS</abbr> appear in brown.
Example: <code class="SIS">DefaultEllipsoid</code>.
</li>
<li>
Other elements, such as those in standard Java, are left in black.
Example: <code>String</code>.
</li>
</ul>
<p>
Text in gray boxes are for information purpose only and can be ignored.
</p>
</section>
</section>


<section>
<header>
<h1 id="DataAccess"><span class="section-number">2.</span> Geospatial data access</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Standards">Previous chapter</a></div><div class="next-chapter"><a href="#Coverage">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc"/></nav>
<p>
<span style="color: red">TODO</span>
</p>

<p>
The <abbr title="International Organization for Standardization">ISO</abbr> 19115 standard defines hundreds of elements.
Some of them will be introduced progressively in next chapters.
But in order to give some idea about what is available, the following table lists a few metadata elements.
Most of the nodes accept an arbitrary amount of values.
For example the <code class="OGC">extent</code> node may contain many geographic areas.
</p>

<table style="line-height:1">
<caption>Extract of a few metadata elements from ISO 19115</caption>
<tr><th>Élément</th>                                <th>Description</th></tr>
<tr><td style="padding-top:9px">Metadata</td>       <td style="padding-top:9px">Metadata about a dataset, service or other resources.</td></tr>
<tr><td>  ├─Reference system info</td>              <td>Description of the spatial and temporal reference systems used in the dataset.</td></tr>
<tr><td>  ├─Identification info</td>                <td>Basic information about the resource(s) to which the metadata applies.</td></tr>
<tr><td>  │   ├─Citation</td>                       <td>Name by which the cited resource is known, reference dates, presentation form, <i>etc.</i></td></tr>
<tr><td>  │   │   └─Cited responsible party</td>    <td>Role, name, contact and position information for individuals or organisations that are responsible for the resource.</td></tr>
<tr><td>  │   ├─Topic category</td>                 <td>Main theme(s) of the resource (e.g. farming, climatology, environment, economy, health, transportation, <i>etc.</i>).</td></tr>
<tr><td>  │   ├─Descriptive keywords</td>           <td>Category keywords, their type, and reference source.</td></tr>
<tr><td>  │   ├─Spatial resolution</td>             <td>Factor which provides a general understanding of the density of spatial data in the resource.</td></tr>
<tr><td>  │   ├─Temporal resolution</td>            <td>Smallest resolvable temporal period in a resource.</td></tr>
<tr><td>  │   ├─Extent</td>                         <td>Spatial and temporal extent of the resource.</td></tr>
<tr><td>  │   ├─Resource format</td>                <td>Description of the format of the resource(s).</td></tr>
<tr><td>  │   ├─Resource maintenance</td>           <td>Information about the frequency of resource updates, and the scope of those updates.</td></tr>
<tr><td>  │   └─Resource constraints</td>           <td>Information about constraints (legal or security) which apply to the resource(s).</td></tr>
<tr><td>  ├─Content info</td>                       <td>Information about the feature catalogue and describes the coverage and image data characteristics.</td></tr>
<tr><td>  │   ├─Imaging condition</td>              <td>Conditions which affected the image (e.g. blurred image, fog, semi darkness, <i>etc.</i>).</td></tr>
<tr><td>  │   ├─Cloud cover percentage</td>         <td>Area of the dataset obscured by clouds, expressed as a percentage of the spatial extent.</td></tr>
<tr><td>  │   └─Attribute group</td>                <td>Information on attribute groups of the resource.</td></tr>
<tr><td>  │       ├─Content type</td>               <td>Types of information represented by the values (e.g. thematic classification, physical measurement, <i>etc.</i>).</td></tr>
<tr><td>  │       └─Attribute</td>                  <td>Information on an attribute of the resource.</td></tr>
<tr><td>  │           ├─Sequence identifier</td>    <td>Unique name or number that identifies attributes included in the coverage.</td></tr>
<tr><td>  │           ├─Peak response</td>          <td>Wavelength at which the response is the highest.</td></tr>
<tr><td>  │           ├─Min/max value</td>          <td>Minimum/maximum value of data values in each sample dimension included in the resource.</td></tr>
<tr><td>  │           ├─Units</td>                  <td>Units of data in each dimension included in the resource.</td></tr>
<tr><td>  │           └─Transfer function type</td> <td>Type of transfer function to be used when scaling a physical value for a given element.</td></tr>
<tr><td>  ├─Distribution info</td>                  <td>Information about the distributor of and options for obtaining the resource(s).</td></tr>
<tr><td>  │   ├─Distribution format</td>            <td>Description of the format of the data to be distributed.</td></tr>
<tr><td>  │   └─Transfer options</td>               <td>Technical means and media by which a resource is obtained from the distributor.</td></tr>
<tr><td>  ├─Data quality info</td>                  <td>Overall assessment of quality of a resource(s).</td></tr>
<tr><td>  ├─Acquisition information</td>            <td>Information about the acquisition of the data.</td></tr>
<tr><td>  │   ├─Environmental conditions</td>       <td>Record of the environmental circumstances during the data acquisition.</td></tr>
<tr><td>  │   └─Platform</td>                       <td>General information about the platform from which the data were taken.</td></tr>
<tr><td>  │       └─Instrument</td>                 <td>Instrument(s) mounted on a platform.</td></tr>
<tr><td>  └─Resource lineage</td>                   <td>Information about the provenance, sources and/or the production processes applied to the resource.</td></tr>
<tr><td>      ├─Source</td>                         <td>Information about the source data used in creating the data specified by the scope.</td></tr>
<tr><td>      └─Process step</td>                   <td>Information about events in the life of a resource specified by the scope.</td></tr>
</table>
</section>


<section>
<header>
<h1 id="Coverage"><span class="section-number">3.</span> Data coverages</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#DataAccess">Previous chapter</a></div><div class="next-chapter"><a href="#Geometry">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc"/></nav>
<p>
Images, or <i>rasters</i>, are a particular case of a data structure called a <i>coverage</i>.
We could think of this as a “coverage of data.”
The title of the <abbr title="International Organization for Standardization">ISO</abbr> 19123 standard that describes them, “Coverage Geometry and Functions”,
nicely summarizes the two essential elements of coverages:
</p>
<ul>
<li>
<p>
A coverage is a function which returns an attribute value from an entered coordinate.
The set of values that may be entered is called the domain, while the set of values that may be returned is called the range.
The domain is often the spatio-temporal area covered by the data,
but nothing in <abbr title="Spatial Information System">SIS</abbr> prevents coverages from extending to other dimensions.
For example, thermodynamic studies often use an area where the dimensions are temperature and pressure.
</p>
<div class="example"><p><b>Example:</b>
The pixel values of an image may contain measures for terrain elevation.
If the function <var>h</var> = <var>f</var>(φ,λ) allows us to obtain (eventually, with the help of interpolations)
the elevation <var>h</var> according the the geographic coordinate (φ,λ),
then the geographic envelope of the image defined by the domain — the function <var>f</var> — is the <i>coverage</i>,
and the set of values <var>h</var> that this function can return is the <i>range</i>.
</p></div>
</li>
<li>
<p>
Different types of coverages may be characterized by the geometry of their cells.
In particular, a coverage is not necessarily composed of quadrilateral cells.
However, given that quadrilateral cells are by far the most frequent (since this is the usual geometry of image pixels),
we often use the term “grid coverage” to specify coverages composed of such cells.
In <abbr>SIS</abbr>, the geometry of coverages is described by the <code class="SIS">GridGeometry</code> class.
</p>
</li>
</ul>
<p>
The characteristics of the spatial domain are defined by <abbr>ISO</abbr> 19123 standard,
while the characteristics of range are not included in the standard.
The standard simply mentions that ranges may be finite or infinite,
and are not necessarily numerical.
For example, the values returned by a coverage may come from an enumeration (“this is a forest,” “this is a lake,” etc.).
However, the standard defines two important types of coverage which have an impact on the types of authorized ranges:
<i>discrete</i> coverages and <i>continuous</i> coverages.
Stated simply, continuous coverages are functions that can use interpolation methods.
Thus, since interpolations are only possible with numeric values, the ranges of non-numeric values may only be used with coverages of the
<code class="OGC">CV_DiscreteCoverage</code> type.
</p>
<aside>
<h2>SIS’s <code class="SIS">Range</code> class and its relationship to the standards</h2>
<p>
The distinction between the ranges of all types of values and the ranges of numeric values is represented in
<abbr title="Spatial Information System">SIS</abbr> by the <code class="SIS">Range</code> and <code class="SIS">NumberRange</code>
classes respectively.
The <code class="SIS">NumberRange</code> is used more often, and is also the one that most closely approaches the
<a href="http://en.wikipedia.org/wiki/Interval_%28mathematics%29">the common mathematical concept of an interval</a>.
This textual representation approaches the specifications of <abbr title="International Organization for Standardization">ISO</abbr> 31-11 standard,
except that the comma is replaced by the character “…” as the separator of minimal and maximal values.
For example, “[0 … 256)” represents the range of values from 0 inclusive to 256 exclusive.
</p>
<p>
<code class="SIS">Range</code> objects are only indirectly associated with coverages.
In <abbr>SIS</abbr>, the values that can return coverages are described by objects of the
<code class="SIS">SampleDimension</code> type. It is these that contain instances of <code class="SIS">Range</code>,
as well as other information such as <i>transfer function</i> (described later).
</p>
</aside>
</section>


<section>
<header>
<h1 id="Geometry"><span class="section-number">4.</span> Geometries</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Coverage">Previous chapter</a></div><div class="next-chapter"><a href="#Referencing">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#GeometryBase">Base classes</a><ul>
<li><a href="#DirectPosition">Direct points and positions</a></li>
<li><a href="#Envelope">Envelopes</a><ul>
<li><a href="#AntiMeridian">Envelopes that cross the antimeridian</a></li></ul></li></ul></li></ul></nav>
<p>
This chapter introduces a few aspects of <abbr title="International Organization for Standardization">ISO</abbr> 19107 standard (<i>Spatial schema</i>)
and the Apache <abbr title="Spatial Information System">SIS</abbr> classes that implement them.
</p>




<section>
<header>
<h2 id="GeometryBase"><span class="section-number">4.1.</span> Base classes</h2>
</header>
<p>
Each geometric object is considered an infinite set of points.
As a set, their most fundamental operations are of the same nature as the standard operations of Java collections.
We may therefore see a geometry as a kind of <code>java.util.Set</code> in which the elements are points,
except that the number of elements contained in the set is infinite (with the exception of geometries representing a simple point).
To better represent this concept, the <abbr title="International Organization for Standardization">ISO</abbr> standard and GeoAPI define a <code class="OGC">TransfiniteSet</code> interface
which we could see as a <code>Set</code> of infinite size.
Although a parent relationship exists conceptually between these interfaces,
GeoAPI does not define <code class="GeoAPI">TransfiniteSet</code> as a sub-interface of <code>java.util.Set</code>,
as the definition of certain methods such as <code>size()</code> and <code>iterator()</code> would be problematic.
However, we find very similar methods such as <code class="GeoAPI">contains(…)</code> and <code class="GeoAPI">intersects(…)</code>.
</p>
<p>
All geometries are specializations of <code class="GeoAPI">TransfiniteSet</code>.
The parent class of those geometries is called <code class="OGC">GM_Object</code> in <abbr>ISO</abbr> 19107 standard.
GeoAPI interfaces use the <code class="GeoAPI">Geometry</code> name instead, as the omission of the <code class="OGC">GM_</code>
prefix (as prescribed in GeoAPI convention) would leave a name too similar to Java’s <code>Object</code> class.
</p>



<h3 id="DirectPosition"><span class="section-number">4.1.1.</span> Direct points and positions</h3>
<p>
<abbr title="International Organization for Standardization">ISO</abbr> 19107 defines two types of structures to represent a point:
<code class="OGC">GM_Point</code> and <code class="OGC">DirectPosition</code>.
The first type is a true geometry and may therefore be relatively cumbersome, depending on the implementation.
The second type is not formally considered to be a geometry;
it extends neither <code class="OGC">GM_Object</code> nor <code class="OGC">TransfiniteSet</code>.
It barely defines any operations besides the storing of a sequence of numbers representing a coordinate.
It may therefore be a more lightweight object.
</p>
<p>
In order to allow the <abbr title="Application Programming Interface">API</abbr> to work equally with these two types of positions,
<abbr>ISO</abbr> 19107 defines <code class="OGC">Position</code> as a <cite>union</cite> of
<code class="OGC">DirectPosition</code> and <code class="OGC">GM_Point</code>.
It is a union in the sense of C/C++. For the Java language, GeoAPI obtains the same effect by defining
<code class="GeoAPI">Position</code> as the parent interface of <code class="GeoAPI">DirectPosition</code> and <code class="GeoAPI">Point</code>.
In practice, the great majority of Apache <abbr title="Spatial Information System">SIS</abbr>’s <abbr>API</abbr> works on <code class="GeoAPI">DirectPosition</code>s,
or occasionally on <code class="GeoAPI">Position</code>s when it seems useful to also allow geometric points.
</p>



<h3 id="Envelope"><span class="section-number">4.1.2.</span> Envelopes</h3>
<p>
Envelopes store minimal and maximal coordinate values of a geometry.
Envelopes are <em>not</em> geometries themselves; they are not infinite sets of points (<code class="OGC">TransfiniteSet</code>).
There is no guarantee that all the positions contained within the limits of an envelope are geographically valid.
Envelopes must be seen as information about extreme values that might take the coordinates of a geometry as if
each dimension were independent of the others, nothing more.
Nevertheless, we speak of envelopes as rectangles, cubes or hyper-cubes (depending on the number of dimensions)
in order to facilitate discussion, while bearing in mind their non-geometric nature.
</p>
<div class="example"><p><b>Example:</b>
We could test whether a position is within the limits of an envelope.
A positive result does not guarantee that the position is within the geometry delimited by the envelope,
but a negative result guarantees that it is outside the envelope.
We can perform intersection tests in the same way.
On the other hand, it makes little sense to apply a rotation to an envelope,
as the result may be very different from that which we would obtain be performing a rotation on the original geometry,
and then recalculating its envelope.
</p></div>
<p>
An envelope might be represented by two positions corresponding to two opposite corners of a rectangle,
cube or hyper-cube.
For the first corner, we often take the one whose ordinates all have the maximal value (<code class="OGC">upperCorner</code>).
When displayed using a conventional system of coordinates (with <var>y</var> axis values running upwards),
these two positions appear respectively in the lower left corner and the upper right corner of a rectangle.
Care must be taken with different coordinate systems, however, which may vary the positions of these corners on the screen.
The expressions <i>lower corner</i> and <i>upper corner</i> should thus be understood in the mathematical rather than the visual sense.
</p>



<h4 id="AntiMeridian"><span class="section-number">4.1.2.1.</span> Envelopes that cross the antimeridian</h4>
<p>
Minimums and maximums are the values most often assigned to <code class="OGC">lowerCorner</code>
and <code class="OGC">upperCorner</code>.
But the situation becomes complicated when an envelope crosses the antimeridian (-180° or 180° longitude).
For example, an envelope 10° in size may begin at 175° longitude and end at -175°.
In this case, the longitude value assigned to <code class="OGC">lowerCorner</code> is greater than that assigned to <code class="OGC">upperCorner</code>.
Apache <abbr title="Spatial Information System">SIS</abbr> therefore uses a slightly different definition of these two corners:
</p>
<ul>
<li><b><code class="SIS">lowerCorner</code>:</b>
the starting point, if we move along the inside of the envelope in the direction of ascending values.
</li>
<li><b><code class="SIS">upperCorner</code>:</b>
the end-point, if we move along the inside of the envelope in the direction of ascending values.
</li>
</ul>
<p>
If the envelope does not cross the antimeridian, these two definitions are equivalent to the selection of minimal and
maximal values respectively. This is the case in the green rectangle in the figure below.
When the envelope crosses the antimeridian, the <code class="SIS">lowerCorner</code> and the
<code class="SIS">upperCorner</code> appear again at the bottom and top of the rectangle
(assuming a standard system of coordinates), so their names remain appropriate from a visual standpoint.
However, the left and right positions are switched.
This case is illustrated by the red rectangle in the figure below.
</p>
<p style="text-align:center">
<img alt="Envelope example with and without anti-meridian spanning." src="../../apidocs/org/apache/sis/geometry/doc-files/AntiMeridian.png"/>
</p>
<p>
The notions of inclusion and intersection, however, interpreted slightly differently in these two cases.
In the usual case where we do not cross the antimeridian, the green rectangle covers a region of inclusion.
The regions excluded from this rectangle continue on to infinity in all directions.
In other words, the region of inclusion is not repeated every 360°.
But in the case of the red rectangle, the information provided by the envelope actually covers a region of exclusion
between the two edges of the rectangle. The region of inclusion extends to infinity to the left and right.
We could stipulate that all longitudes below -180° or above 180° are considered excluded,
but this would be an arbitrary decision that would not be an exact counterpart to the usual case (green rectangle).
A developer may wish to use these values, for example, in a mosaic where the map of the world is repeated several times
horizontally and each repetition is considered distinct.
If developers wish to perform operations as though the regions of inclusion or exclusion were repeated every 360°,
they themselves will have to bring the longitudinal values between -180° and 180° in advance.
All the <code class="SIS">add(…)</code>, <code class="SIS">contains(…)</code>,
<code class="SIS">intersect(…)</code>, etc. functions of all the envelopes defined in the
<code class="SIS">org.apache.sis.geometry</code> package perform their calculations according to this convention.
</p>
<aside>
<h5>Generalizing to other types of axes</h5>
<p>
This section specifically relates to longitude, as it is the most usual example of a cyclic axis.
However, in Apache <abbr title="Spatial Information System">SIS</abbr> envelopes, there is no explicit mention of longitude, or of its 360° cycle.
The characteristics of the range of values of each axis (its extremum, units, type of cycle, etc.)
are attributes of <code class="GeoAPI">CoordinateSystemAxis</code> objects,
indirectly associated with envelopes via the coordinate reference system.
Apache <abbr>SIS</abbr> inspects these attributes to determine the way in which it must perform these operations.
Thus, any axis associated with the code <code class="GeoAPI">RangeMeaning.WRAPAROUND</code> benefit from
the same treatment as does longitude.
For example, this could be a time axis for climatological data (one “year” represents the average temperature in all the
months of January, followed by the average of all the months of February, etc.)
This generalization also applies to longitude axes defined by a range of 0° to 360° rather than -180° to 180°.
</p>
</aside>
<p>
In order for functions such as <code class="SIS">add(…)</code> to work correctly,
all objects involved must use the same coordinate reference system, including the same range of values.
Thus an envelope that expresses longitudes in the range [-180 … +180]° is not compatible with an envelope that expresses
longitudes in the range [0 … 360]°.
The conversions, if necessary, are up to the user
(the <code class="SIS">Envelopes</code> class provides convenience methods to do this).
Moreover, the envelope’s coordinates must be included within the system of coordinates,
unless the developer explicitly decides to consider (for example) 300° longitude as a position distinct from -60°.
The <code class="SIS">GeneralEnvelope</code> class provides a <code class="SIS">normalize()</code> method to bring
coordinates within the desired limits, sometimes at the coast of <cite><i>lower</i></cite> values being higher than
<cite><i>upper</i></cite> values.
</p>
<aside>
<h5>The special case of [+0 … -0] range</h5>
<p>
Java (or more generally, IEEE Standard 754) defines two values distinct from zero:
a positive zero and a negative zero. These two values are considered equal when we compare them with the <code>==</code> operator in Java.
But in <abbr title="Spatial Information System">SIS</abbr> envelopes, they may actually return opposite results for axes using <code class="GeoAPI">RangeMeaning.WRAPAROUND</code>.
An envelope whose range is [0 … 0], [-0 … -0] or [-0 … +0] would normally be considered an empty envelope,
but the [+0 … -0] range would in fact be considered to include the entire set of values all around the world.
This behaviour conforms to the definition of <code class="SIS">lowerCorner</code> and <code class="SIS">upperCorner</code>,
which considers +0 as the starting point, and -0 as the end-point after cycling through all possible values.
Such behaviour only occurs for the pair of values +0 and -0, and only in that order.
For all other real values, if the condition <code>lower</code> <code>==</code> <code>upper</code> is true,
then it is guaranteed that the envelope is empty.
</p>
</aside>
</section>
</section>


<section>
<header>
<h1 id="Referencing"><span class="section-number">5.</span> Spatial reference systems</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Geometry">Previous chapter</a></div><div class="next-chapter"><a href="#Utilities">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#ComponentsOfCRS">Components of a reference system by coordinates</a><ul>
<li><a href="#Ellipsoid">Geoid et ellipsoid</a></li>
<li><a href="#GeodeticDatum">Geodetic datum</a></li>
<li><a href="#CoordinateSystem">Coordinate systems</a><ul>
<li><a href="#AxisOrder">Axis order</a></li></ul></li>
<li><a href="#GeographicCRS">Geographic reference systems</a><ul>
<li><a href="#GeographicWKT">Well-Known Text format</a></li></ul></li>
<li><a href="#ProjectedCRS">Map projections</a><ul>
<li><a href="#ProjectedWKT">Well-Known Text format</a></li></ul></li>
<li><a href="#CompoundCRS">Vertical and temporal dimensions</a><ul>
<li><a href="#CompoundWKT">Well-Known Text format</a></li></ul></li></ul></li>
<li><a href="#GetCRS">Fetching a spatial reference system</a><ul>
<li><a href="#CRSAuthorityFactory">Looking CRS defined by authorities</a></li>
<li><a href="#CRSParsing">Reading definitions in GML or WKT format</a></li>
<li><a href="#CRSFactory">Constructing programmatically</a></li>
<li><a href="#CRS_UserCode">Adding new CRS definitions</a></li></ul></li>
<li><a href="#CoordinateOperations">Coordinate operations</a><ul>
<li><a href="#MathTransform">Executing an operation on coordinate values</a></li>
<li><a href="#TransformDerivative">Partial derivatives of coordinate operations</a><ul>
<li><a href="#DerivativeAndEnvelope">Transform derivatives applied to envelopes</a></li>
<li><a href="#DerivativeAndRaster">Transform derivatives applied to rasters</a></li>
<li><a href="#GetDerivative">Getting the derivative at a point</a></li></ul></li>
<li><a href="#CoordinateOperationSteps">Conceptual versus real chain of coordinate operations</a></li></ul></li>
<li><a href="#Formats">Date storage formats</a></li>
<li><a href="#XML-ISO">Representing objects in XML</a><ul>
<li><a href="#XML-ISO-19115">Representing metadata according to ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification of already-defined instances</a></li>
<li><a href="#nilReason">Representing missing values</a></li></ul></li></ul></li></ul></nav>
<p>
For locating a point on Earth one can use identifiers like city name or postal address
— an approach known as <cite>spatial reference systems by identifiers</cite> —
or use numerical values valid in a given coordinate system like latitudes and longitudes
— an approach known as <cite>spatial reference systems by coordinates</cite>.
Each reference system implies approximations like
the choice of a figure of the Earth (geoid, ellipsoid, <i>etc.</i>) used as an approximation of Earth shape,
the choice of geometric properties (angles, distances, <i>etc.</i>) to be preserved when a map is shown on plane surface, and
a lost of precision when coordinates are transformed to systems using a different <a href="#GeodeticDatum">datum</a>.
</p><p>
A very common misbelief is that one can avoid this complexity by using a single coordinate reference system
(typically <abbr title="World Geodetic System 1984">WGS84</abbr>) as a universal system for all data.
The next chapters will explain why the reality is not so simple.
Whether a universal reference system can suit an application needs or not depends on the desired positional accuracy
and the kind of calculations to be performed with the data.
Unless otherwise specified, Apache <abbr title="Spatial Information System">SIS</abbr> aims to represent coordinates on Earth with an accuracy of one centimetre or better.
But the accuracy can be altered by various situations:
</p>
<ul>
<li>Points should be inside the domain of validity as given by <code class="GeoAPI">ReferenceSystem​.getDomainOfValidity()</code>.</li>
<li>Distance measurements in a given map projection are true only is some special locations,
named for instance “standards parallels”.</li>
<li>Positional accuracy is altered after coordinate transformations.
The new accuracy is described by <code class="GeoAPI">CoordinateOperation​.getCoordinateOperationAccuracy()</code>.</li>
<li>Finding the most appropriate coordinate transformation parameters require the use of a geodetic dataset like <abbr>EPSG</abbr>.
Declaring those parameters within the <abbr>CRS</abbr> (for example with a <code class="OGC">TOWGS84</code> element) is often not sufficient.</li>
</ul>
<article>
<header>
<h2>“Early binding” versus “late binding” implementations</h2>
</header>
<p>
Because of the <abbr title="World Geodetic System 1984">WGS84</abbr> ubiquity, it is tempting to use that system as a hub or a pivot system
for all coordinate transformations.
The use of an “universal” system as a pivot simplifies the design of coordinate transformations libraries.
For example transformations from datum <var>A</var> to datum <var>B</var> can be done by first transforming
from <var>A</var> to <abbr>WGS84</abbr>, then from <abbr>WGS84</abbr> to <var>B</var>.
With such approach, a coordinate transformations library would only need to associate each
<code class="GeoAPI">GeodeticDatum</code> instance with the transformation parameters from that datum to <abbr>WGS84</abbr>.
This approach was encouraged in version 1 of <abbr>WKT</abbr> format, since that format specified a
<code>TOWGS84[…]</code> element (removed in <abbr>WKT</abbr> version 2) precisely for that purpose.
This approach is known in <abbr>EPSG</abbr> guidance notes as “early binding” implementations
since information about coordinate transformations are associated early in geodetic object definitions,
usually right at <code class="GeoAPI">GeographicCRS</code> creation time.
While <abbr>EPSG</abbr> acknowledges that this approach is commonly used,
this is not a recommended strategy for the following reasons:
</p>
<ul>
<li>More than one transformation may exist from datum <var>A</var> to datum <var>B</var>,
where each transformation is designed for a different geographic area.</li>
<li>Some operations are designed specifically for transformations from <var>A</var> to <var>B</var>
and do not have the same accuracy than an operation using <abbr>WGS84</abbr> as an intermediate step.</li>
<li><abbr>WGS84</abbr> itself has been updated many times,
which makes it a kind of moving target (admittedly slowly) for coordinate transformations libraries.</li>
<li>Different systems could be used as the pivot system, for example the <cite>Galileo Reference Frame</cite>
(<abbr>GTRF</abbr>) created for the European <abbr>GPS</abbr> competitor.</li>
</ul>
<div class="example"><p><b>Example:</b>
the <abbr>EPSG</abbr> geodetic dataset defines about 50 transformations from <abbr>NAD27</abbr> to <abbr>NAD83</abbr>.
In an early binding approach, the same geographic <abbr>CRS</abbr> (namely “<abbr>NAD27</abbr>”) in the <abbr>WKT</abbr> 1
format would need to be defined with a <code>TOWGS84[-8, 160, 176]</code> element for coordinates in <abbr>USA</abbr>
or with a <code>TOWGS84[-10, 158, 187]</code> element for coordinates in Canada.
Different parameter values exist for other regions like Cuba, so it is not possible to represent such diversity
with a single <code>TOWGS84[…]</code> element associated to a <abbr>CRS</abbr>.
But even when restricting <abbr>CRS</abbr> usage to the domain of validity of its single <code>TOWGS84[…]</code> element,
those transformations are still approximative with a 10 metres accuracy in the <abbr>USA</abbr> case.
More accurate transformations exist in the form of <abbr>NADCON</abbr> grid shift files,
but those transformations are from <abbr>NAD27</abbr> to <abbr>NAD83</abbr> (which move together on the same continental plate),
not to <abbr>WGS84</abbr> (which move independently).
The difference was often ignored when <abbr>NAD83</abbr> and <abbr>WGS84</abbr> were considered as practically equivalent,
but that assumption is subject to more caution today.
</p></div>
<p>
<abbr>EPSG</abbr> rather recommends the use of “late binding” approach,
in which coordinate transformation methods and parameters are defined for
“<var>A</var> to <var>B</var>” pairs of systems (eventually completed with domain of validity)
rather than associated to standalone datums.
Apache <abbr title="Spatial Information System">SIS</abbr> is a “late binding” implementation,
while some reminiscences of “early binding” approach still exist in the form of the
<code class="SIS">DefaultGeodeticDatum​.getBursaWolfParameters()</code> property.
The later is used only if <abbr>SIS</abbr> fails to apply the late binding approach for given reference systems.
</p>
</article>
<p>
The <code class="SIS">sis-referencing</code> module provides a set of classes implementing
different specializations of the <code class="GeoAPI">ReferenceSystem</code> interface, together with required components.
Those implementations store spatial reference system descriptions, together with metadata like their domain of validity.
However those objects do not perform any operation on coordinate values.
Coordinates <cite>conversions</cite> or <cite>transformations</cite> are performed by another family of types,
with <code class="GeoAPI">CoordinateOperation</code> as the root interface.
Those types will be discussed in <a href="#CoordinateOperation">another section</a>.
</p>






<section>
<header>
<h2 id="ComponentsOfCRS"><span class="section-number">5.1.</span> Components of a reference system by coordinates</h2>
</header>
<p>
Spatial reference systems by coordinates provide necessary information for mapping numerical coordinate values
to real-world locations. In Apache <abbr title="Spatial Information System">SIS</abbr>, most information is contained (directly or indirectly) in
classes with a name ending in <abbr>CRS</abbr>, the abbreviation of <i>Coordinate Reference System</i>.
Those objects contain:
</p>
<ul>
<li>A <i>datum</i>, which specifies among other things which ellipsoid to use as an Earth shape approximation.</li>
<li>A description for each axis: name, direction, units of measurement, range of values.</li>
<li>Sometime a list of parameters, especially when using map projections.</li>
</ul>
<p>
Those systems are described by the <abbr title="International Organization for Standardization">ISO</abbr> 19111 standard (<i>Referencing by Coordinates</i>),
which replaces for most parts the older <abbr>OGC 01-009</abbr> standard (<i>Coordinate Transformation Services</i>).
Those standards are completed by two other standards defining exchange formats:
<abbr>ISO</abbr> 19136 and 19162 respectively for the
<cite>Geographic Markup Language</cite> (<abbr>GML</abbr>) — a <abbr>XML</abbr> format which is quite detailed but verbose —
and the <cite>Well-Known Text</cite> (<abbr>WKT</abbr>) — a text format easier to read by humans.
</p>

<h3 id="Ellipsoid"><span class="section-number">5.1.1.</span> Geoid et ellipsoid</h3>
<p>
Since the real topographic surface is difficult to represent mathematically, it is not used directly.
A slightly more convenient surface is the geoid,
a surface where the gravitational field has the same value everywhere (an equipotential surface).
This surface is perpendicular to the direction of a plumb line at all points.
The geoid surface would be equivalent to the mean sea level if all oceans where at rest,
without winds or permanent currents like the Gulf Stream.
</p><p>
While much smoother than topographic surface, the geoid surface still have hollows and bumps
caused by the uneven distribution of mass inside Earth.
For more convenient mathematical operations, the geoid surface is approximated by an ellipsoid.
This “figure of Earth” is represented in GeoAPI by the <code class="GeoAPI">Ellipsoid</code> interface,
a fundamental component in coordinate reference systems of kind <code class="GeoAPI">GeographicCRS</code> and <code class="GeoAPI">ProjectedCRS</code>.
Tenth of ellipsoids are commonly used for datum definitions.
Some of them provide a very good approximation for a particular geographic area
at the expense of the rest of the world for which the datum was not designed.
Other datums are compromises applicable to the whole world.
</p>
<div class="example">
<p><b>Example:</b>
the <abbr>EPSG</abbr> geodetic dataset defines among others the “<abbr>WGS</abbr> 84”, “Clarke 1866”, “Clarke 1880”,
“<abbr>GRS</abbr> 1980” and “<abbr>GRS</abbr> 1980 Authalic Sphere” (a sphere of same surface than the <abbr>GRS</abbr> 1980 ellipsoid).
Ellipsoids may be used in various places of the world or may be defined for a very specific region.
For example in <abbr>USA</abbr> at the beginning of XX<sup>th</sup> century,
the Michigan state used an ellipsoid based on the “Clarke 1866” ellipsoid but with axis lengths expanded by 800 feet.
This modification aimed to take in account the average state height above mean sea level.</p>
</div>

<h3 id="GeodeticDatum"><span class="section-number">5.1.2.</span> Geodetic datum</h3>
<p>
For defining a geodetic system in a country, a national authority selects an ellipsoid matching closely the country surface.
Differences between that ellipsoid and the geoid’s hollows and bumps are usually less than 100 metres.
Parameters that relate an <code class="GeoAPI">Ellipsoid</code> to the Earth surface (for example the position of ellipsoid center)
are represented by instances of <code class="GeoAPI">GeodeticDatum</code>.
Many <code class="GeoAPI">GeodeticDatum</code> definitions can use the same <code class="GeoAPI">Ellipsoid</code>,
but with different orientations or center positions.
</p><p>
Before the satellite era, geodetic measurements were performed exclusively from Earth surface.
Consequently, two islands or continents not in range of sight from each other were not geodetically related.
So the <cite>North American Datum 1983</cite> (<abbr>NAD83</abbr>) and the <cite>European Datum 1950</cite> (<abbr>ED50</abbr>)
are independent: their ellipsoids have different sizes and are centered at a different positions.
The same geographic coordinate will map different locations on Earth depending on whether the coordinate
uses one reference system or the other.
</p><p>
The <abbr title="Global Positioning System">GPS</abbr> invention implied the creation of a
world geodetic system named <abbr title="World Geodetic System 1984">WGS84</abbr>.
The ellipsoid is then unique and centered at the Earth gravity center.
<abbr>GPS</abbr> provides at any moment the receptor absolute position on that world geodetic system.
But since <abbr>WGS84</abbr> is a world-wide system, it may differs significantly from local systems.
For example the difference between <abbr>WGS84</abbr> and the European system <abbr>ED50</abbr> is about 150 metres,
and the average difference between <abbr>WGS84</abbr> and the <cite>Réunion 1947</cite> system is 1.5 kilometres.
Consequently we shall not blindly use <abbr>GPS</abbr> coordinates on a map,
as transformations to the local system may be required.
Those transformations are represented in GeoAPI by instances of the <code class="GeoAPI">Transformation</code> interface.
</p><p>
The <abbr>WGS84</abbr> ubiquity tends to reduce the need for <code class="GeoAPI">Transformation</code> operations with recent data,
but does not eliminate it.
The Earth moves under the effect of plate tectonic and new systems are defined every years for taking that fact in account.
For example while <abbr>NAD83</abbr> was originally defined as practically equivalent to <abbr>WGS84</abbr>,
there is now (as of 2016) a 1.5 metres difference.
The <cite>Japanese Geodetic Datum 2000</cite> was also defined as practically equivalent to <abbr>WGS84</abbr>,
but the <cite>Japanese Geodetic Datum 2011</cite> now differs.
Even the <abbr>WGS84</abbr> datum, which was a terrestrial model realization at a specific time,
got revisions because of improvements in instruments accuracy.
Today, at least six <abbr>WGS84</abbr> versions exist.
Furthermore many borders were legally defined in legacy datums, for example <abbr>NAD27</abbr> in <abbr>USA</abbr>.
Updating data to the new datum would imply transforming some straight lines or simple geometric shapes
into more irregular shapes, if the shapes are large enough.
</p>

<h3 id="CoordinateSystem"><span class="section-number">5.1.3.</span> Coordinate systems</h3>
<p style="color: red">TODO</p>

<h4 id="AxisOrder"><span class="section-number">5.1.3.1.</span> Axis order</h4>
<p>
The axis order is specified by the authority (typically a national agency) defining the <cite>Coordinate Reference System</cite> (<abbr>CRS</abbr>).
The order depends on the <abbr>CRS</abbr> type and the country defining the <abbr>CRS</abbr>.
In the case of geographic <abbr>CRS</abbr>, the (<var>latitude</var>, <var>longitude</var>) axis order is widely used by geographers and pilots for centuries.
However software developers tend to consistently use the (<var>x</var>, <var>y</var>) order for every kind of <abbr>CRS</abbr>.
Those different practices resulted in contradictory definitions of axis order for almost every <abbr>CRS</abbr> of kind <code class="GeoAPI">GeographicCRS</code>,
for some <code class="GeoAPI">ProjectedCRS</code> in the South hemisphere (South Africa, Australia, <i>etc.</i>) and for some polar projections among others.
</p><p>
Recent <abbr title="Open Geospatial Consortium">OGC</abbr> standards mandate the use of axis order as defined by the authority.
Oldest <abbr>OGC</abbr> standards used the (<var>x</var>, <var>y</var>) axis order instead, ignoring any authority specification.
Many software products still use the old (<var>x</var>, <var>y</var>) axis order,
maybe because such uniformization makes <abbr>CRS</abbr> implementation and usage <em>apparently</em> easier.
Apache <abbr title="Spatial Information System">SIS</abbr> supports both conventions with the following approach:
by default, <abbr>SIS</abbr> creates <abbr>CRS</abbr> with axis order <em>as defined by the authority</em>.
Those <abbr>CRS</abbr> are created by calls to the <code>CRS.forCode(String)</code> method
and the actual axis order can be verified after the <abbr>CRS</abbr> creation with <code>System.out​.println(crs)</code>.
But if (<var>x</var>, <var>y</var>) axis order is wanted for compatibility with older <abbr>OGC</abbr> specifications or other software products,
then <abbr>CRS</abbr> forced to <cite>longitude first</cite> axis order can be created by a call to the following method:
</p>

<pre><code><code class="GeoAPI">CoordinateReferenceSystem</code> crs = …;               <code class="comment">// CRS obtained by any means.
</code>crs = AbstractCRS.castOrCopy(crs).forConvention(AxesConvention.RIGHT_HANDED)</code></pre>

<p>
Among the legacy <abbr>OGC</abbr> standards that used the non-conform axis order,
an influent one is version 1 of the <cite>Well Known Text</cite> (<abbr>WKT</abbr>) format specification.
According that widely-used format, <abbr>WKT</abbr> 1 definitions without explicit <code>AXIS[…]</code> elements
shall default to (<var>longitude</var>, <var>latitude</var>) or (<var>x</var>, <var>y</var>) axis order.
In version 2 of <abbr>WKT</abbr> format, <code>AXIS[…]</code> elements are no longer optional
and should contain an explicit <code>ORDER[…]</code> sub-element for making the intended order yet more obvious.
But if <code>AXIS[…]</code> elements are nevertheless missing in a <abbr>WKT</abbr> 2 definition,
Apache <abbr>SIS</abbr> defaults to (<var>latitude</var>, <var>longitude</var>) order.
So in summary:
</p>
<ul>
<li>Default <abbr>WKT</abbr> 1 axis order of geographic <abbr>CRS</abbr> is (<var>longitude</var>, <var>latitude</var>) as mandated by <abbr>OGC</abbr> 01-009 specification.</li>
<li>Default <abbr>WKT</abbr> 2 axis order of geographic <abbr>CRS</abbr> is (<var>latitude</var>, <var>longitude</var>),
but this is <abbr>SIS</abbr>-specific as <abbr title="International Organization for Standardization">ISO</abbr> 19162 does not mention default axis order.</li>
</ul>
<p>
To avoid ambiguities, users are encouraged to always provide explicit <code>AXIS[…]</code> elements in their <abbr>WKT</abbr>.
The <abbr>WKT</abbr> format will be presented in more details in the next sections.
</p>

<h3 id="GeographicCRS"><span class="section-number">5.1.4.</span> Geographic reference systems</h3>
<p style="color: red">TODO</p>

<h4 id="GeographicWKT"><span class="section-number">5.1.4.1.</span> <i>Well-Known Text</i> format</h4>
<p style="color: red">TODO</p>

<h3 id="ProjectedCRS"><span class="section-number">5.1.5.</span> Map projections</h3>
<p>
Map projections represent a curved surface (the Earth) on a plane surface (a map or a computer screen)
with some control over deformations: one can preserve either the angles or the areas, but not both in same time.
The geometric properties to preserve depend on the feature to represent and the work to do on that feature.
For example countries elongated along the East-West axis often use a Lambert projection,
while countries elongated along the North-South axis prefer a Transverse Mercator projection.
</p>
<p style="color: red">TODO</p>

<h4 id="ProjectedWKT"><span class="section-number">5.1.5.1.</span> <i>Well-Known Text</i> format</h4>
<p style="color: red">TODO</p>

<h3 id="CompoundCRS"><span class="section-number">5.1.6.</span> Vertical and temporal dimensions</h3>
<p style="color: red">TODO</p>

<h4 id="CompoundWKT"><span class="section-number">5.1.6.1.</span> <i>Well-Known Text</i> format</h4>
<p style="color: red">TODO</p>
</section>


<section>
<header>
<h2 id="GetCRS"><span class="section-number">5.2.</span> Fetching a spatial reference system</h2>
</header>
<p style="color: red">TODO</p>

<h3 id="CRSAuthorityFactory"><span class="section-number">5.2.1.</span> Looking <abbr>CRS</abbr> defined by authorities</h3>
<p style="color: red">TODO</p>

<h3 id="CRSParsing"><span class="section-number">5.2.2.</span> Reading definitions in GML or WKT format</h3>
<p style="color: red">TODO</p>

<h3 id="CRSFactory"><span class="section-number">5.2.3.</span> Constructing programmatically</h3>
<p style="color: red">TODO</p>

<h3 id="CRS_UserCode"><span class="section-number">5.2.4.</span> Adding new <abbr>CRS</abbr> definitions</h3>
<p style="color: red">TODO</p>
</section>


<section>
<header>
<h2 id="CoordinateOperations"><span class="section-number">5.3.</span> Coordinate operations</h2>
</header>
<p>
Given a <em>source</em> coordinate reference system (<abbr>CRS</abbr>) in which existing coordinate values are expressed,
and a <em>target</em> coordinate reference system in which coordinate values are desired,
Apache <abbr title="Spatial Information System">SIS</abbr> can provide a <em>coordinate operation</em> performing the conversion or transformation work.
The search for coordinate operations may use a third argument, optional but recommended,
which is the geographic area of the data to transform.
That later argument is recommended because coordinate operations are often valid only in a some geographic area
(typically a particular country or state), and many transformations may exist
for the same pair of source and target <abbr>CRS</abbr> but different domain of validity.
Different coordinate operations may also be different compromises between accuracy and their domain of validity,
and specifying a smaller area of interest may allow Apache <abbr>SIS</abbr> to select a more accurate operation.
</p>
<div class="example"><p><b>Example:</b>
the <abbr>EPSG</abbr> geodetic dataset (as of version 7.9) defines 77 coordinate operations from the
<cite>North American Datum 1927</cite> (EPSG:4267) coordinate reference system to the
<cite>World Geodetic System 1984</cite> (EPSG:4326) <abbr>CRS</abbr>.
There is one operation valid only for coordinate transformations in Québec,
another operation valid for coordinate transformations in Texas west of 100°W,
another operation for the same state but east of 100°W, <i>etc</i>.
If the user did not specified any geographic area of interest,
then Apache <abbr>SIS</abbr> defaults on the coordinate operation which is valid in the largest area.
In this example, the “largest area” criterion results in the selection of a coordinate operation valid for Canada,
not <abbr>USA</abbr>.</p>
</div>
<p>
The easiest way to obtain a coordinate operation from above-cited information
is to use the <code class="SIS">org.apache.sis.referencing.CRS</code> convenience class:
</p>

<pre><code><code class="GeoAPI">CoordinateOperation</code> cop = CRS.findOperation(sourceCRS, targetCRS, areaOfInterest);</code></pre>

<p>
Among the information provided by <code class="GeoAPI">CoordinateOperation</code> object, the following are of special interest:
</p>
<ul>
<li>The <cite>domain of validity</cite>, either as a textual description (e.g. “Canada – onshore and offshore”)
or with the coordinates of a geographic bounding box.</li>
<li>The <cite>positional accuracy</cite>, which may be anything from 1 centimetre to a few kilometres.</li>
<li>The coordinate operation subtype. Among them, two sub-types provide the same functionalities but with a significant conceptual difference:
<ul class="verbose">
<li>
Coordinate <strong>conversions</strong> are fully determined by mathematical formulas.
Those conversions would have an infinite precision if it was not for the unavoidable rounding errors
inherent to floating-point calculations.
Map projections are in this category.
</li><li>
Coordinate <strong>transformations</strong> are defined empirically.
They often have errors of a few metres which are not caused by limitation in computer accuracy.
Those errors exist because transformations are only approximations of a more complex reality.
Datum shifts from <abbr title="North American Datum 1927">NAD27</abbr> to <abbr title="North American Datum 1983">NAD83</abbr>
are in this category.
</li>
</ul>
</li>
</ul>
<p>
If the coordinate operation is an instance of <code class="GeoAPI">Transformation</code>,
then the instance selected by <abbr>SIS</abbr> may be one among many possibilities depending on the area of interest.
Furthermore its accuracy is certainly less than the centimetric accuracy that we can expect from a <code class="GeoAPI">Conversion</code>.
Consequently verifying the domain of validity and the positional accuracy declared in the transformation metadata is of particular importance.
</p>

<h3 id="MathTransform"><span class="section-number">5.3.1.</span> Executing an operation on coordinate values</h3>
<p>
The <code class="GeoAPI">CoordinateOperation</code> object introduced in above section provides high-level informations
(source and target <abbr>CRS</abbr>, domain of validity, positional accuracy, operation parameters, <i>etc</i>).
The actual mathematical work is performed by a separated object obtained by a call to <code class="GeoAPI">CoordinateOperation​.getMathTransform()</code>.
At the difference of <code class="GeoAPI">CoordinateOperation</code> instances, <code class="GeoAPI">MathTransform</code> instances do not carry any metadata.
They are kind of black box which know nothing about the source and target <abbr>CRS</abbr>
(actually the same <code class="GeoAPI">MathTransform</code> can be used for different pairs of <abbr>CRS</abbr> if the mathematical work is the same), domain or accuracy.
Furthermore <code class="GeoAPI">MathTransform</code> may be implemented in a very different way than what <code class="GeoAPI">CoordinateOperation</code> said.
In particular many conceptually different coordinate operations (e.g. longitude rotations,
change of units of measurement, conversions between two Mercator projections on the same datum, <i>etc.</i>)
are implemented by <code class="GeoAPI">MathTransform</code> as <a href="#AffineTransform">affine transforms</a> and concatenated for efficiency,
even if <code class="GeoAPI">CoordinateOperation</code> reports them as a chain of Mercator and other operations.
The “<a href="#CoordinateOperationSteps">conceptual versus real chain of coordinate operations</a>” section explains the differences in more details.
</p>
<p>
The following Java code performs a map projection from geographic coordinates on the <cite>World Geodetic System 1984</cite> (<abbr title="World Geodetic System 1984">WGS84</abbr>) datum
coordinates in the <cite>WGS 84 / UTM zone 33N</cite> coordinate reference system.
In order to make the example a little bit simpler, this code uses predefined constants given by the <code>CommonCRS</code> convenience class.
But more advanced applications will typically use <abbr>EPSG</abbr> codes instead.
Note that all geographic coordinates below express latitude before longitude.
</p>

<pre><code><b>import</b> org.opengis.geometry.<code class="GeoAPI">DirectPosition</code>;
<b>import</b> org.opengis.referencing.crs.<code class="GeoAPI">CoordinateReferenceSystem</code>;
<b>import</b> org.opengis.referencing.operation.<code class="GeoAPI">CoordinateOperation</code>;
<b>import</b> org.opengis.referencing.operation.<code class="GeoAPI">TransformException</code>;
<b>import</b> org.opengis.util.<code class="GeoAPI">FactoryException</code>;
<b>import</b> org.apache.sis.referencing.CRS;
<b>import</b> org.apache.sis.referencing.CommonCRS;
<b>import</b> org.apache.sis.geometry.DirectPosition2D;

<b>public</b> <b>class</b> MyApp {
    <b>public</b> <b>static</b> <b>void</b> main(String[] args) <b>throws</b> <code class="GeoAPI">FactoryException</code>, <code class="GeoAPI">TransformException</code> {
        <code class="GeoAPI">CoordinateReferenceSystem</code> sourceCRS = CommonCRS.WGS84.geographic();
        <code class="GeoAPI">CoordinateReferenceSystem</code> targetCRS = CommonCRS.WGS84.UTM(40, 14);  <code class="comment">// Get whatever zone is valid for 14°E.
</code>        <code class="GeoAPI">CoordinateOperation</code> operation = CRS.findOperation(sourceCRS, targetCRS, <b>null</b>);

        <code class="comment">// The above lines are costly and should be performed only once before to project many points.
</code>        <code class="comment">// In this example, the operation that we got is valid for coordinates in geographic area from
</code>        <code class="comment">// 12°E to 18°E (UTM zone 33) and 0°N to 84°N.
</code>
        <code class="GeoAPI">DirectPosition</code> ptSrc = <b>new</b> DirectPosition2D(40, 14);           <code class="comment">// 40°N 14°E
</code>        <code class="GeoAPI">DirectPosition</code> ptDst = operation.getMathTransform().transform(ptSrc, <b>null</b>);

        System.out.println(<i>"Source: "</i> + ptSrc);
        System.out.println(<i>"Target: "</i> + ptDst);
    }
}</code></pre>


<h3 id="TransformDerivative"><span class="section-number">5.3.2.</span> Partial derivatives of coordinate operations</h3>
<p>
Previous section shows how to project a coordinate from one reference system to another one.
There is another, less known, operation which does not compute the projected coordinates of a given point,
but instead the derivative of the projection function at that point.
This operation was defined in an older Open Geospatial specification,
<a href="http://www.opengeospatial.org/standards/ct">OGC 01-009</a>, now considered obsolete but still useful.
Let <var>P</var> be a map projection converting degrees of latitude and longitude (<var>φ</var>, <var>λ</var>)
into projected coordinates (<var>x</var>, <var>y</var>) in metres.
The formula below represents the map projection result as a column matrix
(reason will become clearer soon):
</p>

<table class="hidden">
<tr>
<th>Equation</th>
<th>Java code</th>
</tr>
<tr>
<td style="vertical-align:middle; min-width:350px; padding-right:60px">
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mi>P</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mtd></mtr>
<mtr><mtd><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mtd></mtr>
</mtable>
</mfenced>
</math>
</td>
<td style="vertical-align:middle; min-width:500px; padding-left:60px">

<pre style="margin:0"><code><code class="GeoAPI">DirectPosition</code> geographic = <b>new</b> DirectPosition2D(<var>φ</var>, <var>λ</var>);
<code class="GeoAPI">DirectPosition</code> projected = <var><b>P</b></var>.transform(geographic, <b>null</b>);
<b>double</b> <var>x</var> = projected.getOrdinate(0);
<b>double</b> <var>y</var> = projected.getOrdinate(1);</code></pre>

</td>
</tr>
</table>

<p>The map projection partial derivate at this point can be represented by a Jacobian matrix:</p>

<table class="hidden">
<tr>
<th>Equation</th>
<th>Java code</th>
</tr>
<tr>
<td style="vertical-align:middle; min-width:350px; padding-right:60px">
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<msup><mi>P</mi><mo>′</mo></msup><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo>
<mo>=</mo>
<msub><mi>JAC</mi><mrow><mi>P</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow></msub>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi><mo>(</mo><mi>φ</mi><mo>,</mo><mi>λ</mi><mo>)</mo></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</td>
<td style="vertical-align:middle; min-width:500px; padding-left:60px">

<pre style="margin:0"><code><code class="GeoAPI">DirectPosition</code> geographic = <b>new</b> DirectPosition2D(<var>φ</var>, <var>λ</var>);
<code class="GeoAPI">Matrix</code> jacobian = <var><b>P</b></var>.derivative(geographic);
<b>double</b> dx_dλ = jacobian.getElement(0,1);
<b>double</b> dy_dφ = jacobian.getElement(1,0);</code></pre>

</td>
</tr>
</table>

<p>
Remaining equations in this section will abridge
∂<var>x</var>(<var>λ</var>, <var>φ</var>) as ∂<var>x</var> and
∂<var>y</var>(<var>λ</var>, <var>φ</var>) as ∂<var>y</var>,
but reader should keep in mind that each of those derivative values depends on the (<var>λ</var>, <var>φ</var>) coordinate given at Jacobian matrix calculation time.
The first matrix column tells us that if we apply a small displacement of ∂<var>φ</var> degrees of latitude from the (<var>φ</var>, <var>λ</var>) position,
— in other words if we move at the (<var>φ</var> + ∂<var>φ</var>, <var>λ</var>) geographic position —
then the projected coordinate will be displaced by (∂<var>x</var>, ∂<var>λ</var>) metres
— in other words it will become (<var>x</var> + ∂<var>x</var>, <var>y</var> + ∂<var>λ</var>).
Similarly the last matrix column gives us the displacement that happen on the projected coordinate
if we apply a small displacement of ∂<var>λ</var> degrees of longitude on the source geographic coordinate.
We can visualize such displacements in a figure like below.
This figure shows the derivative at two points, <var>P</var><sub>1</sub> and <var>P</var><sub>2</sub>,
for emphasing that the result change for every points.
In that figure, vectors <var>U</var> et <var>V</var> stand for the first and second column respectively
in the Jacobian matrices.
</p>

<table class="hidden"><tr>
<td><img alt="Example of a map projection derivative" src="../images/Derivatives.png" style="border: solid 1px"/></td>
<td style="padding-left: 30px; vertical-align: middle">
<p>where vectors are related to the matrix by:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mtable><mtr>
<mtd>
<mover><mi>U</mi><mo>→</mo></mover><mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi></mrow><mrow><mo>∂</mo><mi>φ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</mtd>
<mtd><mtext>et</mtext></mtd>
<mtd>
<mover><mi>V</mi><mo>→</mo></mover><mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>x</mi></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
<mtr>
<mtd><mfrac><mrow><mo>∂</mo><mi>y</mi></mrow><mrow><mo>∂</mo><mi>λ</mi></mrow></mfrac></mtd>
</mtr>
</mtable>
</mfenced>
</mtd>
</mtr></mtable>
</math>
</td>
</tr></table>

<p>
Above figure shows one usage of map projection derivatives:
they provide the direction of parallels and meridians at a given location in a map projection.
One can use that information for determining if axes have been swapped or their direction reversed.
But the usefulness of map projection derivatives goes further.
</p>

<h4 id="DerivativeAndEnvelope"><span class="section-number">5.3.2.1.</span> Transform derivatives applied to envelopes</h4>
<p>
<span style="color: red">TODO</span>
</p>
<table class="hidden">
<tr>
<th>Envelope before projection</th>
<th>Geometric shape after projection</th>
</tr>
<tr>
<td><img alt="Envelope in a geographic CRS" src="../images/GeographicArea.png" style="border: solid 1px; margin-right: 15px"/></td>
<td><img alt="Shape in a projected CRS" src="../images/ConicArea.png" style="border: solid 1px; margin-left:  15px"/></td>
</tr>
</table>
<p>
<span style="color: red">TODO</span>
</p>
<table class="hidden"><tr><td>
<img alt="Cubic approximation of an envelope bounds" src="../images/Approximation.png"/>
</td><td style="padding-left: 60px">
Legend:
<ul>
<li><b>Blue:</b> the geometric shape of the envelope after projection.
This is the shape from which to get a new envelope.</li>
<li><b>Red</b> (with hash): The
<var>y</var> = <var>C</var>₀ + <var>C</var>₁λ + <var>C</var>₂λ² + <var>C</var>₃λ³ approximation.</li>
<li><b>Green</b> (dashed line): Position λ<sub>m</sub> of approximation minimum, obtained by resolving
0 = <var>C</var>₁ + 2<var>C</var>₂λ<sub>m</sub> + 3<var>C</var>₃λ<sub>m</sub>².
The same cubic line can have two minimums.</li>
</ul>
</td></tr></table>
<p>
<span style="color: red">TODO</span>
</p>


<h4 id="DerivativeAndRaster"><span class="section-number">5.3.2.2.</span> Transform derivatives applied to rasters</h4>
<p>
<span style="color: red">TODO</span>
</p>
<table class="hidden">
<tr>
<th style="text-align: left">Source image</th>
<th style="text-align: right">Destination image</th>
</tr>
<tr>
<td colspan="2"><img alt="Intersection of derivatives" src="../images/RasterProjection.png"/></td>
</tr>
</table>
<p>
<span style="color: red">TODO</span>
</p>
<table class="hidden"><tr>
<td><img alt="Intersection of derivatives" src="../images/WarpGrid.png"/></td>
<td style="padding-left: 60px">
Legend:
<ul>
<li><b>Blue dots:</b>  first  iteration (9 points).</li>
<li><b>Green dots:</b> second iteration (25 points, including 16 news).</li>
<li><b>Red dots:</b>   third  iteration (81 points, including 56 news).</li>
</ul>
Continuing…
<ul>
<li>Forth iteration:  289 points, including  208 news.</li>
<li>Fifth iteration: 1089 points, including  800 news.</li>
<li>Sixth iteration: 4225 points, including 3136 news.</li>
<li>…</li>
</ul>
</td></tr></table>
<p>
<span style="color: red">TODO</span>
</p>
<p style="text-align:center"><img alt="Intersection of derivatives" src="../images/IntersectionOfDerivatives.png" style="border: solid 1px"/></p>
<p>
<span style="color: red">TODO</span>
</p>

<h4 id="GetDerivative"><span class="section-number">5.3.2.3.</span> Getting the derivative at a point</h4>
<p>
<span style="color: red">TODO</span>
Example:</p>

<pre><code><code class="SIS">AbstractMathTransform</code> projection = ...;         <code class="comment">// An Apache SIS map projection.
</code><b>double</b>[] sourcePoint = {longitude, latitude};   <code class="comment">// The geographic coordinate to project.
</code><b>double</b>[] targetPoint = <b>new</b> <b>double</b>[2];           <code class="comment">// Where to store the projection result.
</code><code class="GeoAPI">Matrix</code>   derivative  = projection.<code class="SIS">transform</code>(sourcePoint, 0, targetPoint, 0, <b>true</b>);</code></pre>

<p>
<span style="color: red">TODO</span>
</p>

<pre><code>@Override
<b>public</b> <code class="GeoAPI">Matrix</code> derivative(<code class="GeoAPI">DirectPosition</code> p) <b>throws</b> <code class="GeoAPI">TransformException</code> {
    <code class="GeoAPI">Matrix</code> jac = inverse().derivative(transform(p));
    <b>return</b> Matrices.inverse(jac);
}</code></pre>


<h3 id="CoordinateOperationSteps"><span class="section-number">5.3.3.</span> Conceptual versus real chain of coordinate operations</h3>
<p>
Coordinate operations may include many steps, each with their own set of parameters.
For example transformations from one datum (e.g. <abbr title="North American Datum 1927">NAD27</abbr>) to another datum (e.g. <abbr title="World Geodetic System 1984">WGS84</abbr>)
can be approximated by an affine transform (translation, rotation and scale) applied on the <em>geocentric</em> coordinates.
This implies that the coordinates must be converted from <em>geographic</em> to geocentric domain before the affine transform,
then back to geographic domain after the affine transform.
The result is a three-steps process illustrated in the “Conceptual chain of operations” column of the example below.
However because that operation chain is very common, the <abbr>EPSG</abbr> geodetic dataset provides a shortcut
named “Geocentric translation <em>in geographic domain</em>”.
Using this operation, the conversion steps between geographic and geocentric <abbr>CRS</abbr> are implicit.
Consequently the datum shifts as specified by <abbr>EPSG</abbr> appears as if it was a single operation,
but this is not the real operation executed by Apache <abbr title="Spatial Information System">SIS</abbr>.
</p>

<div class="example"><p><b>Example:</b>
transformation of geographic coordinates from <abbr>NAD27</abbr> to <abbr>WGS84</abbr> in Canada
can be approximated by the <abbr>EPSG</abbr>:1172 coordinate operation.
This single <abbr>EPSG</abbr> operation is actually a chain of three operations in which two steps are implicit.
The operation as specified by <abbr>EPSG</abbr> is shown in the first column below.
The same operation with the two hidden steps made explicit is shown in the second column.
The last column shows the same operation as implemented by Apache <abbr>SIS</abbr> under the hood,
which contains additional operations discussed below.
For all columns, input coordinates of the first step and output coordinates of the last step
are (<var>latitude</var>, <var>longitude</var>) coordinates in degrees.
</p>
<div style="display:flex; padding-left:24px">
<div style="width:30%; padding-right:15px; border-right:1px solid">
<b>Operation specified by <abbr>EPSG</abbr>:</b>
<ol>
<li><b>Geocentric translation</b> in <em>geographic</em> domain
<ul>
<li>X-axis translation = -10 m</li>
<li>Y-axis translation = 158 m</li>
<li>Z-axis translation = 187 m</li>
</ul>
</li>
</ol>
Conversions between geographic and geocentric domains are implicit.
The semi-major and semi-minor axis lengths required for those conversions
are inferred from the source and target datum.
</div>
<div style="width:30%; padding-left:30px; padding-right:15px; border-right:1px solid">
<b>Conceptual chain of operations:</b>
<ol>
<li><b>Geographic to geocentric</b> conversion
<ul>
<li>Source semi-major = 6378206.4 m</li>
<li>Source semi-minor = 6356583.8 m</li>
</ul>
</li><li><b>Geocentric translation</b>
<ul>
<li>X-axis translation = -10 m</li>
<li>Y-axis translation = 158 m</li>
<li>Z-axis translation = 187 m</li>
</ul>
</li><li><b>Geocentric to geographic</b> conversion
<ul>
<li>Target semi-major = 6378137.0 m</li>
<li>Target semi-minor ≈ 6356752.3 m</li>
</ul>
</li>
</ol>
Axis order and units are implicitly defined by the source and target <abbr>CRS</abbr>.
It is implementation responsibility to perform any needed unit conversions and/or axis swapping.
</div>
<div style="width:30%; padding-left:30px">
<b>Operations actually performed by Apache <abbr>SIS</abbr>:</b>
<ol>
<li><b>Affine parametric</b> conversion
<ul>
<li>Scale factors (λ and φ) = 0</li>
<li>Shear factors (λ and φ) = π/180</li>
</ul>
</li><li>Ellipsoid (radians domain) to centric conversion
<ul>
<li>Eccentricity ≈ 0.08227</li>
</ul>
</li><li><b>Affine parametric transformation</b>
<ul>
<li>Scale factors (X, Y and Z) ≈ 1.00001088</li>
<li>X-axis translation ≈ -1.568 E-6</li>
<li>Y-axis translation ≈ 24.772 E-6</li>
<li>Z-axis translation ≈ 29.319 E-6</li>
</ul>
</li><li>Centric to ellipsoid (radians domain) conversion
<ul>
<li>Eccentricity ≈ 0.08182</li>
</ul>
</li><li><b>Affine parametric</b> conversion
<ul>
<li>Scale factors (λ and φ) = 0</li>
<li>Shear factors (λ and φ) = 180/π</li>
</ul>
</li>
</ol>
</div>
</div>
<p>
The operation chain actually performed by Apache <abbr>SIS</abbr> is very different than the conceptual operation chain
because the coordinate systems are not the same.
Except for the first and last ones, all Apache <abbr>SIS</abbr> steps work on right-handed coordinate systems
(as opposed to the left-handed coordinate system when <var>latitude</var> is before <var>longitude</var>),
with angular units in radians (instead than degrees) and
linear units relative to an ellipsoid of semi-major axis length of 1 (instead than Earth’s size).
Working in those coordinate systems requires additional steps for unit conversions and axes swapping
at the beginning and at the end of the chain.
Apache <abbr>SIS</abbr> uses <cite>affine parametric conversions</cite> for this purpose,
which allow to combine axes swapping and unit conversions in a single step
(see <a href="#AffineTransform">affine transform</a> for more information).
The reason why Apache <abbr>SIS</abbr> splits conceptual operations in such fine-grained operations
is to allow more efficient concatenations of operation steps.
This approach often allows cancellation of two consecutive affine transforms,
for example a conversion from radians to degrees (e.g. after a <cite>geocentric to ellipsoid</cite> conversion)
immediately followed by a conversion from degrees to radians (e.g. before a map projection).
Another example is the <cite>Affine parametric transformation</cite> step above,
which combines both the <cite>geocentric translation</cite> step
and a scale factor implied by the ellipsoid change.
</p>
</div>
<p>
All those operation chains can be viewed in <cite>Well Known Text</cite> (<abbr>WKT</abbr>) or pseudo-<abbr>WKT</abbr> format.
The simplest operation chain, as specified by the authority, is given directly by the
<code>String</code> representation of the <code class="GeoAPI">CoordinateOperation</code> instance.
This <abbr>WKT</abbr> 2 representation contains not only a description of operations with their parameter values,
but also additional information about the context in which the operation applies (the source and target <abbr>CRS</abbr>)
together with some metadata like the accuracy and domain of validity.
Some operation steps and parameters may be omitted if they can be inferred from the context.
</p>
<div class="example">
<div style="display:flex; padding-left:24px; padding-right:24px">
<div>
<p><b>Example:</b>
the <abbr>WKT</abbr> 2 representation on the right is for the same coordinate operation than the one used in previous example.
This representation can be obtained by a call to <code>System.out​.println(cop)</code>
where <code>cop</code> is a <code class="GeoAPI">CoordinateOperation</code> instance.
Some characteristics of this representation are:
</p>
<ul>
<li><p>The <code>SourceCRS</code> and <code>TargetCRS</code> elements determine axis order and units.
For this reason, axis swapping and unit conversions do not need to be represented in this <abbr>WKT</abbr>.</p></li>
<li><p>The “Geocentric translation in geographic domain” operation implies conversions between geographic and geocentric coordinate reference systems.
Ellipsoid semi-axis lengths are inferred from above <code>SourceCRS</code> and <code>TargetCRS</code> elements,
so they do not need to be specified in this <abbr>WKT</abbr>.</p></li>
<li><p>The operation accuracy (20 metres) is much greater than the numerical floating-point precision.
This kind of metadata could hardly be guessed from the mathematical function alone.</p></li>
</ul>
</div>
<div>

<pre><samp><code class="GeoAPI">CoordinateOperation</code>[<i>"NAD27 to WGS 84 (3)"</i>,
  SourceCRS[<span style="font-family:serif"><i>full CRS definition required here but omitted <b>for</b> brevity</i></span>],
  TargetCRS[<span style="font-family:serif"><i>full CRS definition required here but omitted <b>for</b> brevity</i></span>],
  Method[<i>"Geocentric translations (geog2D domain)"</i>],
    Parameter[<i>"X-axis translation"</i>, -10.0, Unit[<i>"metre"</i>, 1]],
    Parameter[<i>"Y-axis translation"</i>, 158.0, Unit[<i>"metre"</i>, 1]],
    Parameter[<i>"Z-axis translation"</i>, 187.0, Unit[<i>"metre"</i>, 1]],
  OperationAccuracy[20.0],
  Area[<i>"Canada - onshore and offshore"</i>],
  BBox[40.04, -141.01, 86.46, -47.74],
  Id[<i>"EPSG"</i>, 1172, <i>"8.9"</i>]]</samp></pre>

</div>
</div>
</div>
<p>
An operation chain closer to what Apache <abbr>SIS</abbr> really performs is given by the
<code>String</code> representation of the <code class="GeoAPI">MathTransform</code> instance.
In this <abbr>WKT</abbr> 1 representation, contextual information and metadata are lost;
a <code class="GeoAPI">MathTransform</code> is like a mathematical function with no knowledge about the meaning of the coordinates on which it operates.
Since contextual information are lost, implicit operations and parameters become explicit.
This representation is useful for debugging since any axis swapping operation (for example) become visible.
Apache <abbr>SIS</abbr> constructs this representation from the data structure in memory,
but convert them in a more convenient form for human, for example by converting radians to degrees.
</p>
<div class="example">
<div style="display:flex; padding-left:24px; padding-right:24px">
<div>
<p><b>Example:</b>
the <abbr>WKT</abbr> 1 representation on the right is for the same coordinate operation than the one used in previous example.
This representation can be obtained by a call to <code>System.out​.println(cop​.getMathTransform())</code>
where <code>cop</code> is a <code class="GeoAPI">CoordinateOperation</code> instance.
Some characteristics of this representation are:
</p>
<ul>
<li><p>Since there is not anymore (on intend) any information about source and target <abbr>CRS</abbr>,
axis swapping (if needed) and unit conversions must be performed explicitly.
This is the task of the first and last affine operations in this <abbr>WKT</abbr>.</p></li>
<li><p>The “Geocentric translation” operation is not anymore applied in the geographic domain, but in the geocentric domain.
Consequently conversions between geographic and geocentric coordinate reference systems must be made explicit.
Those explicit steps are also necessary for specifying the ellipsoid semi-axis lengths,
since they can not anymore by inferred for source and target <abbr>CRS</abbr>.</p></li>
<li><p>Conversions between geographic and geocentric coordinates are three-dimensional.
Consequently operations for increasing and reducing the number of dimensions are inserted.
By default the ellipsoidal height before conversion is set to zero.</p></li>
</ul>
</div>
<div>

<pre><samp>Concat_MT[
  Param_MT[<i>"Affine parametric transformation"</i>,
    Parameter[<span style="font-family:serif"><i>parameters performing axis swapping omitted <b>for</b> brevity</i></span>]],
  Inverse_MT[Param_MT[<i>"Geographic3D to 2D conversion"</i>]],
  Param_MT[<i>"Geographic/geocentric conversions"</i>,
    Parameter[<i>"semi_major"</i>, 6378206.4],
    Parameter[<i>"semi_minor"</i>, 6356583.8]],
  Param_MT[<i>"Geocentric translations (geocentric domain)"</i>,
    Parameter[<i>"X-axis translation"</i>, -10.0],
    Parameter[<i>"Y-axis translation"</i>, 158.0],
    Parameter[<i>"Z-axis translation"</i>, 187.0]],
  Param_MT[<i>"Geocentric_To_Ellipsoid"</i>,
    Parameter[<i>"semi_major"</i>, 6378137.0],
    Parameter[<i>"semi_minor"</i>, 6356752.314245179]],
  Param_MT[<i>"Geographic3D to 2D conversion"</i>],
  Param_MT[<i>"Affine parametric transformation"</i>,
    Parameter[<span style="font-family:serif"><i>parameters performing axis swapping omitted <b>for</b> brevity</i></span>]]]</samp></pre>

</div>
</div>
</div>
<p>
Finally, the raw operation chain can be view by a call to <code class="SIS">AbstractMathTransform​.toString(Convention.INTERNAL)</code>.
This pseudo-<abbr>WKT</abbr> representation shows exactly what Apache <abbr>SIS</abbr> does,
but is rarely used because difficult to read.
It may occasionally be useful for advanced debugging.
</p>
</section>
</section>


<section>
<header>
<h2 id="Formats"><span class="section-number">5.4.</span> Date storage formats</h2>
</header>
<p>
<span style="color: red">TODO</span>
</p>




<section>
<header>
<h2 id="XML-ISO"><span class="section-number">5.5.</span> Representing objects in <abbr>XML</abbr></h2>
</header>
<p>
Objects defined by <abbr title="Open Geospatial Consortium">OGC</abbr>/<abbr title="International Organization for Standardization">ISO</abbr> standards must be able to communicate with remote machines via the Internet,
using different software written in different languages.
Some of the better known formats include <abbr>WKT</abbr> (<i>Well-Known Text</i>) and <abbr>WKB</abbr> (<i>Well-Known Binary</i>).
But the most exhaustive and often referred format is <abbr>XML</abbr>,
to the point where the representation of <abbr>ISO</abbr> objects in this format is itself sometimes
the entire focus of an international standard.
Thus are metadata classes described in <abbr>ISO</abbr> 19115-1 standard (an abstract specification),
while the representation of these classes in <abbr>XML</abbr> is described in <abbr>ISO</abbr> 19115-3 and 19139 standards.
</p>
<p>
Different <abbr>OGC</abbr>/<abbr>ISO</abbr> standards do not always use the same strategy to express objects in <abbr>XML</abbr>.
<abbr>ISO</abbr> 19115-3 standard in particular uses a more verbose approach than other standards,
and will be the subject of its <a href="#XML-ISO-19115">own section</a>.
But most <abbr>XML</abbr> formats define supplementary types and attributes that are not part of the original abstract specifications.
These supplementary attributes are usually specific to <abbr>XML</abbr> and may not appear in the <abbr title="Application Programming Interface">API</abbr> of Apache <abbr title="Spatial Information System">SIS</abbr>.
However, some of these attributes, such as <code class="OGC">id</code>, <code class="OGC">uuid</code> and
<code>xlink:href</code>, remain accessible in the form of key-value pairs.
</p>
<p>
<abbr>XML</abbr> documents may use any prefixes,
but the following prefixes are commonly used.
They therefore appear by default in documents produced by Apache <abbr>SIS</abbr>.
These prefixes are defined in the <code class="SIS">org.apache.sis.xml.Namespaces</code> class.
</p>
<table>
<caption>Common <abbr>XML</abbr> namespace prefixes</caption>
<tr>
<th>Prefix</th>
<th>Namespace</th>
</tr>
<tr>
<td><code class="OGC">gco</code></td>
<td><code>http://www.isotc211.org/2005/gco</code></td>
</tr>
<tr>
<td><code class="OGC">gfc</code></td>
<td><code>http://www.isotc211.org/2005/gfc</code></td>
</tr>
<tr>
<td><code class="OGC">gmd</code></td>
<td><code>http://www.isotc211.org/2005/gmd</code></td>
</tr>
<tr>
<td><code class="OGC">gmi</code></td>
<td><code>http://www.isotc211.org/2005/gmi</code></td>
</tr>
<tr>
<td><code class="OGC">gmx</code></td>
<td><code>http://www.isotc211.org/2005/gmx</code></td>
</tr>
<tr>
<td><code class="OGC">gml</code></td>
<td><code>http://www.opengis.net/gml/3.2</code></td>
</tr>
<tr>
<td><code>xlink</code></td>
<td><code>http://www.w3.org/1999/xlink</code></td>
</tr>
</table>

<aside>
<h2>Tools for reading and writing <abbr>XML</abbr> documents</h2>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> uses different libraries to read and write different types of objects.
The library used depends on the complexity of the object and on performance constraints.
For example, <abbr title="Java Architecture for XML Binding">JAXB</abbr> annotations have the advantage of being close to code,
which makes it easier to maintain mapping between Java and <abbr>XML</abbr>.
On the other hand, <abbr title="Simple API for XML">SAX</abbr> is more efficient.
In general, Apache <abbr>SIS</abbr> uses:
</p>
<ul>
<li>
<abbr>JAXB</abbr> for objects that do not occur very often in <abbr>XML</abbr> documents, but with complex structures and deep hierarchies.
The metadata set in <abbr title="International Organization for Standardization">ISO</abbr> 19115-3 standard is a typical example
</li>
<li>
<abbr>SAX</abbr> for objects that are relatively simple, but which may exist in very large numbers.
The set of points in a geometry is a typical example.
</li>
<li>
<abbr title="Document Object Model">DOM</abbr> as an alternative to <abbr>JAXB</abbr>
when the <abbr>XML</abbr> elements do not correspond exactly to Java attributes.
<i>Features</i> are an example, as their structure is dynamic.
</li>
</ul>
</aside>




<section>
<header>
<h3 id="XML-ISO-19115"><span class="section-number">5.5.1.</span> Representing metadata according to <abbr title="International Organization for Standardization">ISO</abbr> 19115-3</h3>
</header>
<p>
For each metadata class, there is an <abbr>XML</abbr> type with the same name than in the abstract specification
(for example, <code class="OGC">gmd:MD_Metadata</code> and <code class="OGC">gmd:CI_Citation</code>).
All of these types may be used as the root of an <abbr>XML</abbr> document.
It is therefore possible to write a document representing a complete <code class="OGC">MD_Metadata</code> object,
or to write a document representing only a <code class="OGC">CI_Citation</code> object.
</p>
<p>
<abbr>ISO</abbr> 19115-3 standard arranges the content of these objects in an unusual way:
for each property whose value type is itself another class of <abbr>ISO</abbr> 19115,
the value is wrapped in an element that represents its type, rather than being written directly.
For example, in an object of the <code class="OGC">CI_Citation</code> type,
the value of the <code class="OGC">citedResponsibleParty</code> property is incorporated
into a <code class="OGC">CI_Responsibility</code> element.
This practice doubles the depth of the hierarchy, and introduces duplication at all levels for each value,
as in the following example:
</p>

<pre><samp class="xml"><b>&lt;MD_Metadata&gt;</b>
  &lt;identificationInfo&gt;
    <b>&lt;MD_DataIdentification&gt;</b>
      &lt;citation&gt;
        <b>&lt;CI_Citation&gt;</b>
          &lt;citedResponsibleParty&gt;
            <b>&lt;CI_Responsibility&gt;</b>
              &lt;party&gt;
                <b>&lt;CI_Party&gt;</b>
                  &lt;contactInfo&gt;
                    <b>&lt;CI_Contact&gt;</b>
                      &lt;onlineResource&gt;
                        <b>&lt;CI_OnlineResource&gt;</b>
                          &lt;linkage&gt;
                            &lt;URL&gt;http://www.opengeospatial.org&lt;/URL&gt;
                          &lt;/linkage&gt;
                        <b>&lt;/CI_OnlineResource&gt;</b>
                      &lt;/onlineResource&gt;
                    <b>&lt;/CI_Contact&gt;</b>
                  &lt;/contactInfo&gt;
                <b>&lt;/CI_Party&gt;</b>
              &lt;/party&gt;
            <b>&lt;/CI_Responsibility&gt;</b>
          &lt;/citedResponsibleParty&gt;
        <b>&lt;/CI_Citation&gt;</b>
      &lt;/citation&gt;
    <b>&lt;/MD_DataIdentification&gt;</b>
  &lt;/identificationInfo&gt;
<b>&lt;/MD_Metadata&gt;</b></samp></pre>

<p>
The preceding example, like all documents that conform to <abbr>ISO</abbr> 19115-3,
consists of a systematic alternation of two types of <abbr>XML</abbr> elements:
</p>
<ol>
<li><p>
It begins with the name of the property, which always begins with a lower-case letter (ignoring prefixes).
In Java <abbr title="Application Programming Interface">API</abbr>s, each property corresponds to a method in its enclosing class.
In the example above, <code class="OGC">gmd:identificationInfo</code>  (a property of <code class="OGC">MD_Metadata</code> class)
corresponds to the <code class="GeoAPI">Metadata​.getIdentificationInfo()</code> method.
</p></li>
<li><p>
The value type is included under each property, unless it has been replaced with a reference
(the following <a href="#gco-id">sub-section</a> will elaborate on this subject).
The value type is an <abbr>XML</abbr> element whose name always begins with an upper-case letter,
ignoring prefixes.
In the example above we had <code class="OGC">MD_DataIdentification</code>,
which corresponds to the <code class="GeoAPI">DataIdentification</code> Java interface.
It is this <abbr>XML</abbr> element that contains the child properties.
</p></li>
</ol>

<p>
In order to reduce the complexity of the libraries, GeoAPI and Apache <abbr title="Spatial Information System">SIS</abbr>
only expose publicly a single unified view of these two types of elements.
The public <abbr>API</abbr> basically corresponds to the second group.
However, when writing an <abbr>XML</abbr> document, elements of the first group must be temporarily recreated.
The corresponding classes are defined in internal <abbr>SIS</abbr> packages.
These classes may be ignored, unless the developer wishes to implement his or her own classes whose instances must be written in <abbr title="Java Architecture for XML Binding">JAXB</abbr>.
</p>

<aside id="XML-SIS">
<h3>Implementation strategy in Apache <abbr title="Spatial Information System">SIS</abbr></h3>
<p>
<code class="SIS">org.apache.sis.internal.jaxb.*</code> packages (non-public) define <abbr title="Java Architecture for XML Binding">JAXB</abbr> adaptors for all types of <abbr title="International Organization for Standardization">ISO</abbr> objects.
These adaptors are required anyway to allow <abbr>JAXB</abbr> to get <abbr>SIS</abbr> classes while implementing GeoAPI interfaces.
Conveniently, <abbr>SIS</abbr> made both <abbr>JAXB</abbr> adaptors and objects wrapping the “real” object to be read or written.
This double usage avoids having to double the number of classes (already quite high) present in the internal packages.
</p>
<h4>Naming conventions in <abbr title="XML Schema Definition">XSD</abbr> schemas</h4>
<p>
For each element of the first group listed above, the <abbr>XSD</abbr> schemas of the <abbr title="Open Geospatial Consortium">OGC</abbr>
define a type whose name ends with “<code class="OGC">_PropertyType</code>”.
For the second group, each element has a type whose name ends with “<code class="OGC">_Type</code>”.
The “<code class="OGC">_PropertyType</code>” elements may have a group of attributes
(such as <code class="OGC">gco:uuidref</code> and <code>xlink:href</code>)
which the <abbr>XSD</abbr> schemas collectively name <code class="OGC">gco:ObjectIdentification</code>.
These attributes do not have dedicated Java methods, but are accessible indirectly via the
<code class="SIS">IdentifiedObject</code> interface described in the following subsection.
</p>
</aside>


<h4 id="gco-id"><span class="section-number">5.5.1.1.</span> Identification of already-defined instances</h4>
<p>
The parent element may contain an <code class="OGC">id</code> or <code class="OGC">uuid</code> attribute.
If one of these attributes is present, the parent attribute may be completely omitted;
it will be replaced at the time of reading by the element referenced by the attribute.
In the following example, the part on the left defines an element associated with the identifier “<code>my_id</code>,”
while the part on the right references this element:
</p>

<table class="hidden">
<tr>
<th>Defining an Identifier</th>
<th>Using a Defined Identifier</th>
</tr>
<tr>
<td>

<pre style="margin-top: 6pt"><samp class="xml">&lt;MD_MetaData&gt;
  &lt;identificationInfo&gt;
    &lt;MD_DataIdentification id=<i>"<b>my_id</b>"</i>&gt;
      <code class="comment">&lt;!-- insert child properties here --&gt;</code>
    &lt;/MD_DataIdentification&gt;
  &lt;/identificationInfo&gt;
&lt;/MD_MetaData&gt;</samp></pre>

</td><td>

<pre style="margin-top: 6pt"><samp class="xml">&lt;MD_MetaData&gt;
  &lt;identificationInfo xlink:href=<i>"<b>#my_id</b>"</i>/&gt;
&lt;/MD_MetaData&gt;</samp></pre>

</td>
</tr>
</table>

<p>
The decision of which attribute to use depends on the scope of the referenced item:
</p>
<ul>
<li>
<code class="OGC">id</code> is only valid in the same <abbr>XML</abbr> document that defines the object it references.
</li>
<li>
<code class="OGC">uuid</code> may be valid outside the <abbr>XML</abbr> document,
but someone must maintain a database providing the objects for each given UUID.
</li>
<li>
<code>xlink:href</code> may reference another <abbr>XML</abbr> document accessible on the Internet.
</li>
</ul>
<p>
In the <abbr title="Spatial Information System">SIS</abbr> library, all objects that can be identified in an <abbr>XML</abbr> document
implements the <code class="SIS">org.apache.sis.xml.IdentifiedObject</code> interface.
Each instance of this interface provides a view of its identifiers in the form of a <code>Map&lt;Citation,String&gt;</code>,
in which the <code class="GeoAPI">Citation</code> key indicates the type of identifier and the value is the identifier itself.
Some constants representing different types of identifiers are listed in <code class="SIS">IdentifierSpace</code>,
including <code class="SIS">ID</code>, <code class="SIS">UUID</code> and <code class="SIS">HREF</code>.
Each of these keys may be associated with a different type of value (usually <code>String</code>,
<code>UUID</code> or <code>URI</code>) depending on the key.
For example, the following code defines a value for the <code class="OGC">uuid</code> attribute:
</p>

<pre><code><b>import</b> org.apache.sis.metadata.iso.<code class="SIS">DefaultMetadata</code>;
<b>import</b> org.apache.sis.xml.<code class="SIS">IdentifierSpace</code>;
<b>import</b> java.util.UUID;

<b>public</b> <b>class</b> MyClass {
    <b>public</b> <b>void</b> myMethod() {
        UUID identifier = UUID.randomUUID();
        <code class="SIS"><code class="SIS">DefaultMetadata</code></code> metadata = <b>new</b> <code class="SIS"><code class="SIS">DefaultMetadata</code></code>();
        metadata.<code class="SIS">getIdentifierMap().putSpecialized</code>(<code class="SIS">IdentifierSpace</code>.UUID, identifier);
    }
}</code></pre>

<p>
Although this mechanism has been defined in order to better support the representation of <abbr>XML</abbr> attributes
of the <code class="OGC">gco:ObjectIdentification</code> group,
it also conveniently allows other types of identifiers to be manipulated.
For example, the <code class="GeoAPI">ISBN</code> and <code class="GeoAPI">ISSN</code> attributes of
<code class="GeoAPI">Citation</code> may be manipulated in this way.
The methods of the <code class="SIS">IdentifiedObject</code> interface therefore provides a specific location
where all types of identifiers (not only <abbr>XML</abbr>) associated with an object may be manipulated.
</p>



<h4 id="nilReason"><span class="section-number">5.5.1.2.</span> Representing missing values</h4>
<p>
When a property is not defined, the corresponding GeoAPI method usually returns <code>null</code>.
However, things become complicated when the missing property is a value considered mandatory by <abbr title="International Organization for Standardization">ISO</abbr> 19115 standard.
<abbr>ISO</abbr> 19115-3 allows for the omission of mandatory properties so long as the reason for the missing value is indicated.
The reason may be that the property is not applicable (<code class="OGC">inapplicable</code>),
that the value probably exists but is not known (<code class="OGC">unknown</code>),
that the value cannot exist (<code class="OGC">missing</code>),
or that the value cannot be revealed (<code class="OGC">withheld</code>), <i>etc.</i>
The transmission of this information requires the use of a non-nul object, even when the value is missing.
<abbr title="Spatial Information System">SIS</abbr> will then return an object that, besides implementing the desired GeoAPI interface,
also implements the <code class="SIS">org.apache.sis.xml.NilObject</code> interface.
This interface flags the instances where all methods return an empty collection, an empty table, <code>null</code>,
<code>NaN</code>, <code>0</code> or <code>false</code>, in this preference order, as permitted by the return types of the methods.
Each instance that implements <code class="SIS">NilObject</code> provides a <code class="SIS">getNilReason()</code> method
indicating why the object is nil.
</p>
<p>
In the following example, the left side shows a <code class="OGC">CI_Citation</code> element containing a
<code class="OGC">CI_Series</code> element, while on the right side the series is unknown.
If the <code class="OGC">CI_Series</code> element had been completely omitted,
then the <code class="GeoAPI">Citation​.getSeries()</code> method would return <code>null</code> in Java.
But when a <code class="OGC">nilReason</code> is present, the <abbr>SIS</abbr> implementation of
<code class="SIS">getSeries()</code> returns instead an object that implements both the
<code class="GeoAPI">Series</code> and <code class="SIS">NilReason</code> interfaces, and in which the
<code class="SIS">getNilReason()</code> method returns the constant <code class="SIS">UNKNOWN</code>.
</p>

<table class="hidden">
<tr>
<th>Information Included</th>
<th>Missing Information</th>
</tr>
<tr>
<td>

<pre style="margin-top: 6pt"><samp class="xml">&lt;CI_Citation&gt;
  &lt;series&gt;
    &lt;CI_Series&gt;
      <code class="comment">&lt;!-- insert child properties here --&gt;</code>
    &lt;/CI_Series&gt;
  &lt;/series&gt;
&lt;/CI_Citation&gt;</samp></pre>

</td><td>

<pre style="margin-top: 6pt"><samp class="xml">&lt;CI_Citation&gt;
  &lt;series nilReason=<i>"unknown"</i>/&gt;
&lt;/CI_Citation&gt;</samp></pre>

</td>
</tr>
</table>
</section>
</section>
</section>


<section>
<header>
<h1 id="Utilities"><span class="section-number">6.</span> Utility classes and methods</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Referencing">Previous chapter</a></div><div class="next-chapter"><a href="#GeoAPI-details">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#ComparisonModes">Comparison modes of objects</a></li>
<li><a href="#ObjectConverters">Object converters</a></li>
<li><a href="#Internationalization">Internationalization</a><ul>
<li><a href="#LocalizedString">Distinct character sequences for each locale</a></li>
<li><a href="#InternationalString">Single instance for all supported locales</a></li>
<li><a href="#Locale.ROOT">Locale.ROOT convention</a></li>
<li><a href="#UnicodePoint">Treatment of characters</a><ul>
<li><a href="#Whitespaces">Blank spaces interpretation</a></li></ul></li></ul></li></ul></nav>
<p>
This chapter describes aspects of Apache <abbr title="Spatial Information System">SIS</abbr> that apply to the entire library.
Most of these utilities are not specific to spatial information systems.
</p>






<section>
<header>
<h2 id="ComparisonModes"><span class="section-number">6.1.</span> Comparison modes of objects</h2>
</header>
<p>
There are various opinions on how to implement Java standard’s <code>Object​.equals(Object)</code> method.
According to some, it should be possible to compare different implementations of the same interface or base class.
But to follow this policy, each interface or base class’s javadoc must define the algorithms that all implementations
shall use for their <code>equals(Object)</code> and <code>hashCode()</code> methods.
This approach is common in <code>java.util.Collection</code> and its child interfaces.
Transferring this approach to certain GeoAPI interfaces, however, would be a difficult task,
and would probably not be followed in many implementations.
Moreover, it comes at the expense of being able to take into account supplementary attributes in the child interfaces,
unless this possibility has been specified in the parent interface.
This constraint arises from the following points of the <code>equals(Object)</code> and <code>hashCode()</code> method contracts:
</p>
<ul>
<li><code>A.equals(B)</code> implies <code>B.equals(A)</code> (symmetry);</li>
<li><code>A.equals(B)</code> and <code>B.equals(C)</code> implies <code>A.equals(C)</code> (transitivity);</li>
<li><code>A.equals(B)</code> implies <code>A.hashCode() == B.hashCode()</code>.</li>
</ul>
<p>
For example, these three constraints are violated if <var>A</var> (and eventually <var>C</var>) can contain attributes
which <var>B</var> ignores.
To bypass this problem, an alternative approach is to require that the objects compared by the
<code>Object​.equals(Object)</code> method be of the same class; in other words, <code>A.getClass() == B.getClass()</code>.
This approach is sometimes regarded as contrary to the principles of object oriented programming.
In practice, for relatively complex applications, the important accorded to these principles depends on the context
in which the objects are compared:
if the objects are added to a <code>HashSet</code> or used as keys in a <code>HashMap</code>,
we would need a stricter adherence to the <code>equals(Object)</code> and <code>hashCode()</code> contract.
But if the developer is comparing the objects his- or herself, for example to check that the relevant information has been changed,
then the constraints of symmetry, transitivity or coherence with the hash values may be of little interest.
More permissive comparisons may be desirable, sometimes going so far as to tolerate minor discrepancies in numerical values.
</p>
<p>
In order to allow developers a certain amount of flexibility, many classes in the <abbr title="Spatial Information System">SIS</abbr>
library implement the <code class="SIS">org.apache.sis.util.LenientComparable</code> interface,
which defines a <code class="SIS">equals(Object, ComparisonMode)</code> method.
The principle modes of comparison are:
</p>
<ul>
<li><p>
<b><code class="SIS">STRICT</code></b> — The objects compared must share the same class and have exactly equal attributes,
including any possible public attributes specific to the implementation.
</p></li>
<li><p>
<b><code class="SIS">BY_CONTRACT</code></b> — The objects compared must implement the same GeoAPI (or other standard)
interface, but need not be of the same implementation class.
Only the attributes defined in the interface are compared;
all other attributes specific to the implementation — even if they are public — are ignored.
</p></li>
<li><p>
<b><code class="SIS">IGNORE_METADATA</code></b> — Like <code class="SIS">BY_CONTRACT</code>,
but only compares attributes that influence the operations (numeric calculations or otherwise) performed by the object.
For example, in a geodesic datum, the longitude (in relation to Greenwich) of the original meridian
would be taken into account, while the name of the meridian would be ignored.
</p></li>
<li><p>
<b><code class="SIS">APPROXIMATIVE</code></b> — Like <code class="SIS">IGNORE_METADATA</code>,
but tolerates minor discrepancies in numerical values.
</p></li>
</ul>
<p>
The default mode, used in all <code>equals(Object)</code> methods in <abbr>SIS</abbr>,
is <code class="SIS">STRICT</code>. This mode is chosen for a safe operation — particularly with <code>HashMap</code> —
without the need to rigorously define <code>equals(Object)</code> and <code>hashCode()</code> operations in every interface.
With this mode, the order of objects (<code>A.equals(B)</code> or <code>B.equals(A)</code>) is unimportant.
It is, however, the only mode that offers this guarantee.
In the expression <code>A.equals(B)</code>, the <code class="SIS">BY_CONTRACT</code> mode
(and so by extension all other modes that depend on it) only compares the properties known to <code>A</code>,
regardless of whether <code>B</code> knows more.
</p>
</section>


<section>
<header>
<h2 id="ObjectConverters"><span class="section-number">6.2.</span> Object converters</h2>
</header>
<p>
There is sometime a need to convert instances from a <var>source</var> Java type to a <var>target</var> Java type
while those types are unknown at compile time.
Various projects (Apache Common Convert, Spring, <i>etc.</i>)
have created their own interface for performing object conversions between types known only at runtime.
Details vary, but such interfaces typically look like below:
</p>

<pre><code><b>interface</b> ObjectConverter&lt;S,T&gt; {   <code class="comment">// Some projects use only "Converter" as interface name.
</code>    T apply(S object);             <code class="comment">// Another method name commonly found in other projects is "convert".
</code>}</code></pre>

<p>
Like other projects, Apache <abbr title="Spatial Information System">SIS</abbr> also defines its own <code>ObjectConverter</code> interface.
The main difference between <abbr>SIS</abbr> converter interface and the interfaces found in other projects
is that <abbr>SIS</abbr> converters provide some information about their mathematical properties.
An Apache <abbr>SIS</abbr> converter can have zero, one or many of the following properties:
</p>
<dl>
<dt><dfn>Injective</dfn></dt>
<dd>A function is injective if no pair of <var>S</var> values can produce the same <var>T</var> value.
<div class="example"><p><b>Example:</b>
the <code>Integer</code> → <code>String</code> conversion performed by <code>Integer​.toString()</code>
is an <cite>injective</cite> function because if two <code>Integer</code> values are not equal,
then it is guaranteed that their conversions will result in different <code>String</code> values.
However the <code>String</code> → <code>Integer</code> conversion performed by <code>Integer​.valueOf(String)</code>
is <strong>not</strong> an injective function
because many distinct <code>String</code> values can be converted to the same <code>Integer</code> value.
For example converting the "42", "+42" and "0042" character strings all result in the same 42 integer value.
</p></div>
</dd>

<dt><dfn>Surjective</dfn></dt>
<dd>A function is surjective if each values of <var>T</var> can be created from at least one value of <var>S</var>.
<div class="example"><p><b>Example:</b>
the <code>String</code> → <code>Integer</code> conversion performed by <code>Integer​.valueOf(String)</code>
is a <cite>surjective</cite> function because every <code>Integer</code> value can be created from at least one <code>String</code> value.
However the <code>Integer</code> → <code>String</code> conversion performed by <code>Integer​.toString()</code>
is <strong>not</strong> a surjective function because it can not produce all possible <code>String</code> values.
For example there is no way to produce the "ABC" value with the <code>Integer​.toString()</code> method.
</p></div>
</dd>

<dt><dfn>Bijective</dfn></dt>
<dd>A function is bijective if there is a one-to-one relationship between <var>S</var> and <var>T</var> values.
<div class="example"><p><b>Note:</b>
the <cite>bijective</cite> property is defined here for clarity, but actually does not have an explicit item
in Apache <abbr>SIS</abbr> <code>FunctionProperty</code> enumeration.
It is not necessary since a function that is both <cite>injective</cite> and <cite>surjective</cite> is necessarily bijective.
</p></div>
</dd>

<dt><dfn>Order preserving</dfn></dt>
<dd>A function is order preserving if any sequence of increasing <var>S</var> values is mapped to a sequence of increasing <var>T</var> values.
<div class="example"><p><b>Example:</b>
conversion from <code>Integer</code> to <code>Long</code> preserve the natural ordering of elements.
However conversions from <code>Integer</code> to <code>String</code> do <strong>not</strong> preserve natural ordering,
because some sequences of increasing integer values are ordered differently when their string representations are sorted by lexicographic order.
For example 1, 2, 10 become "1", "10", "2".
</p></div>
</dd>

<dt><dfn>Order reversing</dfn></dt>
<dd>A function is order reversing if any sequence of increasing <var>S</var> values is mapped to a sequence of decreasing <var>T</var> values.
<div class="example"><p><b>Example:</b>
a conversion that reverses the sign of numbers.
</p></div>
</dd>
</dl>
<p>
Above information may seem unnecessary when values are converted without taking in account the context in which the values appear.
But when the value to convert is part of a bigger object, then above information can affect the way the converted value will be used.
For example conversion of a [<var>min</var> … <var>max</var>] range is straightforward when the converter is <cite>order preserving</cite>.
But if the converter is <cite>order reversing</cite>, then the minimum and maximum values need to be interchanged.
For example if the converter reverses the sign of values, then the converted range is [-<var>max</var> … -<var>min</var>].
If the converter is neither order preserving or order reversing, then range conversion is not allowed at all
(because it does not contain the same set of values) even if the minimum and maximum values could be converted individually.
</p>
</section>


<section>
<header>
<h2 id="Internationalization"><span class="section-number">6.3.</span> Internationalization</h2>
</header>
<p>
In an architecture where a program executed on a server provides its data to multiple clients,
the server’s locale conventions are not necessarily the same as those of the clients.
Conventions may differ in language, but also in the way they write numeric values
(even between two countries that speak the same language) as well in time zone.
To produce messages that conform to the client’s conventions, <abbr title="Spatial Information System">SIS</abbr> uses
two approaches, distinguished by their level of granularity: at the level of the messages themselves,
or at the level of the objects that create the messages.
The approach used also determines whether it is possible to share the same instance of an object for all languages.
</p>

<h3 id="LocalizedString"><span class="section-number">6.3.1.</span> Distinct character sequences for each locale</h3>
<p>
Some classes are only designed to function according to one locale convention at a time.
This is of course true for the standard implementations of <code>java.text.Format</code>,
as they are entirely dedicated to the work of internationalization.
But it is also the case for other less obvious classes like <code>javax.imageio.ImageReader</code> and <code>ImageWriter</code>.
When one of these classes is implemented by <abbr title="Spatial Information System">SIS</abbr>,
we identify it by implementing the <code class="SIS">org.apache.sis.util.Localized</code> interface.
The <code class="SIS">getLocale()</code> method of this interface can determine the locale conventions
by which the instance produces its message.
</p>
<p>
Another class that provides different methods for different locales is <code>java.lang.Throwable</code>.
The standard Java <abbr title="Application Programming Interface">API</abbr> defines two methods for getting the error message:
<code>getMessage()</code> and <code>getLocalizedMessage()</code>.
Usually those two methods return the same character sequences,
but some exceptions thrown by Apache <abbr>SIS</abbr> may use different locales.
The policy that <abbr>SIS</abbr> tries to apply on a <em>best-effort</em> basis is:
</p>
<ul>
<li><code>getMessage()</code> returns the message in the <abbr title="Java Virtual Machine">JVM</abbr> default locale.
In a client-server architecture, this is often the locale on the server side.
This is the recommended language for logging messages to be read by system administrators.</li>
<li><code>getLocalizedMessage()</code> returns the message in a locale that depends on the context
in which the exception has been thrown. This is often the locale used by a particular <code class="GeoAPI">Format</code>
or <code class="SIS">DataStore</code> instance, and can be presumed to be the locale on the client side.
This is the recommended language to show in the user application.</li>
</ul>

<div class="example"><p><b>Example:</b>
If an error occurred while a Japanese client connected to an European server, the localized message may be sent
to the client in Japanese language as given by <code>getLocalizedMessage()</code> while the same error may be
logged on the server side in the French (for example) language as given by <code>getMessage()</code>.
This allows system administrator to analyze the issue without the need to understand client’s language.
</p></div>
<p>
The utility class <code class="SIS">org.apache.sis.util.Exceptions</code> provides convenience methods to get messages
according to the conventions of a given locale, when this information is available.
</p>



<h3 id="InternationalString"><span class="section-number">6.3.2.</span> Single instance for all supported locales</h3>
<p>
The <abbr title="Application Programming Interface">API</abbr> conventions defined by <abbr title="Spatial Information System">SIS</abbr> or inherited by GeoAPI favour the use of the
<code class="GeoAPI">InternationalString</code> type when the value of a <code>String</code> type would likely be localized.
This approach allows us to defer the internationalization process to the time when a character sequence is requested,
rather than the time when the object that contains them is created.
This is particularly useful for immutable classes used for creating unique instances independently of locale conventions.
</p>
<div class="example"><p><b>Example:</b>
<abbr>SIS</abbr> includes only one instance of the <code class="GeoAPI">OperationMethod</code>
type representing the Mercator projection, regardless of the client’s language.
But its <code class="GeoAPI">getName()</code> method (indirectly) provides an instance of
<code class="GeoAPI">InternationalString</code>, so that <code>toString(Locale.ENGLISH)</code> returns <cite>Mercator projection</cite>
while <code>toString(Locale.FRENCH)</code> returns <cite>Projection de Mercator</cite>.
</p></div>
<p>
When defining spatial objects independently of locale conventions, we reduce the risk of computational overload.
For example, it is easier to detect that two maps use the same cartographic projection if this last is represented by the
same instance of <code class="GeoAPI">CoordinateOperation</code>,
even if the projection has a different name depending on the country.
Moreover, certain types of <code class="GeoAPI">CoordinateOperation</code> may require coordinate transformation matrices,
so sharing a single instance becomes even more preferable in order to reduce memory consumption.
</p>



<h3 id="Locale.ROOT"><span class="section-number">6.3.3.</span> <code>Locale.ROOT</code> convention</h3>
<p>
All <abbr title="Spatial Information System">SIS</abbr> methods receiving or returning the value of a <code>Locale</code> type accept the <code>Locale.ROOT</code> value.
This value is interpreted as specifying not to localize the text.
The notion of a <cite>non-localized text</cite> is a little false, as it is always necessary to chose a formatting convention.
This convention however, though very close to English, is usually slightly different.
For example:
</p>
<ul>
<li>
Identifiers are written as they appear in <abbr title="Unified Modeling Language">UML</abbr> diagrams,
such as <cite>blurredImage</cite> instead of <cite>Blurred image</cite>.
</li>
<li>
Dates are written according to the <abbr title="International Organization for Standardization">ISO</abbr> 8601 format,
which does not correspond to English conventions.
</li>
<li>
Numbers are written using their <code>toString()</code> methods, rather than using a <code>java.text.NumberFormat</code>.
As a result, there are differences in the number of significant digits,
use of exponential notation and the absence of thousands separators.
</li>
</ul>



<h3 id="UnicodePoint"><span class="section-number">6.3.4.</span> Treatment of characters</h3>
<p>
In Java, sequences of characters use UTF-16 encoding.
There is a direct correspondence between the values of the <code>char</code> type and the great majority of characters,
which facilitates the use of sequences so long as these characters are sufficient.
However, certain Unicode characters cannot be represented by a single <code>char</code>.
These <i>supplementary characters</i> include certain ideograms,
but also road and geographical symbols in the 1F680 to 1F700 range.
Support for these supplementary characters requires slightly more complex interactions than the classic case,
where we may assume a direct correspondence.
Thus, instead of the loop on the left below, international applications must generally use the loop on the right:
</p>

<table class="hidden">
<tr>
<th>Loop to Avoid</th>
<th>Recommended loop</th>
<th>Supplementary character examples</th>
</tr>
<tr>
<td>

<pre style="margin-top: 6pt"><code><b>for</b> (<b>int</b> i=0; i&lt;string.length(); i++) {
    <b>char</b> c = string.charAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// A blank space was found.
</code>    }
}</code></pre>

</td><td>

<pre style="margin-top: 6pt"><code><b>for</b> (<b>int</b> i=0; i&lt;string.length();) {
    <b>int</b> c = string.codePointAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// A blank space was found.
</code>    }
    i += Character.charCount(c);
}</code></pre>

</td><td>
<center>(rendering depends on browser capabilities)</center>
<p style="font-size: 40px">&#128649; &#128677; &#128679; &#128683;
&#128687; &#128696; &#128698; &#128697; &#128708; &#128685;</p>
</td>
</tr>
</table>

<p>
<abbr title="Spatial Information System">SIS</abbr> supports supplementary characters by using the loop on the right where necessary,
but the loop on the left is occasionally used when it is known that the characters searched for are not supplementary characters,
even if some may be present in the sequence in which we are searching.
</p>



<h4 id="Whitespaces"><span class="section-number">6.3.4.1.</span> Blank spaces interpretation</h4>
<p>
Standard Java provides two methods for determining whether a character is a blank space:
<code>Character​.isWhitespace(…)</code> and <code>Character​.isSpaceChar(…)</code>.
These two methods differ in their interpretations of non-breaking spaces, tabs and line breaks.
The first method conforms to the interpretation currently used in languages such as Java, C/C++ and <abbr>XML</abbr>,
which considers tabs and line breaks to be blank spaces, while non-breaking spaces are read as not blank.
The second method — which conforms strictly to the Unicode definition — makes the opposite interpretation.
</p>
<p>
<abbr title="Spatial Information System">SIS</abbr> uses each of these methods in different contexts.
<code>isWhitespace(…)</code> is used to <em>separate</em> the elements of a list (numbers, dates, words, etc.),
while <code>isSpaceChar(…)</code> is used to ignore blank spaces <em>inside</em> a single element.
</p>
<div class="example"><p><b>Example:</b>
Take a list of numbers represented according to French conventions.
Each number may contain <em>non-breaking spaces</em> as thousands separators,
while the different numbers in the list may be separated by ordinary spaces, tabs or line breaks.
When analyzing a number, we want to consider the non-breaking spaces as being part of the number,
whereas a tab or a line break most likely indicates a separation between this number and the next.
We would thus use <code>isSpaceChar(…)</code>.
Conversely, when separating the numbers in the list, we want to consider tabs and line breaks as separators,
but not non-breaking spaces.
We would thus use <code>isWhitespace(…)</code>.
The role of ordinary spaces, to which either case might apply, should be decided beforehand.
</p></div>
<p>
In practice, this distinction is reflected in the use of <code>isSpaceChar(…)</code> in the implementations of <code>java.text.Format</code>,
or the use of <code>isWhitespace(…)</code> in nearly all the rest of the <abbr>SIS</abbr> library.
</p>
</section>
</section>


<section>
<header>
<h1 id="GeoAPI-details"><span class="section-number">7.</span> GeoAPI relationship with standards</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Utilities">Previous chapter</a></div><div class="next-chapter"><a href="#Tests">Next chapter</a> ➡</div></div></nav>
</header>

<nav>In this chapter:<ul class="toc">
<li><a href="#GeoAPI-modules">GeoAPI modules</a></li>
<li><a href="#SpecificationToInterfaces">From OGC specifications to Java interfaces</a><ul>
<li><a href="#UML-annotation">Explicit mapping given by @UML annotations</a></li>
<li><a href="#MappingToJDK">Implicit mapping to standard JDK</a></li></ul></li>
<li><a href="#ReduceDependency">Reduce direct dependency to Apache SIS</a><ul>
<li><a href="#UML-annotation-indep">Mapping given by @UML annotations</a></li>
<li><a href="#ServiceLoader">Fetching implementations of GeoAPI interfaces</a><ul>
<li><a href="#GeoAPI-simple">Defining custom implementations</a></li></ul></li></ul></li></ul></nav>
<p>
The GeoAPI project has been briefly presented <a href="#GeoAPI">in introduction</a> to this document.
This annex explains in more details how GeoAPI relates to international standards.
The goal is to allow developers to reduce their dependency toward GeoAPI or Apache SIS specificities.
</p>







<section>
<header>
<h2 id="GeoAPI-modules"><span class="section-number">7.1.</span> GeoAPI modules</h2>
</header>
<p>
The GeoAPI project consists of a standardized part (<code class="GeoAPI">geoapi</code>)
and an experimental part (<code class="GeoAPI">geoapi-pending</code>).
As these two parts are mutually exclusive, users must take care not to mix them in the same project.
This separation is guaranteed for all projects that depend only on the Maven central repository
(including the final versions of Apache <abbr title="Spatial Information System">SIS</abbr>),
as the <code class="GeoAPI">geoapi-pending</code> module is never deployed on this central repository.
By contrast, certain <abbr>SIS</abbr> development branches may depend on <code class="GeoAPI">geoapi-pending</code>.
</p>
<p>
GeoAPI modules are:
</p>
<ul>
<li><p>
<b><code class="GeoAPI">geoapi</code></b> — includes interfaces covered by the
<a href="http://www.opengeospatial.org/standards/geoapi">GeoAPI standard of the <abbr title="Open Geospatial Consortium">OGC</abbr></a>.
The final versions of Apache <abbr>SIS</abbr> depend on this module.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-pending</code></b> — contains a
<em>copy</em> of all interfaces in the <code class="GeoAPI">geoapi</code> module
(not a dependence) with additions that have not yet been approved as an <abbr>OGC</abbr> standard.
Some additions appear in interfaces normally defined by the <code class="GeoAPI">geoapi</code> module, hence the need to copy them.
Apache <abbr>SIS</abbr>’s development branches <code>jdk7</code> and <code>jdk8</code> depend on this module,
but this dependence becomes a dependence on the <code class="GeoAPI">geoapi</code> standard module when the branches are merged to the trunk.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-conformance</code></b> — includes a JUnit test suite that developers may use to test their implementations.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-examples</code></b> — includes examples of relatively simple implementations.
These examples are placed in the public domain in order to encourage users to copy and adapt them to their needs if
Apache <abbr>SIS</abbr> services are unsuitable.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-proj4</code></b> — contains a partial implementation of <code class="GeoAPI">org.opengis.referencing</code>
packages as adaptors based on the C/C++ Proj.4 library.
This module may be used as an alternative to the <code class="SIS">sis-referencing</code> module for certain functions.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-netcdf</code></b> — contains a partial implementation of <code class="GeoAPI">org.opengis.referencing</code>
and <code class="GeoAPI">org.opengis.coverage</code> packages as adaptors based on the <abbr title="University Corporation for Atmospheric Research">UCAR</abbr> <abbr title="Network Common Data Form">netCDF</abbr> library.
The series of tests in this module was developed in such a way as to be reusable for other projects.
Apache <abbr>SIS</abbr> uses them to test its own <code class="SIS">sis-netcdf</code> module.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-openoffice</code></b> — contains an add-in for the OpenOffice.org office suite.
Note: Apache <abbr>SIS</abbr> provides its own <i>add-in</i> in the <code class="SIS">sis-openoffice</code> module.
</p></li>
</ul>
</section>



<section>
<header>
<h2 id="SpecificationToInterfaces"><span class="section-number">7.2.</span> From <abbr title="Open Geospatial Consortium">OGC</abbr> specifications to Java interfaces</h2>
</header>
<p>
GeoAPI interfaces are sometime generated from other files provided by <abbr>OGC</abbr>, like <abbr title="XML Schema Definition">XSD</abbr> files.
But there is always a manual revision, and often modifications compared to automatically generated Java files.
It would have been possible to automatically generate Java interfaces from <abbr>OGC</abbr> standards using existing tools.
For example one of the most commonly-used approaches is to transform <a href="http://schemas.opengis.net/gml/3.3/"><abbr>XSD</abbr> schemas</a>
into Java interfaces using command line utility <code>xjc</code>.
As this utility is included in most Java distributions (it is one of the <a href="http://jaxb.java.net"><abbr title="Java Architecture for XML Binding">JAXB</abbr></a> tools),
this approach is favoured by many projects found on the Internet.
Other approaches use tools integrated into the Eclipse Development Environment,
which is based on <abbr title="Unified Modeling Language">UML</abbr> schemas rather than <abbr>XSD</abbr> ones.
A similar approach was attempted in the early days of the GeoAPI project, but was quickly abandoned.
We favor a manual approach for the following reasons:
</p>
<ul>
<li>
<p>
Some <abbr>XSD</abbr> schemas are much more verbose than the original <abbr>UML</abbr> schemas.
Converting from <abbr>XSD</abbr> schemas introduces — at least in the case of metadata —
almost double the number of interfaces actually defined by the standard, without adding any new features.
<abbr>XSD</abbr> schemas also define attributes specific to <abbr>XML</abbr> documents (<code class="OGC">id</code>,
<code class="OGC">uuid</code>, <code>xlink:href</code>, <i>etc.</i>), that do not exist in the original <abbr>UML</abbr> diagrams,
and which we do not necessarily wish to expose in a Java <abbr title="Application Programming Interface">API</abbr>.
Converting from <abbr>UML</abbr> schemas avoids this problem, but tools capable of performing this operation are less common.
</p>
<div class="example"><p><b>Example:</b>
<abbr>XSD</abbr> metadata schemas insert a <code class="OGC">&lt;gmd:CI_Citation&gt;</code> element
inside a <code class="OGC">&lt;gmd:citation&gt;</code>,
a <code class="OGC">&lt;gmd:CI_OnlineResource&gt;</code> element inside a <code class="OGC">&lt;gmd:onlineResource&gt;</code>,
and so on for the hundreds of classes defined by <abbr title="International Organization for Standardization">ISO</abbr> 19115 standard.
This redundancy is certainly not necessary in a Java program.
</p></div>
</li>
<li>
<p>
<abbr>OGC</abbr> standards use different naming conventions than Java.
In particular, the names of almost all <abbr>OGC</abbr> classes begin with a two-letter prefix,
such as <code class="OGC">MD_Identifier</code>.
This prefixes fulfill the same role as package names in Java.
GeoAPI adapts this practice by using interface names without prefixes and placing these interfaces in packages corresponding to the prefixes,
but with more descriptive names.
Occasionally we also change the names; for example, to avoid acronyms, or to conform to an established convention such as JavaBeans.
</p>
<div class="example"><p><b>Example:</b>
The <abbr>OGC</abbr> class <code class="OGC">MD_Identifier</code> becomes the
<code class="GeoAPI">Identifier</code> interface in the <code class="GeoAPI">org.opengis.metadata</code> package.
The <abbr>OGC</abbr> class <code class="OGC">SC_CRS</code> becomes the <code class="GeoAPI">CoordinateReferenceSystem</code> interface,
and the <code class="OGC">usesDatum</code> association becomes a <code class="GeoAPI">getDatum()</code> method,
rather than the “<code>getUsesDatum()</code>” that would result from an automatic conversion tool.
We do not allow programs to blindly apply rules that ignore the conventions of the community whose schemas we translate.
</p></div>
</li>
<li>
<p>
The standards may contain structures that do not have a direct equivalent in Java,
such as unions similar to what we would find in C/C++.
The strategy used to obtain an equivalent feature in Java depends on the context:
multiple inheritance of interfaces, modification of the hierarchy, or simply omitting the union.
These decisions are made case-by-case based on a needs analysis.
</p>
<div class="example"><p><b>Example:</b>
<abbr>ISO</abbr> 19111 standard defines different types of coordinate systems, such as spherical, cylindrical, polar or Cartesian.
It then defines several <em>subsets</em> of these types of coordinate systems systems.
These subsets, represented by unions, serve to specify that a class may only be associated with a particular type of coordinate system.
For example, a union of types may be associated with an image, named <code class="OGC">CS_ImageCS</code>,
which can only contain <code class="OGC">CS_CartesianCS</code> and <code class="OGC">CS_AffineCS</code>.
In this case, we get the desired effect in Java through a modification of the hierarchy of classes:
we define the <code class="GeoAPI">CartesianCS</code> interface as a specialization of <code class="GeoAPI">AffineCS</code>,
which is semantically correct.
But it is not possible to apply a similar strategy to other unions without violating the semantics.
</p></div>
</li>
<li>
<p>
Several specifications overlap.
GeoAPI performs the work of integration by replacing some duplicate structures with references to equivalent structures from the standards that best represent them.
</p>
<div class="example"><p><b>Example:</b>
<abbr>ISO</abbr> 19115:2003 standard, which defines metadata structures,
also attempts to describe a few structures representing coordinate reference systems (<abbr title="Coordinate Reference System">CRS</abbr>).
Yet these are also the focus of another standard: <abbr>ISO</abbr> 19111.
At the same time, <abbr>ISO</abbr> 19111:2007 states in section 3 that it reuses all of the elements of
<abbr>ISO</abbr> 19115:2003 except <code class="OGC">MD_CRS</code> and its components.
GeoAPI interfaces reduce the redundancy by applying the exclusion recommended by <abbr>ISO</abbr> 19111 to the entire project.
</p></div>
</li>
<li>
<p>
The complexity of some standards have increased for historical reasons rather than technical ones, related to the standardization process.
GeoAPI reduces the technical debt by designing interfaces with each element in its proper place,
regardless of the chronological order in which the standards were published.
</p>
<div class="example"><p><b>Example:</b>
<abbr>ISO</abbr> 19115-2 standard is an extension of <abbr>ISO</abbr> 19115-1 standard, adding image metadata structures.
These metadata were defined in a separate standard because they were not yet ready when the first part of the standard was published.
As it was not possible for administrative reasons to add attributes to already-published classes,
the new attributes were added in a sub-class bearing almost the same name.
Thus, <abbr>ISO</abbr> 19115-2 defines the class <code class="OGC">MI_Band</code>,
which extends the class <code class="OGC">MD_Band</code> from <abbr>ISO</abbr> 19115-1 by adding attributes that would have appeared
directly in the parent class if there were ready on time.
In GeoAPI, we have chosen to “repair” these anomalies by fusing these two classes into a single interface.
</p></div>
</li>
</ul>
<p>
Deviations from the standards are documented in each affected class and method.
Each mention of a deviation is also collected on a <a href="http://www.geoapi.org/3.0/javadoc/departures.html">single page</a> in order to provide an overview.
Since these deviations blur the relationships between the standards and certain Java interfaces,
the correspondence between these languages is explained by <code class="GeoAPI">@UML</code> annotations and property files described in the following section.
</p>



<h3 id="UML-annotation"><span class="section-number">7.2.1.</span> Explicit mapping given by <code class="GeoAPI">@UML</code> annotations</h3>
<p>
For each class, method and constant defined by an <abbr title="Open Geospatial Consortium">OGC</abbr> or <abbr title="International Organization for Standardization">ISO</abbr> standard,
GeoAPI indicates its provenance using annotations defined in the <code class="GeoAPI">org.opengis.annotation</code> package.
In particular, the <code class="GeoAPI">@UML</code> annotations indicates the standard,
the name of the element in that standard, and also its obligation.
For example, in the following code snippet, the first <code class="GeoAPI">@UML</code> code indicates that the Java interface that follows
(<code class="GeoAPI">ProjectedCRS</code>) is defined using the <code class="OGC">SC_ProjectedCRS</code> type of <abbr>ISO</abbr> 19111 standard.
The second <code class="GeoAPI">@UML</code> annotation, this time applied to the <code class="GeoAPI">getCoordinateSystem()</code> method,
indicates that this method is defined using the <code class="OGC">coordinateSystem</code> association of <abbr>ISO</abbr> 19111 standard,
and that this association is mandatory — meaning, in Java, that the method is not allowed to return a <code>null</code> value.
</p>

<pre><code><b>package</b> <code class="GeoAPI">org.opengis.referencing.crs</code>;

<code class="comment">/**
 * A 2D coordinate reference system used to approximate the shape of the earth on a planar surface.
 */</code>
@<code class="GeoAPI">UML</code>(specification=ISO_19111, identifier=<i>"<code class="OGC">SC_ProjectedCRS</code>"</i>)
<b>public</b> <b>interface</b> <code class="GeoAPI">ProjectedCRS</code> <b>extends</b> <code class="GeoAPI">GeneralDerivedCRS</code> {
    <code class="comment">/**
     * Returns the coordinate system, which must be Cartesian.
     */</code>
    @<code class="GeoAPI">UML</code>(obligation=MANDATORY, specification=ISO_19111, identifier=<i>"<code class="OGC">coordinateSystem</code>"</i>)
    <code class="GeoAPI">CartesianCS</code> <code class="GeoAPI">getCoordinateSystem()</code>;
}</code></pre>

<p>
Java reflection methods allow access to this information during the execution of an application.
This is useful for displaying UML identifiers for users familiar with <abbr>OGC</abbr> standards,
or for writing elements in an <abbr>XML</abbr> document.
Class <code class="SIS">org.apache.sis.util.iso.Types</code> provides static convenience methods
like <code class="SIS">getStandardName(Class)</code> for such operations.
For example the following code will display
“Standard name of type <code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> is <code class="OGC">SC_ProjectedCRS</code>”:
</p>

<pre><code>Class&lt;?&gt; type = <code class="GeoAPI">ProjectedCRS</code>.<b>class</b>;
System.out.println(<i>"Standard name of type "</i> + type.getName() + <i>" is "</i> + Types.getStandardName(type));</code></pre>

<p>
The <code class="SIS">Types​.forStandardName(String)</code> convenience method performs the reverse operation.
Applications who want to perform those operations without SIS convenience methods can follow indications
provided in a <a href="#UML-annotation-geoapi">separated chapter</a>.
</p>



<h3 id="MappingToJDK"><span class="section-number">7.2.2.</span> Implicit mapping to standard <abbr>JDK</abbr></h3>
<p>
Some classes and methods have neither an <code class="GeoAPI">@UML</code> annotation, nor an entry in the <code class="GeoAPI">class-index.properties</code> file.
They are either extensions of GeoAPI, or else types defined in other libraries, such as standard <abbr title="Java Development Kit">JDK</abbr>.
In this last case, the mapping to <abbr title="International Organization for Standardization">ISO</abbr> standards is implicit.
The following table describes this mapping for <abbr>ISO</abbr> 19103 types.
Java’s primitive types are preferred when applicable,
but where necessary their wrappers are used in order to authorize null values.
</p>
<table>
<caption>Mapping between <abbr>ISO</abbr> 19103 and <abbr>JDK</abbr> types</caption>
<tr>
<th><abbr>ISO</abbr> type</th>
<th><abbr>JDK</abbr> type</th>
<th>Remarks</th>
</tr>
<tr>
<td class="separator" colspan="2">Numbers</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Integer</code></td>
<td><code>int</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Integer</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Integer</code> (in some cases)</td>
<td><code>long</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Long</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Real</code></td>
<td><code>double</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Double</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Decimal</code></td>
<td><code>java.math.BigDecimal</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Number</code></td>
<td><code>java.lang.Number</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Texts</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">FreeText</code></td>
<td>(no equivalent)</td>
<td class="leftBorder">See <code class="GeoAPI">org.opengis.util.InternationalString</code> below.</td>
</tr>
<tr>
<td><code class="OGC">CharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder">Often <code class="GeoAPI">org.opengis.util.InternationalString</code> (see below).</td>
</tr>
<tr>
<td><code class="OGC">LocalisedCharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence&lt;Character&gt;</code></td>
<td><code>java.lang.CharSequence</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Character</code></td>
<td><code>char</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Dates and hours</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Date</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Time</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">DateTime</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Collections</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Collection</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Bag</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder">A <code class="OGC">Bag</code> is similar to a
<code class="OGC">Set</code> without being restricted by uniqueness.</td>
</tr>
<tr>
<td><code class="OGC">Set</code></td>
<td><code>java.util.Set</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence</code></td>
<td><code>java.util.List</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Dictionary</code></td>
<td><code>java.util.Map</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">KeyValuePair</code></td>
<td><code>java.util.Map.Entry</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Enumerations</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Enumeration</code></td>
<td><code>java.lang.Enum</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">CodeList</code></td>
<td>(no equivalent)</td>
<td class="leftBorder">See <code class="GeoAPI">org.opengis.util.CodeList</code> below.</td>
</tr>
<tr>
<td class="separator" colspan="2">Various</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Boolean</code></td>
<td><code>boolean</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Boolean</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Any</code></td>
<td><code>java.lang.Object</code></td>
<td class="leftBorder"/>
</tr>
</table>

<p>
The nearest equivalent for <code class="OGC">CharacterString</code> is the <code>String</code> class,
but GeoAPI often uses the <code class="GeoAPI">InternationalString</code> interface, allowing the client to choose the language.
For example, it is useful on a server that simultaneously provides pages in multiple languages.
By returning translations when objects are used rather than at the time of their creation,
we allow the <abbr title="Spatial Information System">SIS</abbr> library to provide the same instances of <code class="GeoAPI">Metadata</code>
or <code class="GeoAPI">Coverage</code> (for example) for the same data, regardless of the client’s language.
Translations may be made on the fly with the help of the application’s <code>ResourceBundle</code>,
or may be provided directly with the data (as in the case of <code class="GeoAPI">Metadata</code>).
</p>
<p>
An <code class="OGC">Enumeration</code> corresponds to an <code>Enum</code> in Java.
Both define all authorized values, without allowing the user to add any.
A <code class="OGC">CodeList</code> is similar to an enumeration, except that users may add their own items.
Standard <abbr>JDK</abbr> does not offer this possibility.
GeoAPI defines an abstract <code class="GeoAPI">CodeList</code> class that reproduces some of the functionality of <code>Enum</code> while being extensible.
Extensions are made available by the <code class="GeoAPI">valueOf(String)</code> static method, which, in contrast to <code>Enum</code>,
creates new instances if the name provided does not correspond to the name of an existing instance.
</p>

<pre><code><code class="GeoAPI">MediumName</code> cdRom  = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">CD_ROM;</code>
<code class="GeoAPI">MediumName</code> usbKey = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>); <code class="comment">// There is no constraint on this value.
</code><b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">CD_ROM</code>"</i>)  == cdRom  : <i>"valueOf must return existing constants."</i>;
<b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>) == usbKey : <i>"valueOf must cache the previously requested values."</i>;</code></pre>
</section>


<section>
<header>
<h2 id="ReduceDependency"><span class="section-number">7.3.</span> Reduce direct dependency to Apache SIS</h2>
</header>
<p>
Previous chapters used Apache SIS static methods for convenience.
In some cases, usage of those convenience methods can be replaced by Java code using only GeoAPI methods.
Such replacements may be desirable for applications who want to reduce direct dependency toward Apache SIS,
for example in order to ease migrations between SIS and other GeoAPI implementations.
However this may require that applications write their own convenience methods.
The following sections provide some tip for easing this task.
</p>

<h3 id="UML-annotation-indep"><span class="section-number">7.3.1.</span> Mapping given by <code class="GeoAPI">@UML</code> annotations</h3>
<p>
For each class, method and constant defined by an <abbr title="Open Geospatial Consortium">OGC</abbr> or <abbr title="International Organization for Standardization">ISO</abbr> standard,
GeoAPI indicates its provenance using annotations defined in the <code class="GeoAPI">org.opengis.annotation</code> package.
This mapping is described in the <a href="#UML-annotation">chapter about GeoAPI</a>.
Java reflection methods allow access to this information during the execution of an application.
Class <code class="SIS">org.apache.sis.util.iso.Types</code> provides static convenience methods like
<code class="SIS">getStandardName(Class)</code>, but one can avoid those methods.
The following example displays the standard name for the method <code class="GeoAPI">getTitle()</code> from the <code class="GeoAPI">Citation</code> interface:
</p>

<pre><code>Class&lt;?&gt; type   = <code class="GeoAPI">Citation</code>.<b>class</b>;
Method   method = type.getMethod(<i>"<code class="GeoAPI">getTitle</code>"</i>, (Class&lt;?&gt;[]) <b>null</b>);
<code class="GeoAPI">UML</code>      annot  = method.getAnnotation(<code class="GeoAPI">UML</code>.<b>class</b>);
String   id     = annot.identifier();
System.out.println(<i>"The standard name for the "</i> + method.getName() + <i>" method is "</i> + id);</code></pre>

<p>
The reverse operation — getting the Java class and method from a standard name — is a bit more complicated.
It requires reading the <code class="GeoAPI">class-index.properties</code> file provided in the <code class="GeoAPI">org.opengis.annotation</code> package.
The following example reads the files just before searching for the name of the interface corresponding to <code class="OGC">CI_Citation</code>.
Users are always encouraged to only read this file once and then save its contents in their application’s cache.
</p>

<pre><code>Properties isoToGeoAPI = <b>new</b> Properties();
<b>try</b> (InputStream in = <code class="GeoAPI">UML</code>.<b>class</b>.getResourceAsStream(<i>"<code class="GeoAPI">class-index.properties</code>"</i>)) {
    isoToGeoAPI.load(in);
}
String isoName = <i>"<code class="OGC">CI_Citation</code>"</i>;
String geoName = getProperty(isoName);
Class&lt;?&gt;  type = Class.forName(geoName);
System.out.println(<i>"The GeoAPI interface for <abbr>ISO</abbr> type "</i> + isoName + <i>" is "</i> + type);</code></pre>

<p>
The <code class="SIS">org.apache.sis.util.iso.Types</code> convenience method for above task is
<code class="SIS">forStandardName(String)</code>.
</p>



<h3 id="ServiceLoader"><span class="section-number">7.3.2.</span> Fetching implementations of GeoAPI interfaces</h3>
<p>
GeoAPI defines factories (<code class="GeoAPI">Factory</code>) that can create implementations of interfaces.
For example, <code class="GeoAPI">DatumFactory</code> provides methods that can create instances which implement interfaces of the
<code class="GeoAPI">org.opengis.referencing.datum</code> package.
A <code class="GeoAPI">Factory</code> must be implemented by a geospatial library,
and declared as a <i>service</i> as defined by the <code>java.util.ServiceLoader</code> class.
The <code>ServiceLoader</code> javadoc explains this procedure.
In brief, the library must create a file in the <code>META-INF/services/</code> directory,
with a name corresponding to the complete name of an interface in the factory
(in the preceding example, <code class="GeoAPI">org.opengis.referencing.datum.DatumFactory</code>).
On one line, this text file must include the complete name of the class that implements this interface.
This class may be hidden from users, as they do not need to know of its existence.
</p>
<p>
If the library has correctly declared its factories as services,
users may import them by using <code>ServiceLoader</code>, as in the example below.
This example only takes the first factory located; if there is more than one factory -
for example when multiple libraries coexist — then the choice is left to the user.
</p>

<pre><code><b>import</b> org.opengis.referencing.<code class="GeoAPI">GeodeticDatum</code>;
<b>import</b> org.opengis.referencing.<code class="GeoAPI">DatumFactory</code>;
<b>import</b> java.util.ServiceLoader;

<b>public</b> <b>class</b> MyApplication {
    <b>public</b> <b>void</b> createMyDatum() {
        ServiceLoader  loader = ServiceLoader.load(<code class="GeoAPI">DatumFactory</code>.<b>class</b>);
        <code class="GeoAPI">DatumFactory</code>  factory = loader.iterator().next();
        <code class="GeoAPI">GeodeticDatum</code> myDatum = factory.<code class="GeoAPI">createGeodeticDatum</code>(…);
    }
}</code></pre>



<h4 id="GeoAPI-simple"><span class="section-number">7.3.2.1.</span> Defining custom implementations</h4>
<p>
Implementing GeoAPI oneself in order to meet very specific needs is not difficult.
A developer might concentrate on a handful of interfaces among the hundreds available,
while keeping other interfaces as extension points to eventually implement as needed.
</p>
<p>
The conceptual model that the interfaces represent is complex. But this complexity may be reduced by combining certain interfaces.
For example, many libraries, even well-known ones, do not distinguish between a <cite>Coordinate System</cite> (<abbr>CS</abbr>)
and a <cite>Coordinate <u>Reference</u> System</cite> (<abbr title="Coordinate Reference System">CRS</abbr>).
A developer that also wishes not to make this distinction may implement these two interfaces with the same class.
The resulting implementation may have a simpler class hierarchy than that of GeoAPI interfaces.
The <code class="GeoAPI">geoapi-examples</code> module, discussed later, provides such combinations.
The following table lists a few possible combinations:
</p>
<table>
<tr>
<th>Main Interface</th>
<th>Auxiliary Interface</th>
<th>Use</th>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateReferenceSystem</code></td>
<td><code class="GeoAPI">CoordinateSystem</code></td>
<td>Description of a spatial reference system (<abbr>CRS</abbr>).</td>
</tr>
<tr>
<td><code class="GeoAPI">GeodeticDatum</code></td>
<td><code class="GeoAPI">Ellipsoid</code></td>
<td>Description of the geodetic datum.</td>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateOperation</code></td>
<td><code class="GeoAPI">MathTransform</code></td>
<td>Coordinate transformation operations.</td>
</tr>
<tr>
<td><code class="GeoAPI">IdentifiedObject</code></td>
<td><code class="GeoAPI">ReferenceIdentifier</code></td>
<td>An objet (usually a <abbr>CRS</abbr>) that we can identify by a code.</td>
</tr>
<tr>
<td><code class="GeoAPI">Citation</code></td>
<td><code class="GeoAPI">InternationalString</code></td>
<td>Bibliographic reference consisting of a simple title.</td>
</tr>
<tr>
<td><code class="GeoAPI">GeographicBoundingBox</code></td>
<td><code class="GeoAPI">Extent</code></td>
<td>Spatial area in degrees of longitude and latitude.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValue</code></td>
<td><code class="GeoAPI">ParameterDescriptor</code></td>
<td>Description of a parameter (name, type) associated with its value.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValueGroup</code></td>
<td><code class="GeoAPI">ParameterDescriptorGroup</code></td>
<td>Description of a set of parameters associated with their values.</td>
</tr>
</table>
<p id="GeoAPI-examples">
The <code class="GeoAPI">geoapi-examples</code> module provides examples of simple implementations.
Many of these classes implement more than one interface at a time in order to provide a simpler conceptual model.
The <a href="http://www.geoapi.org/geoapi-examples/apidocs/overview-summary.html">javadoc for this module</a>
lists key packages and classes along with the combinations performed.
This module illustrates not only how GeoAPI might be implemented,
but also how the implementation might be tested using <code class="GeoAPI">geoapi-conformance</code>.
</p>
<p>
Although its primary goal is to serve as a source of inspiration for implementors,
<code class="GeoAPI">geoapi-examples</code> was also designed so as to be usable by applications with very simple needs.
As all the examples are in the public domain, developers are invited to freely adapt copies of these classes as necessary.
However, if changes are made outside the framework of the GeoAPI project,
fair use demands that modified copies be placed in a package with a different name than <code class="GeoAPI">org.opengis</code>.
</p>
<p>
For somewhat more involved needs, developers are invited to examine the
<code class="GeoAPI">geoapi-proj4</code> and <code class="GeoAPI">geoapi-netcdf</code> modules.
These two modules provide examples of adaptors that are allowed, via GeoAPI interfaces,
to use some of the features of external libraries (Proj.4 and <abbr title="Network Common Data Form">netCDF</abbr>).
The advantage of using these interfaces is to provide a unified model to operate two very different <abbr title="Application Programming Interface">API</abbr>s,
while retaining the ability to switch easily to another library if desired.
</p>
</section>
</section>


<section>
<header>
<h1 id="Tests"><span class="section-number">8.</span> Test suites</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#GeoAPI-details">Previous chapter</a></div><div class="next-chapter"><a href="#DesignNotes">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#GeoAPI-conformance">GeoAPI conformance</a><ul>
<li><a href="#GeoAPI-validators">Instance validations</a></li>
<li><a href="#GeoAPI-tests">Executing pre-defined tests</a></li></ul></li></ul></nav>
<p>
In addition to its own tests, Apache SIS uses tests defined by GeoAPI.
One advantages is that those tests provide an external source for the definition of expected results
(for example the numerical values of coordinates obtained after a map projection).
Such external source reduce the risk that some tests are actually anti-regression tests
instead of correctness tests.
Those tests can also be used by projects other than Apache SIS.
</p>




<section>
<header>
<h2 id="GeoAPI-conformance"><span class="section-number">8.1.</span> GeoAPI conformance</h2>
</header>
<p>
The <code class="GeoAPI">geoapi-conformance</code> module provides <i>validators</i>, a JUnit <i>test suite</i>, and <i>report generators</i>
in the form of <abbr title="Hypertext Markup Language">HTML</abbr> pages.
This module may be used with any GeoAPI implementation.
For developers of a geospatial library, it offers the following advantages:
</p>
<ul>
<li>Reduces the tedious task of writing tests by using existing tests.</li>
<li>Increases confidence in the validity of tests,
since <code class="GeoAPI">geoapi-conformance</code> has its own test suite and is applied to other implementations.</li>
<li>Facilitates comparison with other implementations.</li>
</ul>



<h3 id="GeoAPI-validators"><span class="section-number">8.1.1.</span> Instance validations</h3>
<p>
GeoAPI can validate an instance of its interfaces by checking that certain constraints are observed.
Many constraints can not be expressed in the method signature. Those constraints
are usually described textually in the abstract specifications or in the javadoc.
</p>
<div class="example"><p><b>Example:</b>
A coordinate conversion or transformation (<code class="OGC">CC_CoordinateOperation</code>) may require a sequence of several steps.
In such a sequence of operations (<code class="OGC">CC_ConcatenatedOperation</code>), for each step (<code class="OGC">CC_SingleOperation</code>)
the number of output dimensions must equal the number of input dimensions in the next operation.
Expressed in Java, this constraint stipulates that for the entire index 0 &lt; <var>i</var> &lt; <var>n</var> where <var>n</var>
is the number of operations, we have <code>coordOperation[i].targetDimensions == coordOperation[i-1].sourceDimensions</code>.
</p></div>

<p>
The easiest way to perform these verifications is to call the static methods <code class="GeoAPI">validate(…)</code>
of the <code class="GeoAPI">org.opengis.test.Validators</code> class.
As all of <code class="GeoAPI">Validators</code> methods bear the same name, it is enough to write “<code>validate(<var>value</var>)</code>”
and then let the compiler choose the most appropriate method for the type of object given in argument.
If the object type is not known at the time of compilation,
the <code class="GeoAPI">dispatch(Object)</code> method can be invoked for redirecting the work to the most appropriate <code class="GeoAPI">validate(…)</code> method.
</p>
<p>
All <code class="GeoAPI">validate(…)</code> functions follow a chain of dependencies,
meaning that they will also validate each component of the object to be validated.
For example, the validation of a <code class="GeoAPI">GeographicCRS</code> implies the validation of its component
<code class="GeoAPI">GeodeticDatum</code>, which itself implies the validation of its component <code class="GeoAPI">Ellipsoid</code>, and so on.
Thus it is unnecessary to validate the components explicitely, unless the developer wishes to isolate the test for a particular item known to cause problems.
</p>
<p>
By default, validations are as strict as possible. It is always possible to relax certain rules.
The most common is to tolerate the absence of attributes that would normally be mandatory.
This rule and a few others may be modified globally for all tests executed by the currently running <abbr title="Java Virtual Machine">JVM</abbr>,
as in the following example:
</p>

<pre><code><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">Validators</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <code class="comment">/*
     * Tolerate the absence of mandatory attributes in metadata and citation packages.
     * This modification applies to all tests executed by the currently running <abbr>JVM</abbr>.
     * If there are multiple test classes, this initialization may be performed
     * in a parent class to all test classes.
     */</code>
    <b>static</b> {
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.metadata.requireMandatoryAttributes</code> = <b>false</b>;
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Create an object here.
</code>        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">validate</code>(myObject);
    }
}</code></pre>

<p>
Rules may also be modified for a particular test suite without affecting the default configuration of the standard <abbr>JVM</abbr>.
This approach requires the creation of a new instance of the validator that we wish to modify the configuration.
</p>

<pre><code><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">ValidatorContainer</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <b>private</b> <b>final</b> <code class="GeoAPI">ValidatorContainer</code> validators;

    <b>public</b> MyTest() {
        validators = <b>new</b> <code class="GeoAPI">ValidatorContainer</code>();
        validators.<code class="GeoAPI">metadata.requireMandatoryAttributes</code> = <b>false</b>;
        validators.<code class="GeoAPI">citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Create an object here.
</code>        validators.<code class="GeoAPI">validate</code>(myObject);
    }
}</code></pre>



<h3 id="GeoAPI-tests"><span class="section-number">8.1.2.</span> Executing pre-defined tests</h3>
<p>
JUnit tests are defined in the <code class="GeoAPI">org.opengis.test</code> sub-packages.
All test classes bear a name ending in "<code>Test</code>".
GeoAPI also provides an <code class="GeoAPI">org.opengis.test.TestSuite</code> class including all test classes defined in the
<code class="GeoAPI">geoapi-conformance</code> module, but Apache <abbr title="Spatial Information System">SIS</abbr> does not use it.
Instead, Apache <abbr>SIS</abbr> inherits GeoAPI’s <code class="GeoAPI">*Test</code> classes on a case-by-case basis,
in the appropriate modules.
The example below gives an example of a customized GeoAPI test:
The <a href="http://www.geoapi.org/geoapi-conformance/apidocs/org/opengis/test/referencing/ParameterizedTransformTest.html">parent test javadoc</a>
documents the tests performed in detail.
In this example, only one test is modified and all the others are inherited as they are (it is not necessary to repeat them in the sub-class).
However, this example adds a supplemental verification, annotated with <code>@After</code>, which will be executed after each test.
</p>

<pre><code><b>import</b> org.junit.*;
<b>import</b> org.junit.runner.RunWith;
<b>import</b> org.junit.runners.JUnit4;
<b>import</b> org.opengis.test.referencing.<code class="GeoAPI">ParameterizedTransformTest</code>;
<b>import</b> <b>static</b> org.junit.Assert.*;

@RunWith(JUnit4.<b>class</b>)
<b>public</b> <b>class</b> MyTest <b>extends</b> <code class="GeoAPI">ParameterizedTransformTest</code> {
    <code class="comment">/**
     * Specify our own coordinate transformation factory for the GeoAPI tests.
     * GeoAPI will test the objects created by this factory.
     */</code>
    <b>public</b> MyTest() {
        <b>super</b>(<b>new</b> MyMathTransformFactory());
    }

    <code class="comment">/**
     * Changes the behaviour of a test. This example relaxes the requirements of this test a little,
     * by accepting errors of up to 10 centimetres, rather than the default value of 1 cm.
     * This change only applies to this method, and does not affect the other inherited tests.
     */</code>
    @Test
    @Override
    <b>public</b> <b>void</b> testLambertAzimuthalEqualArea() <b>throws</b> <code class="GeoAPI">FactoryException</code>, <code class="GeoAPI">TransformException</code> {
        <code class="GeoAPI">tolerance</code> = 0.1;                    <code class="comment">// 10 cm tolerance.
</code>        <b>super</b>.<code class="GeoAPI">testLambertAzimuthalEqualArea()</code>;
    }

    <code class="comment">/**
     * Supplemental verification performed after each test, inherited or not.
     * In this example, we are verifying that the transformation tested
     * works correctly in two-dimensional spaces.
     */</code>
    @After
    <b>public</b> <b>void</b> ensureAllTransformAreMath2D() {
        assertTrue(<code class="GeoAPI">transform</code> <b>instanceof</b> <code class="GeoAPI">MathTransform2D</code>);
    }
}</code></pre>
</section>
</section>


<section>
<header>
<h1 id="DesignNotes"><span class="section-number">9.</span> Design notes</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Tests">Previous chapter</a></div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#AffineTransform">Affine transform</a><ul>
<li><a href="#AffineTransformAPI">Integration with graphical libraries</a></li></ul></li>
<li><a href="#MatrixLibrary">Specificities of a matrix library for GIS</a><ul>
<li><a href="#NonSquareMatrix">What to do with non-square matrices (and why)</a></li>
<li><a href="#MatrixLibrarySummary">Apache SIS matrix library</a></li></ul></li></ul></nav>
<p>Following sections explain the rational behind some implementation choices done in Apache <abbr title="Spatial Information System">SIS</abbr>.</p>





<section>
<header>
<h2 id="AffineTransform"><span class="section-number">9.1.</span> Affine transform</h2>
</header>
<p>
Among the many kinds of operations performed by <abbr>GIS</abbr> software products on spatial coordinates,
<cite>affine transforms</cite>  are both relatively simple and very common.
Affine transforms can represent any combination of scales, shears, flips, rotations and translations,
which are <em>linear</em> operations.
Affine transforms can not handle <em>non-linear</em> operations like map projections,
but the affine transform capabilities nevertheless cover many other cases:
</p>
<ul>
<li>Axis order changes,           for example from (<var>latitude</var>, <var>longitude</var>) to (<var>longitude</var>, <var>latitude</var>).</li>
<li>Axis direction changes,       for example the <var>y</var> axis oriented toward down in images.</li>
<li>Prime meridian rotations,     for example from <cite>Paris</cite> to <cite>Greenwich</cite> prime meridian.</li>
<li>Dimensionality changes,       for example from 3-dimensional coordinates to 2-dimensional coordinates by dropping the height.</li>
<li>Unit conversion,              for example from feet to metres.</li>
<li>Pixel to geodetic coordinate, for example the conversion represented in the <code>.tfw</code> files associated to some <abbr>TIFF</abbr> images.</li>
<li>Part of map projections,      for example the <cite>False Easting</cite>, <cite>False Northing</cite> and <cite>Scale factor</cite> parameters.</li>
</ul>
<p>
Affine transforms can be concatenated efficiently.
No matter how many affine transforms are chained, the result can be represented by a single affine transform.
This property is more easily seen when affine transforms are represented by matrices:
in order to concatenate those operations, we only need to multiply those matrices.
The “pixel to geographic coordinate conversions” case below gives an example.
</p>

<div class="example">
<p><b>Example:</b>
given an image with pixel coordinates represented by (<var>x</var>,<var>y</var>) tuples
and given the following assumptions:
</p>
<ul>
<li>There is no shear, no rotation and no flip.</li>
<li>All pixels have the same width in degrees of longitude.</li>
<li>All pixels have the same height in degrees of latitude.</li>
<li>Pixel indices are positive integers starting at (0,0) inclusive.</li>
</ul>
<p>Then conversions from pixel coordinates (<var>x</var>,<var>y</var>)
to geographic coordinates (<var>λ</var>,<var>φ</var>) can be represented by the following equations,
where <var>N</var><sub><var>x</var></sub> is the image width and
<var>N</var><sub><var>y</var></sub> the image height in number of pixels:
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mtable>
<mtr>
<mtd><mo>λ</mo></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub><mi>x</mi><mo>+</mo><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
<mtd><mtext>        where        </mtext></mtd>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd>
<mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac>
</mtd>
<mtd><mtext>    and    </mtext></mtd>
<mtd><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mo>φ</mo></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub><mi>y</mi><mo>+</mo><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
<mtd><mtext>        where        </mtext></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd>
<mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac>
</mtd>
<mtd><mtext>    and    </mtext></mtd>
<mtd><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
<mtd><mo>=</mo></mtd>
<mtd><msub><mi>φ</mi><mrow>min</mrow></msub></mtd>
</mtr>
</mtable>
</math>
</p><p>
Above equations can be represented in matrix form as below:
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>λ</mi></mtd></mtr>
<mtr><mtd><mi>φ</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><msub><mi>S</mi><mrow>λ</mrow></msub></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>T</mi><mrow>λ</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>S</mi><mrow>φ</mrow></msub></mtd>
<mtd><msub><mi>T</mi><mrow>φ</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
<mo>×</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><mi>x</mi></mtd></mtr>
<mtr><mtd><mi>y</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
</math>
</p><p>
In this particular case, scale factors <var>S</var> are the pixel size in degrees
and translation terms <var>T</var> are the geographic coordinate of an image corner
(not necessarily the lower-left corner if some axes have been flipped).
This straightforward interpretation holds because of above-cited assumptions, but
matrix coefficients become more complex if the image has shear or rotation
or if pixel coordinates do not start at (0,0).
However it is not necessary to use more complex equations for supporting more generic cases.
The following example starts with an “initial conversion” matrix
where the <var>S</var> and <var>T</var> terms are set to the most straightforward values.
Then the <var>y</var> axis direction is reversed for matching the most common convention in image coordinate systems (change 1),
and axis are swapped resulting in latitude before longitude (change 2).
Note that when affine transform concatenations are written as matrix multiplications, operations are ordered from right to left:
<var>A</var>×<var>B</var>×<var>C</var> is equivalent to first applying operation <var>C</var>,
then operation <var>B</var> and finally operation <var>A</var>.
</p>
<table class="hidden"><tr>
<th>Change 2</th><th/>
<th>Change 1</th><th/>
<th>Initial conversion</th><th/>
<th>Concatenated operation</th>
</tr><tr>
<td style="vertical-align: middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</td>
<td style="vertical-align: middle; padding-left: 15px; padding-right: 15px">×</td>
<td style="vertical-align: middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>-1</mn></mtd>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</td>
<td style="vertical-align: middle; padding-left: 15px; padding-right: 15px">×</td>
<td style="vertical-align: middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><msub><mi>φ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</td>
<td style="vertical-align: middle; padding-left: 15px; padding-right: 15px">=</td>
<td style="vertical-align: middle">
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mo>-</mo><mfrac>
<mrow>
<msub><mi>φ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>φ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>y</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><msub><mi>φ</mi><mrow>max</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mfrac>
<mrow>
<msub><mi>λ</mi><mrow>max</mrow></msub><mo>-</mo>
<msub><mi>λ</mi><mrow>min</mrow></msub>
</mrow><mrow>
<msub><mi>N</mi><mrow><mi>x</mi></mrow></msub>
</mrow>
</mfrac></mtd>
<mtd><mn>0</mn></mtd>
<mtd><msub><mi>λ</mi><mrow>min</mrow></msub></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
</math>
</td>
</tr></table>
<p>
A key principle is that there is no need to write Java code dedicated to above kinds of axis changes.
Those operations, and many other, can be handled by matrix algebra.
This approach makes easier to write generic code and improves performance.
Apache <abbr title="Spatial Information System">SIS</abbr> follows this principle by using affine transforms for every operations
that can be performed by such transform.
For instance there is no code dedicated to changing order of ordinate values in a coordinate.
</p>
</div>

<h3 id="AffineTransformAPI"><span class="section-number">9.1.1.</span> Integration with graphical libraries</h3>
<p>
About all graphical libraries support some kind of coordinate operations, usually as <cite>affine transforms</cite>
or a slight generalization like <cite>perspective transforms</cite>.
Each library defines its own <abbr title="Application Programming Interface">API</abbr>. Some examples are listed below:
</p>
<table>
<caption>Affine transform implementations in graphical libraries</caption>
<tr><th>Library</th>                                  <th>Transform implementation</th>                          <th>Dimensions</th></tr>
<tr><td>Java2D</td>                                   <td><code>java.awt.geom.AffineTransform</code></td>        <td>2</td></tr>
<tr><td>Java3D</td>                                   <td><code>javax.media.j3d.Transform3D</code></td>          <td>3</td></tr>
<tr><td>JavaFX</td>                                   <td><code>javafx.scene.transform.Affine</code></td>        <td>2 or 3</td></tr>
<tr><td>Java Advanced Imaging (<abbr>JAI</abbr>)</td> <td><code>javax.media.jai.PerspectiveTransform</code></td> <td>2</td></tr>
<tr><td>Android</td>                                  <td><code>android.graphics.Matrix</code></td>              <td>2</td></tr>
</table>
<p>
However in many cases, affine or perspective transforms are the only kind of coordinate operations supported by the graphical library.
Apache <abbr title="Spatial Information System">SIS</abbr> needs to handle a wider range of operations, in which affine transforms are only special cases.
In particular most map projections and datum shifts can not be represented by affine transforms.
<abbr>SIS</abbr> also needs to support arbitrary number of dimensions,
while above-cited <abbr>API</abbr> restrict the use to a fixed number of dimensions.
For those reasons <abbr>SIS</abbr> can not use directly the above-cited <abbr>API</abbr>.
Instead, <abbr>SIS</abbr> uses the more abstract <code class="GeoAPI">org.opengis.referencing.transform.MathTransform</code> interface.
But in the special case where the transform is actually affine, <abbr>SIS</abbr> may try to use an existing implementation,
in particular Java2D. The following Java code can be used in situations where the Java2D object is desired:
</p>

<pre><code><code class="GeoAPI">MathTransform</code> mt = ...;    <code class="comment">// Any math transform created by Apache SIS.
</code><b>if</b> (mt <b>instanceof</b> AffineTransform) {
    AffineTransform at = (AffineTransform) mt;
    <code class="comment">// Use Java2D API from here.
</code>}</code></pre>

<p>
Apache <abbr>SIS</abbr> uses Java2D on a <em>best effort</em> basis only.
The above cast is not guaranteed to succeed,
even when the <code class="GeoAPI">MathTransform</code> meets the requirements allowing Java2D usage.
</p>
</section>


<section>
<header>
<h2 id="MatrixLibrary"><span class="section-number">9.2.</span> Specificities of a matrix library for <abbr>GIS</abbr></h2>
</header>
<p>
<abbr>GIS</abbr> make an extensive usage of matrices for displaying maps or for transforming coordinates.
There is many excellent open source or commercial matrix libraries available.
However, <abbr>GIS</abbr> have some specific needs that differ a little bit from the goals of many existent libraries.
Matrix operations like those described in the <a href="#AffineTransform">affine transform chapter</a>
appear in almost all coordinate operations applied by Apache <abbr title="Spatial Information System">SIS</abbr>.
But the analysis of those operations reveal some patterns:
</p>
<ul>
<li><p>Those matrices are almost always of small size, rarely more than 5 rows and 5 columns.</p></li>
<li><p>“Heavy” matrix operations (matrix inversions or multiplications) do not happen in performance-critical code.
In almost every cases, those heavy operations are executed only once, for example when a data file is read
or in preparation steps before to transform coordinates.
Those heavy operations rarely happen in the loop that apply the coordinate operation
after we finished to prepare it.</p></li>
<li><p>In a sequence of matrix multiplications or inversions, rounding errors accumulate and grow fast.
If the sequence of matrix operations is long enough,
rounding errors can become indistinguishable from real operations like datum shifts.
This ambiguity can happen because the matrix representation of some datum shifts has small values,
with scale factors of a few parts per million and rotation terms of a few arc-seconds.</p></li>
<li><p>It is quite common that two affine transforms cancel each other when they are concatenated, i.e.
that matrix multiplications result in some or all scale factors equal to 1 and some or all translation terms equal to 0.
However because of rounding errors the results are rarely exact, but are rather some values like 0,9999…97 instead of 1.
The usual workaround is to compare floating point numbers with some tolerance threshold.
Unfortunately it is difficult to choose a threshold that catch a wide range of rounding errors
without wrongly considering legitimate datum shifts as rounding errors (see previous point).</p></li>
</ul>
<p>
As a consequence of above points, accuracy of a matrix library is more important than performance for a <abbr>GIS</abbr> like Apache <abbr>SIS</abbr>.
Paradoxically, a good way to improve performance is to invest more CPU time for more accurate matrix operations
when <em>preparing</em> (not <em>executing</em>) the coordinate operation,
because it increases the chances to correctly detect which operations cancel each other.
This investment can save execution time at the place where it matters most:
in the code looping over millions of coordinates to transform.
</p><p>
However matrix libraries are often designed for high performances with large matrices, sometime containing thousands of rows and columns.
Those libraries can efficiently resolve systems of linear equations with hundreds of unknown variables.
Those libraries resolve difficult problems, but not of the same kind than the problems that Apache <abbr>SIS</abbr> needs to solve.
For that reason, and also for another reason described in next paragraphs, Apache <abbr>SIS</abbr> uses its own matrix implementation.
This implementation addresses the accuracy issue by using “double-double” arithmetic
(a technic for simulating the accuracy of approximatively 120 bits wide floating point numbers)
at the cost of performance in a phase (transform <em>preparation</em>) where performance is not considered critical.
</p>

<h3 id="NonSquareMatrix"><span class="section-number">9.2.1.</span> What to do with non-square matrices (and why)</h3>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> often needs to inverse matrices, in order to perform a coordinate operation in reverse direction.
Matrix inversions are typically performed on square matrices, but <abbr>SIS</abbr> also needs to inverse non-square matrices.
Depending on whether we have more lines than columns:
</p>
<ul>
<li>From Apache <abbr>SIS</abbr> library perspective, a non-square matrix is a coordinate operation that adds or removes a dimension.</li>
<li>From linear algebra libraries perspective, a non-square matrix is an under-determined or over-determined system of equations.</li>
</ul>
<p>
To illustrate the issues caused by direct use of libraries designed for linear algebra,
consider a (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>) → (<var>φ₂</var>, <var>λ₂</var>) conversion
from three-dimensional points to two-dimensional points on a surface.
The <var>φ</var> terms are latitudes, the <var>λ</var> terms are longitudes and
(<var>φ₂</var>, <var>λ₂</var>) may be different than (<var>φ₁</var>, <var>λ₁</var>) if <var>h</var> axis is not perpendicular to the surface.
</p><p>


<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="MathML capable browser required" display="block">
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><msub><mi>φ</mi><mrow><mn>2</mn></mrow></msub></mtd></mtr>
<mtr><mtd><msub><mi>λ</mi><mrow><mn>2</mn></mrow></msub></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
<mo>=</mo>
<mfenced close="]" open="[">
<mtable>
<mtr>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
</mtr>
<mtr>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>0</mn></mtd>
<mtd><mn>1</mn></mtd>
</mtr>
</mtable>
</mfenced>
<mo>×</mo>
<mfenced close="]" open="[">
<mtable>
<mtr><mtd><msub><mi>φ</mi><mrow><mn>1</mn></mrow></msub></mtd></mtr>
<mtr><mtd><msub><mi>λ</mi><mrow><mn>1</mn></mrow></msub></mtd></mtr>
<mtr><mtd><mi>h</mi></mtd></mtr>
<mtr><mtd><mn>1</mn></mtd></mtr>
</mtable>
</mfenced>
</math>
</p><p>
For linear algebra libraries, the above non-square matrix represents an under-determined system of equations and may be considered unresolvable.
Indeed the above coordinate operation can not be inverted as a (<var>φ₂</var>, <var>λ₂</var>) → (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>)
operation because we do not know which value to assign to <var>h</var>.
Ignoring <var>h</var> implies that we can not assign values to (<var>φ₁</var>, <var>λ₁</var>) neither since those values may depend on <var>h</var>.
However in <abbr>GIS</abbr> case, the ellipsoidal <var>h</var> axis is perpendicular to the ellipsoid surface
on which the <em>geodetic</em> latitudes and longitudes (<var>φ</var>, <var>λ</var>) are represented
(note that this statement is not true for <em>geocentric</em> latitudes and longitudes).
This perpendicularity makes <var>φ₁</var> and <var>λ₁</var> independent of <var>h</var>.
In such cases, we can can still do some processing.
</p><p>
Apache <abbr>SIS</abbr> proceeds by checking if <var>h</var> values are independent of <var>φ</var> and <var>λ</var> values.
We identify such cases by checking which matrix coefficients are zero.
If <abbr>SIS</abbr> can identify independent dimensions, it can temporarily exclude those dimensions
and invert the matrix using only the remaining dimensions.
If <abbr>SIS</abbr> does not found a sufficient amount of independent dimensions, an exception is thrown.
But if a matrix inversion has been possible, then we need to decide which value to assign to the dimensions that <abbr>SIS</abbr> temporarily excluded.
By default, <abbr>SIS</abbr> assigns the <code>NaN</code> (<cite>Not-a-Number</cite>) value to those dimensions.
However in the particular case of ellipsoidal height <var>h</var> in a (<var>φ₂</var>, <var>λ₂</var>) → (<var>φ₁</var>, <var>λ₁</var>, <var>h</var>) operation,
the zero value may also be appropriate on the assumption that the coordinates are usually close to the ellipsoid surface.
In any case, the coefficients that Apache <abbr>SIS</abbr> sets to zero or <code>NaN</code> is based on the assumption
that the matrix represents a coordinate operation; this is not something that can be done with arbitrary matrices.
</p><p>
The above-described approach allows Apache <abbr>SIS</abbr> to resolve some under-determined equation systems commonly found in <abbr>GIS</abbr>.
In our example using <code>NaN</code> as the default value, the <var>h</var> ordinate stay unknown – we do not create information from nothing –
but at least the (<var>φ</var>, <var>λ</var>) coordinates are preserved.
The opposite problem, those of over-determined equation systems, is more subtile.
An approach commonly applied by linear algebra libraries is to resolve over-determined systems by the least squares method.
Such method applied to our example would compute a (<var>φ₂</var>, <var>λ₂</var>, <var>h</var>) → (<var>φ₁</var>, <var>λ₁</var>) operation
that seems the best compromise for various <var>φ₂</var>, <var>λ₂</var> and <var>h</var> values,
while being (except special cases) an exact solution for no-one.
Furthermore linear combinations between those three variables may be an issue because of heterogenous units of measurement,
for instance with <var>h</var> in metres and (<var>φ</var>, <var>λ</var>) in degrees.
Apache <abbr>SIS</abbr> rather proceeds in the same way than for under-determined systems:
by requiring that some dimensions are independent from other dimensions, otherwise the matrix is considered non-invertible.
Consequently in over-determined systems case, <abbr>SIS</abbr> may refuse to perform some matrix inversions that linear algebra libraries can do,
but in case of success the resulting coordinate operation is guaranteed to be exact (ignoring rounding errors).
</p>

<h3 id="MatrixLibrarySummary"><span class="section-number">9.2.2.</span> Apache <abbr title="Spatial Information System">SIS</abbr> matrix library</h3>
<p>
In summary, Apache <abbr>SIS</abbr> provides its own matrix library for the following reasons:
</p>
<ul>
<li>Lightweight objects for small matrices, especially the 3×3 ones.</li>
<li>Improved accuracy with “double-double” arithmetic, accepting performance cost in codes where performance is not critical.</li>
<li>Special handling of non-square matrices on the assumption that those matrices represent coordinate operations.</li>
</ul>
<p>
This library is provided in the <code class="SIS">org.apache.sis.matrix</code> package of the <code class="SIS">sis-referencing</code> module.
</p>
</section>
</section>
</main>
</body>
</html>