<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>

<!--
  Licensed to the Apache Software Foundation (ASF)

      http://www.apache.org/licenses/LICENSE-2.0

  This is an automatically generated file. DO NOT EDIT.
  See the files in the ../../../book/ directory instead.
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>Introduction to Apache SIS</title>
<link href="../book.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p style="margin-top: 30pt"><span style="font-size: 30pt; font-weight: 900">Introduction to Apache SIS®</span></p>
<p style="margin-bottom: 20pt">(English | <a href="../fr/developer-guide.html">Français</a>)</p>
<p><i>Martin Desruisseaux</i><br/>
<i>Christina Hough</i></p>
<p>This work is licensed under the Apache 2 license.</p>
<hr/>

<p><b style="font-size: 20pt">Table of content</b></p>
<nav>
<ul class="toc">
<li><a href="#Foreword">Foreward</a><ul>
<li><a href="#Standards">Standards and Norms</a></li>
<li><a href="#About">Conventions Used in This Guide</a><ul>
<li><a href="#CodeColors">Code Colors</a></li></ul></li></ul></li>
<li><a href="#GeoAPI">GeoAPI</a><ul>
<li><a href="#UML-annotation">Mapping Given by @UML Annotations</a><ul>
<li><a href="#MappingToJDK">Implicit Mapping to Standard JDK</a></li></ul></li>
<li><a href="#GeoAPI-implementation">Interface implementations</a></li></ul></li>
<li><a href="#Utilities">Utility Classes and Methods</a><ul>
<li><a href="#ComparisonMode">Comparison Modes of Objects</a></li>
<li><a href="#Internationalization">Internationalization</a><ul>
<li><a href="#LocalizedString">Distinct Character Sequences for Each Locale</a></li>
<li><a href="#InternationalString">Single instance for all supported locales</a></li>
<li><a href="#Locale.ROOT">Locale.ROOT Convention</a></li>
<li><a href="#UnicodePoint">Treatment of Characters</a><ul>
<li><a href="#Whitespaces">The Interpretation of Blank Spaces</a></li></ul></li></ul></li></ul></li>
<li><a href="#Geometry">Geometries</a><ul>
<li><a href="#Geometry-root">Base Classes</a><ul>
<li><a href="#DirectPosition">Direct Points and Positions</a></li>
<li><a href="#Envelope">Envelopes</a><ul>
<li><a href="#AntiMeridian">Envelopes that Cross the Antimeridian</a></li></ul></li></ul></li></ul></li>
<li><a href="#Coverage">Data Coverages</a></li>
<li><a href="#XML-ISO">Representing Objects in XML</a><ul>
<li><a href="#XML-ISO-19115">Representing Metadata According to ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification of Already-Defined Instances</a></li>
<li><a href="#nilReason">Representing Missing Values</a></li></ul></li></ul></li>
<li><a href="#reduce-direct-dependency">Reduce direct dependency to Apache SIS</a><ul>
<li><a href="#UML-annotation-geoapi">Mapping Given by @UML Annotations</a></li>
<li><a href="#ServiceLoader">Fetching implementations of GeoAPI Interfaces</a><ul>
<li><a href="#GeoAPI-simple">Defining Custom Implementations</a></li></ul></li></ul></li>
<li><a href="#tests">Test suites</a><ul>
<li><a href="#GeoAPI-validators">Instance Validations</a></li>
<li><a href="#GeoAPI-tests">Executing Pre-defined Tests</a></li></ul></li>
</ul>
</nav>

<main>
<section>
<header>
<h1 id="Foreword"><span class="section-number">1.</span> Foreward</h1>
<nav><div class="chapter-links"><div class="next-chapter"><a href="#GeoAPI">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#Standards">Standards and Norms</a></li>
<li><a href="#About">Conventions Used in This Guide</a><ul>
<li><a href="#CodeColors">Code Colors</a></li></ul></li></ul></nav>
<p>
A geospatial information community is a collection of systems or individuals capable of exchanging their geospatial data
through the use of common standards, allowing them to communicate with one another.
As there are many ways to represent geospatial information, each community tends to structure this information in light of its areas of interest.
This diversity complicates the task of Spatial Information System (<abbr>SIS</abbr>) users
by confronting them with an apparently chaotic variety of data formats and structures.
The characteristics of these structures vary according to the observed phenomenon and measurement methods,
as well as the habits of the organizations producing the data.
Such a variety represents an obstacle in studies that require heterogeneous combinations of data,
especially when they originate in communities that are traditionally distinct.
For example, a researcher studying cholera might be interested in populations of shrimp as a propagation vector of the disease.
But as doctors and oceanographers may not be used to share their work,
the participants of such a study may be limited by the effort required to convert the data.
</p><p>
We cannot impose a uniform format on all data collections, as the diversity of formats is tied to factors
such as the constraints imposed by the measuring apparatus, and the statistical distribution of values.
A more flexible solution is to ensure the interoperability of data across a common programming interface
(<abbr title="Application Programming Interface">API</abbr>).
This <abbr>API</abbr> is not necessarily defined in a programming language;
the actual tendency is rather to define conventions that use existing web protocols, which we can translate into various programming languages.
But in order for this approach to be viable, the <abbr>API</abbr> must be generally accepted by independent developers.
In other words, the <abbr>API</abbr> must come as near as possible to industrial standards.
</p><p>
For example, one task that benefit from a successful standardization is the accessing of relational databases.
The industry has established a common language — the <abbr title="Structured Query Language">SQL</abbr> standard —
that the creators of Java have embedded in standard <abbr title="Java DataBase Connectivity">JDBC</abbr> programming interfaces.
Today, these interfaces are implemented by many software programs, both free and commercial.
Like databases, methods of accessing geographic information have been standardized.
In this case, however, the efforts have been more recent, and their integration in software — especially in older programs — is incomplete and not always coherent.
At the time of writing, no product to our knowledge has implemented all of the specifications in their entirety.
However, there are many implementations that cover a fairly large spectrum.
One of these is the Apache <abbr>SIS</abbr>® library that is described in this document.
</p><p>
Apache <abbr title="Spatial Information System">SIS</abbr> is characterized by a sustained effort to comply with standards.
In general, complying with standards demands a greater effort than would be required for an isolated development,
but rewards us with a double advantage: not only does it improve the interoperability of our data with that of external projects,
it also points towards a robust way of elaborating the conceptual model reflected in the <abbr>API</abbr>.
In effect, the groups of experts who conceived the standards anticipated difficulties that sometimes escape the engineer at the beginning of a project,
but which risk to hit them before the end.
</p>



<h2 id="Standards"><span class="section-number">1.1.</span> Standards and Norms</h2>
<p>
Most standards used by Apache <abbr title="Spatial Information System">SIS</abbr> have been devised by the <a href="http://www.opengeospatial.org">Open Geospatial Consortium</a> (<abbr>OGC</abbr>),
sometimes in collaboration with the <a href="http://www.iso.org">International Organization for Standardization</a> (<abbr>ISO</abbr>).
Some <abbr>ISO</abbr> standards themselves become European standards via the <a href="http://inspire.jrc.ec.europa.eu">INSPIRE Directive</a>.
These standards offer two key features:
</p>
<ul>
<li>
Allowing a community to make its information public in such a way that outside individuals or systems can discover it.
</li>
<li>
Transferring information from one community to another while preserving its semantics,
even if the two communities use very different internal representations.
</li>
</ul>
<p>
These standards are made available to the international community for free,
as <a href="http://www.opengeospatial.org/standards/is">specifications (<abbr title="Portable Document Format">PDF</abbr> files)</a> or
as <a href="http://schemas.opengis.net/gml/3.3/">schemas (<abbr title="XML Schema Definition">XSD</abbr> files)</a>.
Standardization organizations do not create software; to obtain an implementation of these specifications,
users must choose one of the compliant products available on the market, or develop their own solutions.
Such voluntary compliance with these specifications allow independent communities to more easily exchange geographic information.
</p>



<details>
<summary>More about standardization process</summary>
<article id="OGC-process">
<header>
<h1><abbr>OGC</abbr> Standardization Process</h1>
</header>
<p>
The work of the <abbr title="Open Geospatial Consortium">OGC</abbr> is done by email, teleconferences, and at <a href="http://www.opengeospatial.org/event?category=ogctcpc">in-person meetings</a>.
The <abbr>OGC</abbr> organizes four meetings per year, each lasting five days, and hosted by member organizations that sponsor the event (companies, universities, research centres, <i>etc</i>).
The host continent alternates between Europe and North America, with a growing presence in Asia since 2011.
These meetings are usually attended by between 50 and 100 participants from among the hundreds of members of the <abbr>OGC</abbr>.
Some participants are present at almost all the meetings, forming the pillars of the organization.
The meetings of the <abbr>OGC</abbr> offer opportunities for exchange among members from diverse backgrounds.
</p><p>
The creation of a <abbr>OGC</abbr> standard begins with a gathering of organizations or individuals with a common interest in an issue.
A working group is proposed as a <i>Domain Working Group</i> (<abbr>DWG</abbr>) or as a <i>Standard Working Group</i> (<abbr>SWG</abbr>).
<abbr>DWG</abbr>s are open to all members of the <abbr>OGC</abbr>,
while <abbr>SWG</abbr>s require that their participants enter into an agreement not to hinder the distribution of the standard through intellectual property claims.
</p>

<h2 id="OGC-SWG">Standard Working Group (<abbr>SWG</abbr>) Procedures</h2>
<p>
In order to be accepted, a standardization project must be supported by a minimum number of members belonging to distinct organizations.
These founding members draft a charter defining the objectives of the <abbr>SWG</abbr>,
which must be approved by the Technical Committee of the <abbr title="Open Geospatial Consortium">OGC</abbr>.
Each founding member is endowed with the right to vote, with a limit of one voting member per organization.
Each new member that wishes to join the <abbr>SWG</abbr> after its creation is granted the role of observer,
and receives on request the right to vote after several months of observation.
</p><p>
A <abbr>SWG</abbr> may contain several dozen members, but the volunteers performing the bulk of the work are usually fewer.
Their proposals are submitted to the entire membership of the group, who may accept them by unanimous consent.
Any objections must be debated, and an alternative proposed.
<abbr>SWG</abbr>s usually try to debate an issue until a consensus emerges rather than move ahead despite negative votes,
even if those opposed are in a minority.
The decisions of the group are then integrated into the specifications by a member who assumes the role of editor.
</p><p>
As far as possible, the working group must structure the specifications as a core around which various extensions might be built.
A series of tests must accompany the standard, allowing implementations to be classified by the level of test passed.
There must be at least one <i>reference implementation</i> that passes all the tests in order to demonstrate that the standard is usable.
</p><p>
When the standard is considered ready, the <abbr>SWG</abbr> votes on a motion proposing its submission to a vote by the higher authorities of the <abbr>OGC</abbr>.
This process takes several months. There is a faster process for approving <i>de facto</i> standards, but it is applied sparingly.
</p>

<h2 id="OGC-OAB">The Architecture Board (<abbr>OAB</abbr>) and the Technical Committee (<abbr>TC</abbr>)</h2>
<p>
All proposals for standards are first examined by the <abbr title="Open Geospatial Consortium">OGC</abbr> Architecture Board (<abbr>OAB</abbr>).
This board ensures that the standard conforms to the requirements of the <abbr>OGC</abbr> in form,
modularization, and in terms of integration with other standards.
If the <abbr>OAB</abbr> approves it, the standard is next submitted to a vote by the members of the Technical Committee (<abbr>TC</abbr>).
This committee consists of the principal members of the <abbr>OGC</abbr>, and only they are capable of granting final approval.
If approved, the standard is made publicly available for comments during a period of several months.
At the end of this period, the <abbr title="Standard Working Group">SWG</abbr> must examine and respond to each comment.
The eventual modifications of the standard are submitted to the <abbr>OAB</abbr>, then the standard is published in its final form.
This distribution is announced in a press release by the <abbr>OGC</abbr>.
</p><p>
Certain members of the <abbr title="Open Geospatial Consortium">OGC</abbr> and the <abbr title="Technical Committee">TC</abbr>
also act as liaisons with the International Organization for Standardization (<abbr>ISO</abbr>).
Cooperation between the two organizations goes two ways:
the <abbr>OGC</abbr> adopts the <abbr>ISO</abbr> standards as a foundation on which to develop new standards,
and certain <abbr>OGC</abbr> standards become <abbr>ISO</abbr> standards.
</p>

<h2 id="OGC-RFC">Procedure for the Submission of Proposals for Modification</h2>
<p>
All users, whether or not they are members of the Open Geospatial Consortium, may propose modifications to <abbr title="Open Geospatial Consortium">OGC</abbr> standards.
A list of current proposals for changes, along with a form for submitting new proposals, is <a href="http://www.opengeospatial.org/standards/cr">available online</a>.
Each proposal is reviewed by the <abbr title="Standard Working Group">SWG</abbr>.
</p><p>
Some working groups use other parallel systems for submissions, for example GitHub merge requests, hosted outside of the structures of the <abbr>OGC</abbr>.
</p>
</article>
</details>



<p>
Besides these formal standardization organizations, there are organizations that are not officially dedicated
to the creation of standards, but whose work has largely been adopted as <i>de facto</i> standards.
In particular, the <a href="http://www.epsg.org">EPSG</a> database offers numeric codes which allow the easy identification of a
Coordinates Reference System (<abbr>CRS</abbr>) among <a href="../../tables/CoordinateReferenceSystems.html">several thousand</a>.
This database is offered by petroleum companies that have an interest in ensuring their explorations are conducted in the correct place,
even when using map produced by another party.
Other examples of <i>de facto</i> standards include <a href="http://geotiff.osgeo.org">GeoTIFF</a> for data distributed on a grid (such as images),
and <a href="http://en.wikipedia.org/wiki/Shapefile">Shapefile</a> for vector data (such as geometric shapes).
</p><p>
<abbr>OGC</abbr> standards are specified in several dozen documents.
Each document outlines a service — for example, the transformation of coordinates.
The function of each service is described by a collection of object classes and their interactions.
These elements are illustrated by <abbr>UML</abbr> (Unified Modeling Language) diagrams in specifications called “abstracts”.
<a href="http://www.opengeospatial.org/standards/as">Abstract specifications</a> do not refer to any specific computer language.
Their concepts may be applied more or less directly to a programming language, a database or an <abbr>XML</abbr> schema.
There is always an element of arbitrariness in the method of applying an abstract specification,
given that adjustments are often necessary to take into account the constraints or conventions of the target language.
Certain data structures only exist in a few languages — for example, unions that exist in C/C++ but not in Java.
</p>



<details>
<summary>More about “implementation specifications”</summary>
<article id="implementation-standard">
<header>
<h1>Historical note</h1>
</header>
<p>
At the turn of the millennium, the abstract specifications were explicitly concretized in <i>implementation specifications</i>.
The term “implementation” is used here in the sense of all types of interfaces (Java or others) derived from
<abbr title="Unified Modeling Language">UML</abbr> diagrams, and not implementations in the Java sense.
Such specifications existed for <abbr title="Structured Query Language">SQL</abbr>,
<abbr title="Common Object Request Broker Architecture">CORBA</abbr>, <abbr title="Component Object Model">COM</abbr>, and Java languages.
As these languages are capable of executing procedures, the specifications of this period define not only data structures,
but also operations that apply to these structures.
</p><p>
Thereafter, enthusiasm for “Web 2.0” increased interest for <abbr>XML</abbr> over other languages.
Older implementation specifications were deprecated,
and <abbr title="XML Schema Definition">XSD</abbr> schemas became the main concretization of abstract specifications.
Even the way abstract specifications are designed has evolved: they are less likely to define operations, and so what remains is closer to descriptions of database schemas.
Some operations that were defined in older standards now appear, in another form, in web service specifications.
Finally, the term “implementation specification” has been deprecated, to be subsumed under the term “<abbr title="Open Geospatial Consortium">OGC</abbr> standard.”
But despite their depreciation, <a href="http://www.opengeospatial.org/docs/retired">old implementation specifications</a> remain useful to programs in Java, because:
</p>
<ul>
<li>Their simpler models, applied to the same concepts, are helpful in understanding new specifications.</li>
<li>They sometimes define easy ways to perform common tasks, where the newer specifications limit themselves to general cases.</li>
<li>As operations are more often omitted from the newer specifications, the old ones remain a useful supplement when defining <abbr title="Application Programming Interface">API</abbr>s.</li>
</ul>
<p>
The Apache <abbr title="Spatial Information System">SIS</abbr> project is based on the most recent specifications,
drawing from the archives of the <abbr>OGC</abbr> to complete certain abstract standards or make them more usable.
Some old definitions are preserved as “convenience methods”, not always bringing new functionality, but facilitating the practical use of a library.
</p>
</article>
</details>
<p>
The following table lists the main norms used by the project.
Many norms are published both as <abbr>ISO</abbr> standards and as <abbr>OGC</abbr> standards,
and their corresponding names are listed next to one another in the first two columns.
The “implementation specifications” section lists specifications that bring few new concepts compared to abstract specifications,
but detail how to represent those concepts in specific environments like <abbr>XML</abbr> documents.
Standards that are deprecated but still partially used appear <s>struck through</s>.
Finally, GeoAPI packages will be introduced in upcoming chapters.
</p>
<table>
<caption>Main Standards Related to the Apache <abbr>SIS</abbr> project</caption>
<tr>
<th><abbr>ISO</abbr> Norm</th>
<th><abbr>OGC</abbr> Norm</th>
<th>Titre</th>
<th>GeoAPI package</th>
<th>Apache SIS package</th>
</tr><tr>
<td class="separator" colspan="5">Abstract Specifications</td>
</tr><tr>
<td><abbr>ISO</abbr> 19103</td>
<td/>
<td><i>Conceptual schema language</i></td>
<td><code class="GeoAPI">org.opengis.util</code></td>
<td><code class="SIS">org.apache.sis.util.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-1</td>
<td>Topic 11</td>
<td><i>Metadata</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19115-2</td>
<td/>
<td><i>Metadata — extensions for imagery and gridded data</i></td>
<td><code class="GeoAPI">org.opengis.metadata</code></td>
<td><code class="SIS">org.apache.sis.metadata.iso</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111</td>
<td>Topic 2</td>
<td><i>Spatial referencing by coordinates</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19111-2</td>
<td/>
<td><i>Referencing — extension for parametric values</i></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19108</td>
<td/>
<td><i>Temporal Schema</i></td>
<td><code class="GeoAPI">org.opengis.temporal</code></td>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19107</td>
<td>Topic 1</td>
<td><i>Feature geometry</i></td>
<td><code class="GeoAPI">org.opengis.geometry</code></td>
<td><code class="SIS">org.apache.sis.geometry</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19101</td>
<td>Topic 5</td>
<td><i>Features</i></td>
<td><code class="GeoAPI">org.opengis.feature</code></td>
<td><code class="SIS">org.apache.sis.feature</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19123</td>
<td>Topic 6</td>
<td><i>Schema for coverage geometry and functions</i></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19156</td>
<td>Topic 20</td>
<td><i>Observations and measurements</i></td>
<td><code class="GeoAPI">org.opengis.observation</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Implementation Specifications</td>
</tr><tr>
<td><abbr>ISO</abbr> 19139</td>
<td/>
<td><i>Metadata <abbr>XML</abbr> schema implementation</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19136</td>
<td>OGC 07-036</td>
<td><i>Geography Markup Language (<abbr>GML</abbr>) Encoding Standard</i></td>
<td/>
<td><code class="SIS">org.apache.sis.xml</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 19162</td>
<td>OGC 12-063</td>
<td><i>Well-known text representation of coordinate reference systems</i></td>
<td/>
<td><code class="SIS">org.apache.sis.io.wkt</code></td>
</tr><tr>
<td><abbr>ISO</abbr> 13249</td>
<td/>
<td><i><abbr>SQL</abbr> spatial</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-009</s></td>
<td><s><i>Coordinate Transformation Services</i></s></td>
<td><code class="GeoAPI">org.opengis.referencing</code></td>
<td><code class="SIS">org.apache.sis.referencing</code></td>
</tr><tr>
<td/>
<td><s><abbr>OGC</abbr> 01-004</s></td>
<td><s><i>Grid Coverage</i></s></td>
<td><code class="GeoAPI">org.opengis.coverage</code></td>
<td><code class="SIS">org.apache.sis.coverage</code></td>
</tr><tr>
<td/>
<td><abbr>SLD</abbr></td>
<td><i>Styled Layer Descriptor</i></td>
<td><code class="GeoAPI">org.opengis.style</code></td>
<td/>
</tr><tr>
<td class="separator" colspan="5">Web Services</td>
</tr><tr>
<td><abbr>ISO</abbr> 19128</td>
<td><abbr>WMS</abbr></td>
<td><i>Web Map Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WMTS</abbr></td>
<td><i>Web Map Tile Service</i></td>
<td/>
<td/>
</tr><tr>
<td><abbr>ISO</abbr> 19142</td>
<td><abbr>WFS</abbr></td>
<td><i>Web Feature Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WCS</abbr></td>
<td><i>Web Coverage Service</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>WPS</abbr></td>
<td><i>Web Processing Service</i></td>
<td/>
<td/>
</tr>
<tr>
<td/>
<td>Open<abbr>LS</abbr></td>
<td><i>Location Services</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SWE</abbr></td>
<td><i>Sensor Web Enablement</i></td>
<td/>
<td/>
</tr><tr>
<td/>
<td><abbr>SOS</abbr></td>
<td><i>Sensor Observation Service</i></td>
<td/>
<td/>
</tr>
</table>



<h2 id="About"><span class="section-number">1.2.</span> Conventions Used in This Guide</h2>
<p>
Standards sometimes favour the application of certain generic terms to particular contexts,
which may differ from the context in which other communities use these terms.
For example, the terms <i>domain</i> and <i>range</i> may apply to arbitrary functions in order to designate
a set of possible values of inputs and outputs respectively.
But the functions to which they are applied by certain <abbr>ISO</abbr> standards are not the same as the functions to which they are applied by other libraries.
For example, <abbr>ISO</abbr> 19123 applies these terms to <code class="OGC">CV_Coverage</code> objects,
seen as functions in which the <i>domain</i> is the set of spatio-temporal coordinates encompassed by the data,
and the <i>range</i> is the set of values encompassed.
But <abbr title="University Corporation for Atmospheric Research">UCAR</abbr>'s <abbr title="Network Common Data Form">NetCDF</abbr> library
applies these terms instead to the function of converting pixel indices (its <i>domain</i>) to spatial-temporal coordinates (its <i>range</i>).
Thus the <abbr>UCAR</abbr> library's <i>range</i> may be the <i>domain</i> of <abbr>ISO</abbr> 19123.
</p><p>
The Apache <abbr title="Spatial Information System">SIS</abbr> library prefers as much as possible to use terms in the sense of <abbr title="Open Geospatial Consortium">OGC</abbr> and <abbr>ISO</abbr> norms.
Particular care must be taken, however, with the interfaces between <abbr>SIS</abbr> and certain other external libraries,
in order to reduce the risk of confusion.
</p>



<h3 id="CodeColors"><span class="section-number">1.2.1.</span> Code Colors</h3>
<p>
The elements defined in a computer language, such as classes and methods in Java or elements in an <abbr>XML</abbr> document,
appear in monospaced font.
In order to facilitate an understanding of the relationships between Apache <abbr title="Spatial Information System">SIS</abbr> and the standards, these elements are also represented using the following colour codes:
</p>
<ul>
<li>
Elements defined in the <abbr title="Open Geospatial Consortium">OGC</abbr> standard
or the <abbr title="International Organization for Standardization">ISO</abbr> standard appear in blue.
Example: <code class="OGC">CD_Ellipsoid</code>.
</li>
<li>
Elements defined in GeoAPI appear in green.
Example: <code class="GeoAPI">Ellipsoid</code>.
</li>
<li>
Elements defined in Apache <abbr title="Spatial Information System">SIS</abbr> appear in brown.
Example: <code class="SIS">DefaultEllipsoid</code>.
</li>
<li>
Other elements, such as those in standard Java, are left in black.
Example: <code>String</code>.
</li>
</ul>
<p>
Text in gray boxes are for information purpose only and can be ignored.
</p>
</section>
<section>
<header>
<h1 id="GeoAPI"><span class="section-number">2.</span> GeoAPI</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Foreword">Previous chapter</a></div><div class="next-chapter"><a href="#Utilities">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#UML-annotation">Mapping Given by @UML Annotations</a><ul>
<li><a href="#MappingToJDK">Implicit Mapping to Standard JDK</a></li></ul></li>
<li><a href="#GeoAPI-implementation">Interface implementations</a></li></ul></nav>
<p>
The <a href="http://www.geoapi.org">GeoAPI</a> project offers a set of Java interfaces for geospatial applications.
In a series of <code class="GeoAPI">org.opengis.*</code> packages, GeoAPI defines structures representing metadata,
coordinate reference systems and operations that perform cartographic projections.
In a part that is not yet standardized — called <i>pending</i> — GeoAPI defines structures that represent geo-referenced images,
geometries, filters that can be applied to queries, and other features.
These interfaces closely follow the specifications of the <abbr title="Open Geospatial Consortium">OGC</abbr>, while interpreting and adapting them
to meet the needs of Java developers — for example, conforming with naming conventions.
These interfaces benefit both client applications and libraries:
</p>
<ul>
<li><p>
Developers of client applications benefit from the greater knowledge base available on the Internet
(due to the many publications related to <abbr>OGC</abbr> standards), as well as increased interoperability.
Interoperability is facilitated by a better separation between applications that <em>call</em> GeoAPI functions,
and libraries that <em>implement</em> GeoAPI.
The separation is similar to that offered by the <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/"><abbr title="Java DataBase Connectivity">JDBC</abbr></a> (<i>Java Database Connectivity</i>) interfaces of standard Java.
Using the interfaces' <abbr title="Application Programming Interface">API</abbr>, developers can ignore the underlying implementation.
For example, they can perform cartographic projections with the help of the <a href="http://www.geoapi.org/geoapi-proj4/index.html">Proj.4</a> library, or the Apache <abbr title="Spatial Information System">SIS</abbr> library,
without having to change their programs when they change libraries.
</p></li>
<li><p>
The developers of libraries inherit the expertise of the specifications' authors, via the models that represent interfaces.
GeoAPI also provides a framework within which developers can prioritize the implementation of the features they most need,
while leaving the remaining features as extension points for future developments.
For example, clients can call a GeoAPI function even if it is not yet supported by the library,
and simply get a null value until a new version of the library returns a relevant value.
</p></li>
</ul>


<details>
<summary>More about the GeoAPI project</summary>
<article>
<header>
<h1>GeoAPI project history</h1>
</header>
<p>
In 2001, the Open GIS Consortium (the former name of the Open Geospatial Consortium) published
<a href="http://www.opengeospatial.org/standards/ct"><abbr title="Open Geospatial Consortium">OGC</abbr> implementation specification 01-009:
<cite>Coordinate Transformation Services</cite></a>.
This specification, developed by the Computer Aided Development Corporation (Cadcorp),
was accompanied by <abbr title="Component Object Model">COM</abbr>, <abbr title="Common Object Request Broker Architecture">CORBA</abbr>, and Java interfaces.
At this time, the wave of web services had not yet eclipsed classical programming interfaces.
The interfaces of the <abbr>OGC</abbr> did anticipate a networked world,
but invested rather — in the case of Java — in <abbr>RMI</abbr> (<i>Remote Method Invocation</i>) technology.
As the GeoAPI project did not yet exist, we retroactively designate these historical interfaces “<a href="http://www.geoapi.org/0.1/index.html">GeoAPI 0.1</a>”.
These interfaces already used the package name <code class="GeoAPI">org.opengis</code>, which would be adopted by GeoAPI.
</p><p>
In 2002, developers of free projects launched a
<a href="http://web.archive.org/web/20030509104308/http://digitalearth.org/story/2002/10/10/55046/206">call for the creation of a geospatial <abbr title="Application Programming Interface">API</abbr></a>.
The initial proposal attracted the interest of at least five free projects.
The project was created using <a href="http://sourceforge.net/projects/geoapi/">SourceForge</a>,
which has since hosted the source code in a <a href="http://www.geoapi.org/source-repository.html">Subversion repository</a>.
It was then that the project assumed the name “GeoAPI”, and used the interfaces of the <abbr>OGC</abbr> specification 01-009 as a starting point.
</p><p>
A few months later, the <abbr>OGC</abbr> launched the <a href="http://www.opengeospatial.org/standards/go"><abbr>GO</abbr>-1: <i>Geographic Objects</i></a> project,
which pursued goals similar to those of GeoAPI.
In the meantime, the <abbr>OGC</abbr> abandonned some of their specifications in favor of <abbr title="International Organization for Standardization">ISO</abbr> standards.
GeoAPI and <abbr>GO-1</abbr> worked jointly to rework the GeoAPI interfaces and base them on the new <abbr>ISO</abbr> norms.
Their first interation, <a href="http://www.geoapi.org/1.0/index.html">GeoAPI 1.0</a>,
served as a starting point for the first draft of the <abbr>OGC</abbr> specification 03-064 by the <abbr>GO</abbr>-1 working group.
The final version of this specification became an <abbr>OGC</abbr> standard in 2005,
and <a href="http://www.geoapi.org/2.0/index.html">GeoAPI 2.0</a> was published at that time.
</p><p>
The <abbr>GO</abbr>-1 project was largely supported by a company called <i>Polexis</i>.
Its acquisition by <i>Sys Technology</i>, and the change in priorities under the new owners,
brought a halt to the <abbr>GO</abbr>-1 project, which in turn slowed development on GeoAPI.
In order to resume development, a new working group entitled “GeoAPI 3.0” was created at the <abbr>OGC</abbr>.
This group took a narrower focus compared to GeoAPI 2.0, concentrating on the most stable interfaces, and putting the others
— such as geometries — in a module entitled “<a href="http://www.geoapi.org/geoapi-pending/index.html">pending</a>”, for future consideration.
<a href="http://www.geoapi.org/3.0/index.html">GeoAPI 3.0</a> became an <a href="http://www.opengeospatial.org/standards/geoapi"><abbr>OGC</abbr> standard</a> in 2011.
This version was the first to be deployed in the <a href="http://search.maven.org/#search|ga|1|geoapi">Maven central repository</a>.
</p>
</article>
</details>

<p>GeoAPI interfaces are sometime generated from other files provided by <abbr>OGC</abbr>, like <abbr title="XML Schema Definition">XSD</abbr> files.
But there is always a manual revision, and often modifications compared to automatically generated Java files.
Deviations from the standards are documented in each affected class and method.
Each mention of a deviation is also collected on a <a href="http://www.geoapi.org/3.0/javadoc/departures.html">single page</a> in order to provide an overview.
Since these deviations blur the relationships between the standards and certain Java interfaces,
the correspondence between these languages is explained by <code class="GeoAPI">@UML</code> annotations and property files described in the following section.
</p>

<details>
<summary>More about the reasons for manual definition of Java interfaces</summary>
<article id="SpecificationToInterfaces">
<header>
<h1>From <abbr title="Open Geospatial Consortium">OGC</abbr> specifications to Java interfaces</h1>
</header>
<p>
It is possible to automatically generate Java interfaces <abbr>OGC</abbr> standards using existing tools.
One of the most commonly-used approaches is to transform <a href="http://schemas.opengis.net/gml/3.3/"><abbr title="XML Schema Definition">XSD</abbr> schemas</a>
into Java interfaces using command line utility <code>xjc</code>.
As this utility is included in most Java distributions (it is one of the <a href="http://jaxb.java.net"><abbr>JAXB</abbr></a> tools),
this approach is favoured by many projects found on the Internet.
Other approaches use tools integrated into the Eclipse Development Environment,
which is based on <abbr title="Unified Modeling Language">UML</abbr> schemas rather than <abbr>XSD</abbr> ones.
</p><p>
A similar approach was attempted in the early days of the GeoAPI project, but was quickly abandoned.
We favor a manual approach for the following reasons:
</p>
<ul>
<li>
<p>
Some <abbr>XSD</abbr> schemas are much more verbose than the original <abbr>UML</abbr> schemas.
Converting from <abbr>XSD</abbr> schemas introduces — at least in the case of metadata —
almost double the number of interfaces actually defined by the standard, without adding any new features.
<abbr>XSD</abbr> schemas also define attributes specific to <abbr>XML</abbr> documents (<code class="OGC">id</code>,
<code class="OGC">uuid</code>, <code>xlink:href</code>, <i>etc.</i>), that do not exist in the original <abbr>UML</abbr> diagrams,
and which we do not necessarily wish to expose in a Java <abbr title="Application Programming Interface">API</abbr>.
Converting from <abbr>UML</abbr> schemas avoids this problem, but tools capable of performing this operation are less common.
</p>
<div class="example"><p><b>Example:</b>
<abbr>XSD</abbr> metadata schemas insert a <code class="OGC">&lt;gmd:CI_Citation&gt;</code> element
inside a <code class="OGC">&lt;gmd:citation&gt;</code>,
a <code class="OGC">&lt;gmd:CI_OnlineResource&gt;</code> element inside a <code class="OGC">&lt;gmd:onlineResource&gt;</code>,
and so on for the hundreds of classes defined by <abbr title="International Organization for Standardization">ISO</abbr> 19115 standard.
This redundancy is certainly not necessary in a Java program.
</p></div>
</li>
<li>
<p>
<abbr>OGC</abbr> standards use different naming conventions than Java.
In particular, the names of almost all <abbr>OGC</abbr> classes begin with a two-letter prefix,
such as <code class="OGC">MD_Identifier</code>.
This prefixes fulfill the same role as package names in Java.
GeoAPI adapts this practice by using interface names without prefixes and placing these interfaces in packages corresponding to the prefixes,
but with more descriptive names.
Occasionally we also change the names; for example, to avoid acronyms, or to conform to an established convention such as JavaBeans.
</p>
<div class="example"><p><b>Example:</b>
The <abbr>OGC</abbr> class <code class="OGC">MD_Identifier</code> becomes the
<code class="GeoAPI">Identifier</code> interface in the <code class="GeoAPI">org.opengis.metadata</code> package.
The <abbr>OGC</abbr> class <code class="OGC">SC_CRS</code> becomes the <code class="GeoAPI">CoordinateReferenceSystem</code> interface,
and the <code class="OGC">usesDatum</code> association becomes a <code class="GeoAPI">getDatum()</code> method,
rather than the “<code>getUsesDatum()</code>” that would result from an automatic conversion tool.
We do not allow programs to blindly apply rules that ignore the conventions of the community whose schemas we translate.
</p></div>
</li>
<li>
<p>
The standards may contain structures that do not have a direct equivalent in Java,
such as unions similar to what we would find in C/C++.
The strategy used to obtain an equivalent feature in Java depends on the context:
multiple inheritance of interfaces, modification of the hierarchy, or simply omitting the union.
These decisions are made case-by-case based on a needs analysis.
</p>
<div class="example"><p><b>Example:</b>
<abbr>ISO</abbr> 19111 standard defines different types of coordinate systems, such as spherical, cylindrical, polar or Cartesian.
It then defines several <em>subsets</em> of these types of coordinate systems systems.
These subsets, represented by unions, serve to specify that a class may only be associated with a particular type of coordinate system.
For example, a union of types may be associated with an image, named <code class="OGC">CS_ImageCS</code>,
which can only contain <code class="OGC">CS_CartesianCS</code> and <code class="OGC">CS_AffineCS</code>.
In this case, we get the desired effect in Java through a modification of the hierarchy of classes:
we define the <code class="GeoAPI">CartesianCS</code> interface as a specialization of <code class="GeoAPI">AffineCS</code>,
which is semantically correct.
But it is not possible to apply a similar strategy to other unions without violating the semantics.
</p></div>
</li>
<li>
<p>
Several specifications overlap.
GeoAPI performs the work of integration by replacing some duplicate structures with references to equivalent structures from the standards that best represent them.
</p>
<div class="example"><p><b>Example:</b>
<abbr>ISO</abbr> 19115:2003 standard, which defines metadata structures,
also attempts to describe a few structures representing coordinate reference systems (<abbr title="Coordinate Reference System">CRS</abbr>).
Yet these are also the focus of another standard: <abbr>ISO</abbr> 19111.
At the same time, <abbr>ISO</abbr> 19111:2007 states in section 3 that it reuses all of the elements of
<abbr>ISO</abbr> 19115:2003 except <code class="OGC">MD_CRS</code> and its components.
GeoAPI interfaces reduce the redundancy by applying the exclusion recommended by <abbr>ISO</abbr> 19111 to the entire project.
</p></div>
</li>
<li>
<p>
The complexity of some standards have increased for historical reasons rather than technical ones, related to the standardization process.
GeoAPI reduces the technical debt by designing interfaces with each element in its proper place,
regardless of the chronological order in which the standards were published.
</p>
<div class="example"><p><b>Exemple:</b>
<abbr>ISO</abbr> 19115-2 standard is an extension of <abbr>ISO</abbr> 19115-1 standard, adding image metadata structures.
These metadata were defined in a separate standard because they were not yet ready when the first part of the standard was published.
As it was not possible for administrative reasons to add attributes to already-published classes,
the new attributes were added in a sub-class bearing almost the same name.
Thus, <abbr>ISO</abbr> 19115-2 defines the class <code class="OGC">MI_Band</code>,
which extends the class <code class="OGC">MD_Band</code> from <abbr>ISO</abbr> 19115-1 by adding attributes that would have appeared
directly in the parent class if there were ready on time.
In GeoAPI, we have chosen to “repair” these anomalies by fusing these two classes into a single interface.
</p></div>
</li>
</ul>
</article>
</details>

<p id="GeoAPI-core">
GeoAPI is composed of many modules.
The <code class="GeoAPI">geoapi</code> and <code class="GeoAPI">geoapi-pending</code> modules
provide interfaces derived from <abbr>UML</abbr> schemas of international standards.
The conceptual model will be explained in detail in the chapters describing Apache <abbr title="Spatial Information System">SIS</abbr> implementation.
However, we can get an overview of its content by consulting the page listing the mapping between
<a href="http://www.geoapi.org/3.0/javadoc/content.html">GeoAPI methods and the standards where they come from</a>.
</p>

<details>
<summary>More about GeoAPI modules</summary>
<article id="GeoAPI-modules">
<h1>GeoAPI Modules</h1>
<p>
The GeoAPI project consists of a standardized part (<code class="GeoAPI">geoapi</code>)
and an experimental part (<code class="GeoAPI">geoapi-pending</code>).
As these two parts are mutually exclusive, users must take care not to mix them in the same project.
This separation is guaranteed for all projects that depend only on the Maven central repository
(including the final versions of Apache <abbr title="Spatial Information System">SIS</abbr>),
as the <code class="GeoAPI">geoapi-pending</code> module is never deployed on this central repository.
By contrast, certain <abbr>SIS</abbr> development branches may depend on <code class="GeoAPI">geoapi-pending</code>.
</p>
<p>
GeoAPI modules are:
</p>
<ul>
<li><p>
<b><code class="GeoAPI">geoapi</code></b> — includes interfaces covered by the
<a href="http://www.opengeospatial.org/standards/geoapi">GeoAPI standard of the <abbr title="Open Geospatial Consortium">OGC</abbr></a>.
The final versions of Apache <abbr>SIS</abbr> depend on this module.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-pending</code></b> — contains a
<em>copy</em> of all interfaces in the <code class="GeoAPI">geoapi</code> module
(not a dependence) with additions that have not yet been approved as an <abbr>OGC</abbr> standard.
Some additions appear in interfaces normally defined by the <code class="GeoAPI">geoapi</code> module, hence the need to copy them.
Apache <abbr>SIS</abbr>'s development branches <code>jdk6</code>, <code>jdk7</code> and <code>jdk8</code> depend on this module,
but this dependence becomes a dependence on the <code class="GeoAPI">geoapi</code> standard module when the branches are merged to the trunk.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-conformance</code></b> — includes a JUnit test suite that developers may use to test their implementations.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-examples</code></b> — includes examples of relatively simple implementations.
These examples are placed in the public domain in order to encourage users to copy and adapt them to their needs if
Apache <abbr>SIS</abbr> services are unsuitable.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-proj4</code></b> — contains a partial implementation of <code class="GeoAPI">org.opengis.referencing</code>
packages as adaptors based on the C/C++ Proj.4 library.
This module may be used as an alternative to the <code class="SIS">sis-referencing</code> module for certain functions.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-netcdf</code></b> — contains a partial implementation of <code class="GeoAPI">org.opengis.referencing</code>
and <code class="GeoAPI">org.opengis.coverage</code> packages as adaptors based on the <abbr title="University Corporation for Atmospheric Research">UCAR</abbr> <abbr title="Network Common Data Form">NetCDF</abbr> library.
The series of tests in this module was developed in such a way as to be reusable for other projects.
Apache <abbr>SIS</abbr> uses them to test its own <code class="SIS">sis-netcdf</code> module.
</p></li>
<li><p>
<b><code class="GeoAPI">geoapi-openoffice</code></b> — contains an add-in for the OpenOffice.org office suite.
<!--
            Apache <abbr>SIS</abbr> offers its own add-in in the <code>sis-openoffice</code> module,
            but uses the same function names as the GeoAPI module in order to maintain some compatibility.
            -->
</p></li>
</ul>
</article>
</details>



<h2 id="UML-annotation"><span class="section-number">2.1.</span> Mapping Given by <code class="GeoAPI">@UML</code> Annotations</h2>
<p>
For each class, method and constant defined by an <abbr title="Open Geospatial Consortium">OGC</abbr> or <abbr title="International Organization for Standardization">ISO</abbr> standard,
GeoAPI indicates its provenance using annotations defined in the <code class="GeoAPI">org.opengis.annotation</code> package.
In particular, the <code class="GeoAPI">@UML</code> annotations indicates the standard,
the name of the element in that standard, and also its obligation.
For example, in the following code snippet, the first <code class="GeoAPI">@UML</code> code indicates that the Java interface that follows
(<code class="GeoAPI">ProjectedCRS</code>) is defined using the <code class="OGC">SC_ProjectedCRS</code> type of <abbr>ISO</abbr> 19111 standard.
The second <code class="GeoAPI">@UML</code> annotation, this time applied to the <code class="GeoAPI">getCoordinateSystem()</code> method,
indicates that this method is defined using the <code class="OGC">coordinateSystem</code> association of <abbr>ISO</abbr> 19111 standard,
and that this association is mandatory — meaning, in Java, that the method is not allowed to return a <code>null</code> value.
</p>

<pre><b>package</b> <code class="GeoAPI">org.opengis.referencing.crs</code>;

<code class="comment">/**
 * A 2D coordinate reference system used to approximate the shape of the earth on a planar surface.
 */</code>
@<code class="GeoAPI">UML</code>(specification=ISO_19111, identifier=<i>"<code class="OGC">SC_ProjectedCRS</code>"</i>)
<b>public</b> <b>interface</b> <code class="GeoAPI">ProjectedCRS</code> <b>extends</b> <code class="GeoAPI">GeneralDerivedCRS</code> {
    <code class="comment">/**
     * Returns the coordinate system, which must be Cartesian.
     */</code>
    @<code class="GeoAPI">UML</code>(obligation=MANDATORY, specification=ISO_19111, identifier=<i>"<code class="OGC">coordinateSystem</code>"</i>)
    <code class="GeoAPI">CartesianCS</code> <code class="GeoAPI">getCoordinateSystem()</code>;
}</pre>

<p>
Java reflection methods allow access to this information during the execution of an application.
This is useful for displaying UML identifiers for users familiar with <abbr>OGC</abbr> standards,
or for writing elements in an <abbr>XML</abbr> document.
Class <code class="SIS">org.apache.sis.util.iso.Types</code> provides static convenience methods
like <code class="SIS">getStandardName(Class)</code> for such operations.
For example the following code will display
“Standard name of type <code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> is <code class="OGC">SC_ProjectedCRS</code>”:
</p>

<pre>Class&lt;?&gt; type = <code class="GeoAPI">ProjectedCRS</code>.<b>class</b>;
System.out.println(<i>"Standard name of type "</i> + type.getName() + <i>" is "</i> + Types.getStandardName(type));</pre>

<p>
The <code class="SIS">Types​.forStandardName(String)</code> convenience method performs the reverse operation.
Applications who want to perform those operations without SIS convenience methods can follow indications
provided in a <a href="#UML-annotation-geoapi">separated chapter</a>.
</p>



<h3 id="MappingToJDK"><span class="section-number">2.1.1.</span> Implicit Mapping to Standard <abbr>JDK</abbr></h3>
<p>
Some classes and methods have neither an <code class="GeoAPI">@UML</code> annotation, nor an entry in the <code class="GeoAPI">class-index.properties</code> file.
They are either extensions of GeoAPI, or else types defined in other libraries, such as standard <abbr title="Java Development Kit">JDK</abbr>.
In this last case, the mapping to <abbr title="International Organization for Standardization">ISO</abbr> standards is implicit.
The following table describes this mapping for <abbr>ISO</abbr> 19103 types.
Java's primitive types are preferred when applicable,
but where necessary their wrappers are used in order to authorize null values.
</p>
<table>
<caption>Mapping between <abbr>ISO</abbr> 19103 and <abbr>JDK</abbr> types</caption>
<tr>
<th><abbr>ISO</abbr> type</th>
<th><abbr>JDK</abbr> type</th>
<th>Remarks</th>
</tr>
<tr>
<td class="separator" colspan="2">Numbers</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Integer</code></td>
<td><code>int</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Integer</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Integer</code> (in some cases)</td>
<td><code>long</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Long</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Real</code></td>
<td><code>double</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Double</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Decimal</code></td>
<td><code>java.math.BigDecimal</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Number</code></td>
<td><code>java.lang.Number</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Texts</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">FreeText</code></td>
<td>(no equivalent)</td>
<td class="leftBorder">See <code class="GeoAPI">org.opengis.util.InternationalString</code> below.</td>
</tr>
<tr>
<td><code class="OGC">CharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder">Often <code class="GeoAPI">org.opengis.util.InternationalString</code> (see below).</td>
</tr>
<tr>
<td><code class="OGC">LocalisedCharacterString</code></td>
<td><code>java.lang.String</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence&lt;Character&gt;</code></td>
<td><code>java.lang.CharSequence</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Character</code></td>
<td><code>char</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Dates and hours</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Date</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Time</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">DateTime</code></td>
<td><code>java.util.Date</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Collections</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Collection</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Bag</code></td>
<td><code>java.util.Collection</code></td>
<td class="leftBorder">A <code class="OGC">Bag</code> is similar to a
<code class="OGC">Set</code> without being restricted by uniqueness.</td>
</tr>
<tr>
<td><code class="OGC">Set</code></td>
<td><code>java.util.Set</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Sequence</code></td>
<td><code>java.util.List</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Dictionary</code></td>
<td><code>java.util.Map</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">KeyValuePair</code></td>
<td><code>java.util.Map.Entry</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td class="separator" colspan="2">Enumerations</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Enumeration</code></td>
<td><code>java.lang.Enum</code></td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">CodeList</code></td>
<td>(no equivalent)</td>
<td class="leftBorder">See <code class="GeoAPI">org.opengis.util.CodeList</code> below.</td>
</tr>
<tr>
<td class="separator" colspan="2">Various</td>
<td class="leftBorder"/>
</tr>
<tr>
<td><code class="OGC">Boolean</code></td>
<td><code>boolean</code></td>
<td class="leftBorder">Sometimes <code>java.lang.Boolean</code> for optional attributes.</td>
</tr>
<tr>
<td><code class="OGC">Any</code></td>
<td><code>java.lang.Object</code></td>
<td class="leftBorder"/>
</tr>
</table>

<p>
The nearest equivalent for <code class="OGC">CharacterString</code> is the <code>String</code> class,
but GeoAPI often uses the <code class="GeoAPI">InternationalString</code> interface, allowing the client to choose the language.
For example, it is useful on a server that simultaneously provides pages in multiple languages.
By returning translations when objects are used rather than at the time of their creation,
we allow the <abbr title="Spatial Information System">SIS</abbr> library to provide the same instances of <code class="GeoAPI">Metadata</code>
or <code class="GeoAPI">Coverage</code> (for example) for the same data, regardless of the client's language.
Translations may be made on the fly with the help of the application's <code>ResourceBundle</code>,
or may be provided directly with the data (as in the case of <code class="GeoAPI">Metadata</code>).
</p>
<p>
An <code class="OGC">Enumeration</code> corresponds to an <code>Enum</code> in Java.
Both define all authorized values, without allowing the user to add any.
A <code class="OGC">CodeList</code> is similar to an enumeration, except that users may add their own items.
Standard <abbr>JDK</abbr> does not offer this possibility.
GeoAPI defines an abstract <code class="GeoAPI">CodeList</code> class that reproduces some of the functionality of <code>Enum</code> while being extensible.
Extensions are made available by the <code class="GeoAPI">valueOf(String)</code> static method, which, in contrast to <code>Enum</code>,
creates new instances if the name provided does not correspond to the name of an existing instance.
</p>

<pre><code class="GeoAPI">MediumName</code> cdRom  = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">CD_ROM;</code>
<code class="GeoAPI">MediumName</code> usbKey = <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>); <code class="comment">// There is no constraint on this value.
</code><b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">CD_ROM</code>"</i>)  == cdRom  : <i>"valueOf must return existing constants."</i>;
<b>assert</b> <code class="GeoAPI">MediumName</code>.<code class="GeoAPI">valueOf</code>(<i>"<code class="GeoAPI">USB_KEY</code>"</i>) == usbKey : <i>"valueOf must cache the previously requested values."</i>;</pre>



<h2 id="GeoAPI-implementation"><span class="section-number">2.2.</span> Interface implementations</h2>
<p>
Apache SIS implements most GeoAPI interfaces by a class of the same name than the interface
but prefixed by “<code>Abstract</code>”, “<code>Default</code>” or “<code>General</code>”.
Apache SIS classes prefixed by “<code>Default</code>” can be instantiated directly by a
<code>new DefaultXXX(…)</code> statement or by a call to the <code>createXXX(…)</code> method in a factory.
</p>
<div class="example"><b>Example:</b> to represent a projected coordinate reference system (Mercator, Lambert, <i>etc</i>):
<ul>
<li><code class="GeoAPI">org.opengis.referencing.crs.ProjectedCRS</code> is the GeoAPI interface derived from ISO 19111 standard, and</li>
<li><code class="SIS">org.apache.sis.referencing.crs.DefaultProjectedCRS</code> is the implementation provided by Apache SIS.</li>
</ul>
An instance can be created by:
<ul>
<li><code>ProjectedCRS crs = new DefaultProjectedCRS(…)</code>, ou</li>
<li><code>ProjectedCRS crs = CRSFactory​.createProjectedCRS(…)</code>.</li>
</ul>
Both approaches expect the same arguments (omitted in this example for brevity).
</div>
<p>
In the default Apache SIS configuration, using <code>CRSFactory​.createXXX(…)</code> or <code>new DefaultXXX(…)</code>
is almost the same except that <code class="GeoAPI">Factory</code> may return existing instances instead than creating new instances,
and that exceptions thrown in case of invalid arguments are different types.
In more advanced configurations, using <code class="GeoAPI">Factory</code> reduces the
<a href="#ServiceLoader">direct dependencies toward Apache SIS</a>
and allows inversion of control.
</p><p>
The “<code>General</code>” prefix is sometime used instead than “<code>Default</code>”
to indicate that alternative implementations are available for some specific cases.
For example the <code>Envelope</code> interface is implemented by at least two Apache SIS classes:
<code class="SIS">GeneralEnvelope</code> and <code>Envelope2D</code>.
The first implementation can represent envelopes with any number of dimensions
while the second implementation is specialized for two-dimensional envelopes.
</p><p>
Apache SIS classes prefixed by “<code>Abstract</code>” should not – in principle – be instantiated.
Users should instantiate a non-abstract subclass instead.
But many SIS classes are only conceptually abstract, without <code>abstract</code> Java keyword in class definition.
Such classes can be instantiated by a <code>new AbstractXXX(…)</code> statement
– but not by <code class="GeoAPI">Factory</code> – despite being conceptually abstract.
However such instantiations should be done only in last resort, when it is not possible to determine the exact subtype.
</p>
</section>
<section>
<header>
<h1 id="Utilities"><span class="section-number">3.</span> Utility Classes and Methods</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#GeoAPI">Previous chapter</a></div><div class="next-chapter"><a href="#Geometry">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#ComparisonMode">Comparison Modes of Objects</a></li>
<li><a href="#Internationalization">Internationalization</a><ul>
<li><a href="#LocalizedString">Distinct Character Sequences for Each Locale</a></li>
<li><a href="#InternationalString">Single instance for all supported locales</a></li>
<li><a href="#Locale.ROOT">Locale.ROOT Convention</a></li>
<li><a href="#UnicodePoint">Treatment of Characters</a><ul>
<li><a href="#Whitespaces">The Interpretation of Blank Spaces</a></li></ul></li></ul></li></ul></nav>
<p>
This chapter describes aspects of Apache <abbr title="Spatial Information System">SIS</abbr> that apply to the entire library.
Most of these utilities are not specific to spatial information systems.
</p>

<h2 id="ComparisonMode"><span class="section-number">3.1.</span> Comparison Modes of Objects</h2>
<p>
There are various opinions on how to implement Java standard's <code>Object​.equals(Object)</code> method.
According to some, it should be possible to compare different implementations of the same interface or base class.
But to follow this policy, each interface or base class's javadoc must define the algorithms that all implementations
shall use for their <code>equals(Object)</code> and <code>hashCode()</code> methods.
This approach is common in <code>java.util.Collection</code> and its child interfaces.
Transferring this approach to certain GeoAPI interfaces, however, would be a difficult task,
and would probably not be followed in many implementations.
Moreover, it comes at the expense of being able to take into account supplementary attributes in the child interfaces,
unless this possibility has been specified in the parent interface.
This constraint arises from the following points of the <code>equals(Object)</code> and <code>hashCode()</code> method contracts:
</p>
<ul>
<li><code>A.equals(B)</code> implies <code>B.equals(A)</code> (symmetry);</li>
<li><code>A.equals(B)</code> and <code>B.equals(C)</code> implies <code>A.equals(C)</code> (transitivity);</li>
<li><code>A.equals(B)</code> implies <code>A.hashCode() == B.hashCode()</code>.</li>
</ul>
<p>
For example, these three constraints are violated if <var>A</var> (and eventually <var>C</var>) can contain attributes
which <var>B</var> ignores.
To bypass this problem, an alternative approach is to require that the objects compared by the
<code>Object​.equals(Object)</code> method be of the same class; in other words, <code>A.getClass() == B.getClass()</code>.
This approach is sometimes regarded as contrary to the principles of object oriented programming.
In practice, for relatively complex applications, the important accorded to these principles depends on the context
in which the objects are compared:
if the objects are added to a <code>HashSet</code> or used as keys in a <code>HashMap</code>,
we would need a stricter adherence to the <code>equals(Object)</code> and <code>hashCode()</code> contract.
But if the developer is comparing the objects his- or herself, for example to check that the relevant information has been changed,
then the constraints of symmetry, transitivity or coherence with the hash values may be of little interest.
More permissive comparisons may be desirable, sometimes going so far as to tolerate minor discrepancies in numerical values.
</p>
<p>
In order to allow developers a certain amount of flexibility, many classes in the <abbr title="Spatial Information System">SIS</abbr>
library implement the <code class="SIS">org.apache.sis.util.LenientComparable</code> interface,
which defines a <code class="SIS">equals(Object, ComparisonMode)</code> method.
The principle modes of comparison are:
</p>
<ul>
<li><p>
<b><code class="SIS">STRICT</code></b> — The objects compared must share the same class and have exactly equal attributes,
including any possible public attributes specific to the implementation.
</p></li>
<li><p>
<b><code class="SIS">BY_CONTRACT</code></b> — The objects compared must implement the same GeoAPI (or other standard)
interface, but need not be of the same implementation class.
Only the attributes defined in the interface are compared;
all other attributes specific to the implementation — even if they are public — are ignored.
</p></li>
<li><p>
<b><code class="SIS">IGNORE_METADATA</code></b> — Like <code class="SIS">BY_CONTRACT</code>,
but only compares attributes that influence the operations (numeric calculations or otherwise) performed by the object.
For example, in a geodesic datum, the longitude (in relation to Greenwich) of the original meridian
would be taken into account, while the name of the meridian would be ignored.
</p></li>
<li><p>
<b><code class="SIS">APPROXIMATIVE</code></b> — Like <code class="SIS">IGNORE_METADATA</code>,
but tolerates minor discrepancies in numerical values.
</p></li>
</ul>
<p>
The default mode, used in all <code>equals(Object)</code> methods in <abbr>SIS</abbr>,
is <code class="SIS">STRICT</code>. This mode is chosen for a safe operation — particularly with <code>HashMap</code> —
without the need to rigorously define <code>equals(Object)</code> and <code>hashCode()</code> operations in every interface.
With this mode, the order of objects (<code>A.equals(B)</code> or <code>B.equals(A)</code>) is unimportant.
It is, however, the only mode that offers this guarantee.
In the expression <code>A.equals(B)</code>, the <code class="SIS">BY_CONTRACT</code> mode
(and so by extension all other modes that depend on it) only compares the properties known to <code>A</code>,
regardless of whether <code>B</code> knows more.
</p>



<h2 id="Internationalization"><span class="section-number">3.2.</span> Internationalization</h2>
<p>
In an architecture where a program executed on a server provides its data to multiple clients,
the server's locale conventions are not necessarily the same as those of the clients.
Conventions may differ in language, but also in the way they write numeric values
(even between two countries that speak the same language) as well in time zone.
To produce messages that conform to the client's conventions, <abbr title="Spatial Information System">SIS</abbr> uses
two approaches, distinguished by their level of granularity: at the level of the messages themselves,
or at the level of the objects that create the messages.
The approach used also determines whether it is possible to share the same instance of an object for all languages.
</p>

<h3 id="LocalizedString"><span class="section-number">3.2.1.</span> Distinct Character Sequences for Each Locale</h3>
<p>
Some classes are only designed to function according to one locale convention at a time.
This is of course true for the standard implementations of <code>java.text.Format</code>,
as they are entirely dedicated to the work of internationalization.
But it is also the case for other less obvious classes like <code>javax.imageio.ImageReader</code>/<code>ImageWriter</code>
and for <code>Exception</code> subclasses.
When one of these classes is implemented by <abbr title="Spatial Information System">SIS</abbr>,
we identify it by implementing the <code class="SIS">org.apache.sis.util.Localized</code> interface.
The <code class="SIS">getLocale()</code> method of this interface can determine the locale conventions
by which the instance produces its message.
</p>
<p>
Some sub-classes of <code>Exception</code> defined by <abbr>SIS</abbr> also implement the <code class="SIS">Localized</code> interface.
For these exceptions, the error message may be produced according to two locale conventions,
for either the administrator or the client respectively:
<code>getMessage()</code> returns the exception message according to the system default conventions,
while <code>getLocalizedMessage()</code> returns the exception message according to the locale conventions specified
by <code class="SIS">getLocale()</code>.
This <code>Locale</code> will be determined by the <code class="SIS">Localized</code> object that threw the exception.
</p>
<div class="example"><p><b>Example:</b>
Given an environment in which the default language is English and an <code class="SIS">AngleFormat</code> object is created to
read angles according to French conventions.
If a <code>ParseException</code> is thrown when using this formatter, <code>getMessage()</code> returns the error message in English,
while <code>getLocalizedMessage()</code> returns the error message in French.
</p></div>
<p>
The exceptions defined by <abbr>SIS</abbr> do not implement all of the <code class="SIS">Localized</code> interface.
Only those most likely to be shown to the user are localized in this way.
<code>ParseException</code> are good candidates because they often occur due to an incorrect entry by the client.
By contrast, <code>NullPointerException</code> are generally caused by a programming error;
they may be localized in the system default language, but that is usually all.
</p>
<p>
The utility class <code class="SIS">org.apache.sis.util.Exceptions</code> provides convenience methods to get messages
according to the conventions of a given locale, when this information is available.
</p>



<h3 id="InternationalString"><span class="section-number">3.2.2.</span> Single instance for all supported locales</h3>
<p>
The <abbr title="Application Programming Interface">API</abbr> conventions defined by <abbr title="Spatial Information System">SIS</abbr> or inherited by GeoAPI favour the use of the
<code class="GeoAPI">InternationalString</code> type when the value of a <code>String</code> type would likely be localized.
This approach allows us to defer the internationalization process to the time when a character sequence is requested,
rather than the time when the object that contains them is created.
This is particularly useful for immutable classes used for creating unique instances independently of locale conventions.
</p>
<div class="example"><p><b>Example:</b>
<abbr>SIS</abbr> includes only one instance of the <code class="GeoAPI">OperationMethod</code>
type representing the Mercator projection, regardless of the client's language.
But its <code class="GeoAPI">getName()</code> method (indirectly) provides an instance of
<code class="GeoAPI">InternationalString</code>, so that <code>toString(Locale.ENGLISH)</code> returns <cite>Mercator projection</cite>
while <code>toString(Locale.FRENCH)</code> returns <cite>Projection de Mercator</cite>.
</p></div>
<p>
When defining spatial objects independently of locale conventions, we reduce the risk of computational overload.
For example, it is easier to detect that two maps use the same cartographic projection if this last is represented by the
same instance of <code class="GeoAPI">CoordinateOperation</code>,
even if the projection has a different name depending on the country.
Moreover, certain types of <code class="GeoAPI">CoordinateOperation</code> may require coordinate transformation matrices,
so sharing a single instance becomes even more preferable in order to reduce memory consumption.
</p>



<h3 id="Locale.ROOT"><span class="section-number">3.2.3.</span> <code>Locale.ROOT</code> Convention</h3>
<p>
All <abbr title="Spatial Information System">SIS</abbr> methods receiving or returning the value of a <code>Locale</code> type accept the <code>Locale.ROOT</code> value.
This value is interpreted as specifying not to localize the text.
The notion of a <cite>non-localized text</cite> is a little false, as it is always necessary to chose a formatting convention.
This convention however, though very close to English, is usually slightly different.
For example:
</p>
<ul>
<li>
Identifiers are written as they appear in <abbr title="Unified Modeling Language">UML</abbr> diagrams,
such as <cite>blurredImage</cite> instead of <cite>Blurred image</cite>.
</li>
<li>
Dates are written according to the <abbr title="International Organization for Standardization">ISO</abbr> 8601 format,
which does not correspond to English conventions.
</li>
<li>
Numbers are written using their <code>toString()</code> methods, rather than using a <code>java.text.NumberFormat</code>.
As a result, there are differences in the number of significant digits,
use of exponential notation and the absence of thousands separators.
</li>
</ul>



<h3 id="UnicodePoint"><span class="section-number">3.2.4.</span> Treatment of Characters</h3>
<p>
In Java, sequences of characters use UTF-16 encoding.
There is a direct correspondence between the values of the <code>char</code> type and the great majority of characters,
which facilitates the use of sequences so long as these characters are sufficient.
However, certain Unicode characters cannot be represented by a single <code>char</code>.
These <i>supplementary characters</i> include certain ideograms,
but also road and geographical symbols in the 1F680 to 1F700 range.
Support for these supplementary characters requires slightly more complex interactions than the classic case,
where we may assume a direct correspondence.
Thus, instead of the loop on the left below, international applications must generally use the loop on the right:
</p>

<table class="hidden">
<tr>
<th>Loop to Avoid</th>
<th>Recommended loop</th>
</tr>
<tr>
<td>
<pre style="margin-top: 6pt"><b>for</b> (<b>int</b> i=0; i&lt;string.length(); i++) {
    <b>char</b> c = string.charAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// A blank space was found.
</code>    }
}</pre>
</td>
<td>
<pre style="margin-top: 6pt"><b>for</b> (<b>int</b> i=0; i&lt;string.length();) {
    <b>int</b> c = string.codePointAt(i);
    <b>if</b> (Character.isWhitespace(c)) {
        <code class="comment">// A blank space was found.
</code>    }
    i += Character.charCount(c);
}</pre>
</td>
</tr>
</table>

<p>
<abbr title="Spatial Information System">SIS</abbr> supports supplementary characters by using the loop on the right where necessary,
but the loop on the left is occasionally used when it is known that the characters searched for are not supplementary characters,
even if some may be present in the sequence in which we are searching.
</p>



<h4 id="Whitespaces"><span class="section-number">3.2.4.1.</span> The Interpretation of Blank Spaces</h4>
<p>
Standard Java provides two methods for determining whether a character is a blank space:
<code>Character​.isWhitespace(…)</code> and <code>Character​.isSpaceChar(…)</code>.
These two methods differ in their interpretations of non-breaking spaces, tabs and line breaks.
The first method conforms to the interpretation currently used in languages such as Java, C/C++ and <abbr>XML</abbr>,
which considers tabs and line breaks to be blank spaces, while non-breaking spaces are read as not blank.
The second method — which conforms strictly to the Unicode definition — makes the opposite interpretation.
</p>
<p>
<abbr title="Spatial Information System">SIS</abbr> uses each of these methods in different contexts.
<code>isWhitespace(…)</code> is used to <em>separate</em> the elements of a list (numbers, dates, words, etc.),
while <code>isSpaceChar(…)</code> is used to ignore blank spaces <em>inside</em> a single element.
</p>
<div class="example"><p><b>Example:</b>
Take a list of numbers represented according to French conventions.
Each number may contain <em>non-breaking spaces</em> as thousands separators,
while the different numbers in the list may be separated by ordinary spaces, tabs or line breaks.
When analyzing a number, we want to consider the non-breaking spaces as being part of the number,
whereas a tab or a line break most likely indicates a separation between this number and the next.
We would thus use <code>isSpaceChar(…)</code>.
Conversely, when separating the numbers in the list, we want to consider tabs and line breaks as separators,
but not non-breaking spaces.
We would thus use <code>isWhitespace(…)</code>.
The role of ordinary spaces, to which either case might apply, should be decided beforehand.
</p></div>
<p>
In practice, this distinction is reflected in the use of <code>isSpaceChar(…)</code> in the implementations of <code>java.text.Format</code>,
or the use of <code>isWhitespace(…)</code> in nearly all the rest of the <abbr>SIS</abbr> library.
</p>
</section>
<section>
<header>
<h1 id="Geometry"><span class="section-number">4.</span> Geometries</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Utilities">Previous chapter</a></div><div class="next-chapter"><a href="#Coverage">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#Geometry-root">Base Classes</a><ul>
<li><a href="#DirectPosition">Direct Points and Positions</a></li>
<li><a href="#Envelope">Envelopes</a><ul>
<li><a href="#AntiMeridian">Envelopes that Cross the Antimeridian</a></li></ul></li></ul></li></ul></nav>
<p>
This chapter introduces a few aspects of <abbr title="International Organization for Standardization">ISO</abbr> 19107 standard (<i>Spatial schema</i>)
and the Apache <abbr title="Spatial Information System">SIS</abbr> classes that implement them.
</p>



<h2 id="Geometry-root"><span class="section-number">4.1.</span> Base Classes</h2>
<p>
Each geometric object is considered an infinite set of points.
As a set, their most fundamental operations are of the same nature as the standard operations of Java collections.
We may therefore see a geometry as a kind of <code>java.util.Set</code> in which the elements are points,
except that the number of elements contained in the set is infinite (with the exception of geometries representing a simple point).
To better represent this concept, the <abbr title="International Organization for Standardization">ISO</abbr> standard and GeoAPI define a <code class="OGC">TransfiniteSet</code> interface
which we could see as a <code>Set</code> of infinite size.
Although a parent relationship exists conceptually between these interfaces,
GeoAPI does not define <code class="GeoAPI">TransfiniteSet</code> as a sub-interface of <code>java.util.Set</code>,
as the definition of certain methods such as <code>size()</code> and <code>iterator()</code> would be problematic.
However, we find very similar methods such as <code class="GeoAPI">contains(…)</code> and <code class="GeoAPI">intersects(…)</code>.
</p>
<p>
All geometries are specializations of <code class="GeoAPI">TransfiniteSet</code>.
The parent class of those geometries is called <code class="OGC">GM_Object</code> in <abbr>ISO</abbr> 19107 standard.
GeoAPI interfaces use the <code class="GeoAPI">Geometry</code> name instead, as the omission of the <code class="OGC">GM_</code>
prefix (as prescribed in GeoAPI convention) would leave a name too similar to Java's <code>Object</code> class.
</p>



<h3 id="DirectPosition"><span class="section-number">4.1.1.</span> Direct Points and Positions</h3>
<p>
<abbr title="International Organization for Standardization">ISO</abbr> 19107 defines two types of structures to represent a point:
<code class="OGC">GM_Point</code> and <code class="OGC">DirectPosition</code>.
The first type is a true geometry and may therefore be relatively cumbersome, depending on the implementation.
The second type is not formally considered to be a geometry;
it extends neither <code class="OGC">GM_Object</code> nor <code class="OGC">TransfiniteSet</code>.
It barely defines any operations besides the storing of a sequence of numbers representing a coordinate.
It may therefore be a more lightweight object.
</p>
<p>
In order to allow the <abbr title="Application Programming Interface">API</abbr> to work equally with these two types of positions,
<abbr>ISO</abbr> 19107 defines <code class="OGC">Position</code> as a <cite>union</cite> of
<code class="OGC">DirectPosition</code> and <code class="OGC">GM_Point</code>.
It is a union in the sense of C/C++. For the Java language, GeoAPI obtains the same effect by defining
<code class="GeoAPI">Position</code> as the parent interface of <code class="GeoAPI">DirectPosition</code> and <code class="GeoAPI">Point</code>.
In practice, the great majority of Apache <abbr title="Spatial Information System">SIS</abbr>'s <abbr>API</abbr> works on <code class="GeoAPI">DirectPosition</code>s,
or occasionally on <code class="GeoAPI">Position</code>s when it seems useful to also allow geometric points.
</p>



<h3 id="Envelope"><span class="section-number">4.1.2.</span> Envelopes</h3>
<p>
Envelopes store minimal and maximal coordinate values of a geometry.
Envelopes are <em>not</em> geometries themselves; they are not infinite sets of points (<code class="OGC">TransfiniteSet</code>).
There is no guarantee that all the positions contained within the limits of an envelope are geographically valid.
Envelopes must be seen as information about extreme values that might take the coordinates of a geometry as if
each dimension were independent of the others, nothing more.
Nevertheless, we speak of envelopes as rectangles, cubes or hyper-cubes (depending on the number of dimensions)
in order to facilitate discussion, while bearing in mind their non-geometric nature.
</p>
<div class="example"><p><b>Example:</b>
We could test whether a position is within the limits of an envelope.
A positive result does not guarantee that the position is within the geometry delimited by the envelope,
but a negative result guarantees that it is outside the envelope.
We can perform intersection tests in the same way.
On the other hand, it makes little sense to apply a rotation to an envelope,
as the result may be very different from that which we would obtain be performing a rotation on the original geometry,
and then recalculating its envelope.
</p></div>
<p>
An envelope might be represented by two positions corresponding to two opposite corners of a rectangle,
cube or hyper-cube.
For the first corner, we often take the one whose ordinates all have the maximal value (<code class="OGC">upperCorner</code>).
When displayed using a conventional system of coordinates (with <var>y</var> axis values running upwards),
these two positions appear respectively in the lower left corner and the upper right corner of a rectangle.
Care must be taken with different coordinate systems, however, which may vary the positions of these corners on the screen.
The expressions <i>lower corner</i> and <i>upper corner</i> should thus be understood in the mathematical rather than the visual sense.
</p>



<h4 id="AntiMeridian"><span class="section-number">4.1.2.1.</span> Envelopes that Cross the Antimeridian</h4>
<p>
Minimums and maximums are the values most often assigned to <code class="OGC">lowerCorner</code>
and <code class="OGC">upperCorner</code>.
But the situation becomes complicated when an envelope crosses the antimeridian (-180° or 180° longitude).
For example, an envelope 10° in size may begin at 175° longitude and end at -175°.
In this case, the longitude value assigned to <code class="OGC">lowerCorner</code> is greater than that assigned to <code class="OGC">upperCorner</code>.
Apache <abbr title="Spatial Information System">SIS</abbr> therefore uses a slightly different definition of these two corners:
</p>
<ul>
<li><b><code class="SIS">lowerCorner</code>:</b>
the starting point, if we move along the inside of the envelope in the direction of ascending values.
</li>
<li><b><code class="SIS">upperCorner</code>:</b>
the end-point, if we move along the inside of the envelope in the direction of ascending values.
</li>
</ul>
<p>
If the envelope does not cross the antimeridian, these two definitions are equivalent to the selection of minimal and
maximal values respectively. This is the case in the green rectangle in the figure below.
When the envelope crosses the antimeridian, the <code class="SIS">lowerCorner</code> and the
<code class="SIS">upperCorner</code> appear again at the bottom and top of the rectangle
(assuming a standard system of coordinates), so their names remain appropriate from a visual standpoint.
However, the left and right positions are switched.
This case is illustrated by the red rectangle in the figure below.
</p>
<p style="text-align:center">
<img alt="Envelope example with and without anti-meridian spanning." src="../../apidocs/org/apache/sis/geometry/doc-files/AntiMeridian.png"/>
</p>
<p>
The notions of inclusion and intersection, however, interpreted slightly differently in these two cases.
In the usual case where we do not cross the antimeridian, the green rectangle covers a region of inclusion.
The regions excluded from this rectangle continue on to infinity in all directions.
In other words, the region of inclusion is not repeated every 360°.
But in the case of the red rectangle, the information provided by the envelope actually covers a region of exclusion
between the two edges of the rectangle. The region of inclusion extends to infinity to the left and right.
We could stipulate that all longitudes below -180° or above 180° are considered excluded,
but this would be an arbitrary decision that would not be an exact counterpart to the usual case (green rectangle).
A developer may wish to use these values, for example, in a mosaic where the map of the world is repeated several times
horizontally and each repetition is considered distinct.
If developers wish to perform operations as though the regions of inclusion or exclusion were repeated every 360°,
they themselves will have to bring the longitudinal values between -180° and 180° in advance.
All the <code class="SIS">add(…)</code>, <code class="SIS">contains(…)</code>,
<code class="SIS">intersect(…)</code>, etc. functions of all the envelopes defined in the
<code class="SIS">org.apache.sis.geometry</code> package perform their calculations according to this convention.
</p>
<aside>
<h5>Generalizing to Other Types of Axes</h5>
<p>
This section specifically relates to longitude, as it is the most usual example of a cyclic axis.
However, in Apache <abbr title="Spatial Information System">SIS</abbr> envelopes, there is no explicit mention of longitude, or of its 360° cycle.
The characteristics of the range of values of each axis (its extremum, units, type of cycle, etc.)
are attributes of <code class="GeoAPI">CoordinateSystemAxis</code> objects,
indirectly associated with envelopes via the coordinate reference system.
Apache <abbr>SIS</abbr> inspects these attributes to determine the way in which it must perform these operations.
Thus, any axis associated with the code <code class="GeoAPI">RangeMeaning.WRAPAROUND</code> benefit from
the same treatment as does longitude.
For example, this could be a time axis for climatological data (one “year” represents the average temperature in all the
months of January, followed by the average of all the months of February, etc.)
This generalization also applies to longitude axes defined by a range of 0° to 360° rather than -180° to 180°.
</p>
</aside>
<p>
In order for functions such as <code class="SIS">add(…)</code> to work correctly,
all objects involved must use the same coordinate reference system, including the same range of values.
Thus an envelope that expresses longitudes in the range [-180 … +180]° is not compatible with an envelope that expresses
longitudes in the range [0 … 360]°.
The conversions, if necessary, are up to the user
(the <code class="SIS">Envelopes</code> class provides convenience methods to do this).
Moreover, the envelope's coordinates must be included within the system of coordinates,
unless the developer explicitly decides to consider (for example) 300° longitude as a position distinct from -60°.
The <code class="SIS">GeneralEnvelope</code> class provides a <code class="SIS">normalize()</code> method to bring
coordinates within the desired limits, sometimes at the coast of <cite><i>lower</i></cite> values being higher than
<cite><i>upper</i></cite> values.
</p>
<aside>
<h5>The Special Case of the Range [+0 … -0]</h5>
<p>
Java (or more generally, IEEE Standard 754) defines two values distinct from zero:
a positive zero and a negative zero. These two values are considered equal when we compare them with the <code>==</code> operator in Java.
But in <abbr title="Spatial Information System">SIS</abbr> envelopes, they may actually return opposite results for axes using <code class="GeoAPI">RangeMeaning.WRAPAROUND</code>.
An envelope whose range is [0 … 0], [-0 … -0] or [-0 … +0] would normally be considered an empty envelope,
but the [+0 … -0] range would in fact be considered to include the entire set of values all around the world.
This behaviour conforms to the definition of <code class="SIS">lowerCorner</code> and <code class="SIS">upperCorner</code>,
which considers +0 as the starting point, and -0 as the end-point after cycling through all possible values.
Such behaviour only occurs for the pair of values +0 and -0, and only in that order.
For all other real values, if the condition <code>lower</code> <code>==</code> <code>upper</code> is true,
then it is guaranteed that the envelope is empty.
</p>
</aside>
</section>
<section>
<header>
<h1 id="Coverage"><span class="section-number">5.</span> Data Coverages</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Geometry">Previous chapter</a></div><div class="next-chapter"><a href="#XML-ISO">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc"/></nav>
<p>
Images, or <i>rasters</i>, are a particular case of a data structure called a <i>coverage</i>.
We could think of this as a “coverage of data.”
The title of the <abbr title="International Organization for Standardization">ISO</abbr> 19123 standard that describes them, “Coverage Geometry and Functions”,
nicely summarizes the two essential elements of coverages:
</p>
<ul>
<li>
<p>
A coverage is a function which returns an attribute value from an entered coordinate.
The set of values that may be entered is called the domain, while the set of values that may be returned is called the range.
The domain is often the spatio-temporal area covered by the data,
but nothing in <abbr title="Spatial Information System">SIS</abbr> prevents coverages from extending to other dimensions.
For example, thermodynamic studies often use an area where the dimensions are temperature and pressure.
</p>
<div class="example"><p><b>Example:</b>
The pixel values of an image may contain measures for terrain elevation.
If the function <var>h</var> = <var>f</var>(φ,λ) allows us to obtain (eventually, with the help of interpolations)
the elevation <var>h</var> according the the geographic coordinate (φ,λ),
then the geographic envelope of the image defined by the domain — the function <var>f</var> — is the <i>coverage</i>,
and the set of values <var>h</var> that this function can return is the <i>range</i>.
</p></div>
</li>
<li>
<p>
Different types of coverages may be characterized by the geometry of their cells.
In particular, a coverage is not necessarily composed of quadrilateral cells.
However, given that quadrilateral cells are by far the most frequent (since this is the usual geometry of image pixels),
we often use the term “grid coverage” to specify coverages composed of such cells.
In <abbr>SIS</abbr>, the geometry of coverages is described by the <code class="SIS">GridGeometry</code> class.
</p>
</li>
</ul>
<p>
The characteristics of the spatial domain are defined by <abbr>ISO</abbr> 19123 standard,
while the characteristics of range are not included in the standard.
The standard simply mentions that ranges may be finite or infinite,
and are not necessarily numerical.
For example, the values returned by a coverage may come from an enumeration (“this is a forest,” “this is a lake,” etc.).
However, the standard defines two important types of coverage which have an impact on the types of authorized ranges:
<i>discrete</i> coverages and <i>continuous</i> coverages.
Stated simply, continuous coverages are functions that can use interpolation methods.
Thus, since interpolations are only possible with numeric values, the ranges of non-numeric values may only be used with coverages of the
<code class="OGC">CV_DiscreteCoverage</code> type.
</p>
<aside>
<h2>SIS's <code class="SIS">Range</code> Class and its Relationship to the Standards</h2>
<p>
The distinction between the ranges of all types of values and the ranges of numeric values is represented in
<abbr title="Spatial Information System">SIS</abbr> by the <code class="SIS">Range</code> and <code class="SIS">NumberRange</code>
classes respectively.
The <code class="SIS">NumberRange</code> is used more often, and is also the one that most closely approaches the
<a href="http://en.wikipedia.org/wiki/Interval_%28mathematics%29">the common mathematical concept of an interval</a>.
This textual representation approaches the specifications of <abbr title="International Organization for Standardization">ISO</abbr> 31-11 standard,
except that the comma is replaced by the character “…” as the separator of minimal and maximal values.
For example, “[0 … 256)” represents the range of values from 0 inclusive to 256 exclusive.
</p>
<p>
<code class="SIS">Range</code> objects are only indirectly associated with coverages.
In <abbr>SIS</abbr>, the values that can return coverages are described by objects of the
<code class="SIS">SampleDimension</code> type. It is these that contain instances of <code class="SIS">Range</code>,
as well as other information such as <i>transfer function</i> (described later).
</p>
</aside>
</section>
<section>
<header>
<h1 id="XML-ISO"><span class="section-number">6.</span> Representing Objects in <abbr>XML</abbr></h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#Coverage">Previous chapter</a></div><div class="next-chapter"><a href="#reduce-direct-dependency">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#XML-ISO-19115">Representing Metadata According to ISO 19115-3</a><ul>
<li><a href="#gco-id">Identification of Already-Defined Instances</a></li>
<li><a href="#nilReason">Representing Missing Values</a></li></ul></li></ul></nav>
<p>
Objects defined by <abbr title="Open Geospatial Consortium">OGC</abbr>/<abbr title="International Organization for Standardization">ISO</abbr> standards must be able to communicate with remote machines via the Internet,
using different software written in different languages.
Some of the better known formats include <abbr>WKT</abbr> (<i>Well-Known Text</i>) and <abbr>WKB</abbr> (<i>Well-Known Binary</i>).
But the most exhaustive and often referred format is <abbr>XML</abbr>,
to the point where the representation of <abbr>ISO</abbr> objects in this format is itself sometimes
the entire focus of an international standard.
Thus are metadata classes described in <abbr>ISO</abbr> 19115-1 standard (an abstract specification),
while the representation of these classes in <abbr>XML</abbr> is described in <abbr>ISO</abbr> 19115-3 and 19139 standards.
</p>
<p>
Different <abbr>OGC</abbr>/<abbr>ISO</abbr> standards do not always use the same strategy to express objects in <abbr>XML</abbr>.
<abbr>ISO</abbr> 19115-3 standard in particular uses a more verbose approach than other standards,
and will be the subject of its <a href="#XML-ISO-19115">own section</a>.
But most <abbr>XML</abbr> formats define supplementary types and attributes that are not part of the original abstract specifications.
These supplementary attributes are usually specific to <abbr>XML</abbr> and may not appear in the <abbr title="Application Programming Interface">API</abbr> of Apache <abbr title="Spatial Information System">SIS</abbr>.
However, some of these attributes, such as <code class="OGC">id</code>, <code class="OGC">uuid</code> and
<code>xlink:href</code>, remain accessible in the form of key-value pairs.
</p>
<p>
<abbr>XML</abbr> documents may use any prefixes,
but the following prefixes are commonly used.
They therefore appear by default in documents produced by Apache <abbr>SIS</abbr>.
These prefixes are defined in the <code class="SIS">org.apache.sis.xml.Namespaces</code> class.
</p>
<table>
<caption>Common <abbr>XML</abbr> namespace prefixes</caption>
<tr>
<th>Prefix</th>
<th>Namespace</th>
</tr>
<tr>
<td><code class="OGC">gco</code></td>
<td><code>http://www.isotc211.org/2005/gco</code></td>
</tr>
<tr>
<td><code class="OGC">gfc</code></td>
<td><code>http://www.isotc211.org/2005/gfc</code></td>
</tr>
<tr>
<td><code class="OGC">gmd</code></td>
<td><code>http://www.isotc211.org/2005/gmd</code></td>
</tr>
<tr>
<td><code class="OGC">gmi</code></td>
<td><code>http://www.isotc211.org/2005/gmi</code></td>
</tr>
<tr>
<td><code class="OGC">gmx</code></td>
<td><code>http://www.isotc211.org/2005/gmx</code></td>
</tr>
<tr>
<td><code class="OGC">gml</code></td>
<td><code>http://www.opengis.net/gml/3.2</code></td>
</tr>
<tr>
<td><code>xlink</code></td>
<td><code>http://www.w3.org/1999/xlink</code></td>
</tr>
</table>

<aside>
<h2>Tools for Reading and Writing <abbr>XML</abbr> Documents</h2>
<p>
Apache <abbr title="Spatial Information System">SIS</abbr> uses different libraries to read and write different types of objects.
The library used depends on the complexity of the object and on performance constraints.
For example, <abbr title="Java Architecture for XML Binding">JAXB</abbr> annotations have the advantage of being close to code,
which makes it easier to maintain mapping between Java and <abbr>XML</abbr>.
On the other hand, <abbr title="Simple API for XML">SAX</abbr> is more efficient.
In general, Apache <abbr>SIS</abbr> uses:
</p>
<ul>
<li>
<abbr>JAXB</abbr> for objects that do not occur very often in <abbr>XML</abbr> documents, but with complex structures and deep hierarchies.
The metadata set in <abbr title="International Organization for Standardization">ISO</abbr> 19115-3 standard is a typical example
</li>
<li>
<abbr>SAX</abbr> for objects that are relatively simple, but which may exist in very large numbers.
The set of points in a geometry is a typical example.
</li>
<li>
<abbr title="Document Object Model">DOM</abbr> as an alternative to <abbr>JAXB</abbr>
when the <abbr>XML</abbr> elements do not correspond exactly to Java attributes.
<i>Features</i> are an example, as their structure is dynamic.
</li>
</ul>
</aside>



<h2 id="XML-ISO-19115"><span class="section-number">6.1.</span> Representing Metadata According to <abbr title="International Organization for Standardization">ISO</abbr> 19115-3</h2>
<p>
For each metadata class, there is an <abbr>XML</abbr> type with the same name than in the abstract specification
(for example, <code class="OGC">gmd:MD_Metadata</code> and <code class="OGC">gmd:CI_Citation</code>).
All of these types may be used as the root of an <abbr>XML</abbr> document.
It is therefore possible to write a document representing a complete <code class="OGC">MD_Metadata</code> object,
or to write a document representing only a <code class="OGC">CI_Citation</code> object.
</p>
<p>
<abbr>ISO</abbr> 19115-3 standard arranges the content of these objects in an unusual way:
for each property whose value type is itself another class of <abbr>ISO</abbr> 19115,
the value is wrapped in an element that represents its type, rather than being written directly.
For example, in an object of the <code class="OGC">CI_Citation</code> type,
the value of the <code class="OGC">citedResponsibleParty</code> property is incorporated
into a <code class="OGC">CI_Responsibility</code> element.
This practice doubles the depth of the hierarchy, and introduces duplication at all levels for each value,
as in the following example:
</p>

<pre class="xml"><b>&lt;MD_Metadata&gt;</b>
  &lt;identificationInfo&gt;
    <b>&lt;MD_DataIdentification&gt;</b>
      &lt;citation&gt;
        <b>&lt;CI_Citation&gt;</b>
          &lt;citedResponsibleParty&gt;
            <b>&lt;CI_Responsibility&gt;</b>
              &lt;party&gt;
                <b>&lt;CI_Party&gt;</b>
                  &lt;contactInfo&gt;
                    <b>&lt;CI_Contact&gt;</b>
                      &lt;onlineResource&gt;
                        <b>&lt;CI_OnlineResource&gt;</b>
                          &lt;linkage&gt;
                            &lt;URL&gt;http://www.opengeospatial.org&lt;/URL&gt;
                          &lt;/linkage&gt;
                        <b>&lt;/CI_OnlineResource&gt;</b>
                      &lt;/onlineResource&gt;
                    <b>&lt;/CI_Contact&gt;</b>
                  &lt;/contactInfo&gt;
                <b>&lt;/CI_Party&gt;</b>
              &lt;/party&gt;
            <b>&lt;/CI_Responsibility&gt;</b>
          &lt;/citedResponsibleParty&gt;
        <b>&lt;/CI_Citation&gt;</b>
      &lt;/citation&gt;
    <b>&lt;/MD_DataIdentification&gt;</b>
  &lt;/identificationInfo&gt;
<b>&lt;/MD_Metadata&gt;</b></pre>

<p>
The preceding example, like all documents that conform to <abbr>ISO</abbr> 19115-3,
consists of a systematic alternation of two types of <abbr>XML</abbr> elements:
</p>
<ol>
<li><p>
It begins with the name of the property, which always begins with a lower-case letter (ignoring prefixes).
In Java <abbr title="Application Programming Interface">API</abbr>s, each property corresponds to a method in its enclosing class.
In the example above, <code class="OGC">gmd:identificationInfo</code>  (a property of <code class="OGC">MD_Metadata</code> class)
corresponds to the <code class="GeoAPI">Metadata​.getIdentificationInfo()</code> method.
</p></li>
<li><p>
The value type is included under each property, unless it has been replaced with a reference
(the following <a href="#gco-id">sub-section</a> will elaborate on this subject).
The value type is an <abbr>XML</abbr> element whose name always begins with an upper-case letter,
ignoring prefixes.
In the example above we had <code class="OGC">MD_DataIdentification</code>,
which corresponds to the <code class="GeoAPI">DataIdentification</code> Java interface.
It is this <abbr>XML</abbr> element that contains the child properties.
</p></li>
</ol>

<p>
In order to reduce the complexity of the libraries, GeoAPI and Apache <abbr title="Spatial Information System">SIS</abbr>
only expose publicly a single unified view of these two types of elements.
The public <abbr>API</abbr> basically corresponds to the second group.
However, when writing an <abbr>XML</abbr> document, elements of the first group must be temporarily recreated.
The corresponding classes are defined in internal <abbr>SIS</abbr> packages.
These classes may be ignored, unless the developer wishes to implement his or her own classes whose instances must be written in <abbr title="Java Architecture for XML Binding">JAXB</abbr>.
</p>

<aside>
<h3>Implementation Strategy in Apache <abbr title="Spatial Information System">SIS</abbr></h3>
<p>
<code class="SIS">org.apache.sis.internal.jaxb.*</code> packages (non-public) define <abbr title="Java Architecture for XML Binding">JAXB</abbr> adaptors for all types of <abbr title="International Organization for Standardization">ISO</abbr> objects.
These adaptors are required anyway to allow <abbr>JAXB</abbr> to get <abbr>SIS</abbr> classes while implementing GeoAPI interfaces.
Conveniently, <abbr>SIS</abbr> made both <abbr>JAXB</abbr> adaptors and objects wrapping the “real” object to be read or written.
This double usage avoids having to double the number of classes (already quite high) present in the internal packages.
</p>
<h4>Naming Conventions in <abbr title="XML Schema Definition">XSD</abbr> Schemas</h4>
<p>
For each element of the first group listed above, the <abbr>XSD</abbr> schemas of the <abbr title="Open Geospatial Consortium">OGC</abbr>
define a type whose name ends with “<code class="OGC">_PropertyType</code>”.
For the second group, each element has a type whose name ends with “<code class="OGC">_Type</code>”.
The “<code class="OGC">_PropertyType</code>” elements may have a group of attributes
(such as <code class="OGC">gco:uuidref</code> and <code>xlink:href</code>)
which the <abbr>XSD</abbr> schemas collectively name <code class="OGC">gco:ObjectIdentification</code>.
These attributes do not have dedicated Java methods, but are accessible indirectly via the
<code class="SIS">IdentifiedObject</code> interface described in the following subsection.
</p>
</aside>


<h3 id="gco-id"><span class="section-number">6.1.1.</span> Identification of Already-Defined Instances</h3>
<p>
The parent element may contain an <code class="OGC">id</code> or <code class="OGC">uuid</code> attribute.
If one of these attributes is present, the parent attribute may be completely omitted;
it will be replaced at the time of reading by the element referenced by the attribute.
In the following example, the part on the left defines an element associated with the identifier “<code>my_id</code>,”
while the part on the right references this element:
</p>

<table class="hidden">
<tr>
<th>Defining an Identifier</th>
<th>Using a Defined Identifier</th>
</tr>
<tr>
<td>
<pre class="xml" style="margin-top: 6pt">&lt;MD_MetaData&gt;
  &lt;identificationInfo&gt;
    &lt;MD_DataIdentification id=<i>"<b>my_id</b>"</i>&gt;
      <code class="comment">&lt;!-- insert child properties here --&gt;</code>
    &lt;/MD_DataIdentification&gt;
  &lt;/identificationInfo&gt;
&lt;/MD_MetaData&gt;</pre>
</td>
<td>
<pre class="xml" style="margin-top: 6pt">&lt;MD_MetaData&gt;
  &lt;identificationInfo xlink:href=<i>"<b>#my_id</b>"</i>/&gt;
&lt;/MD_MetaData&gt;</pre>
</td>
</tr>
</table>

<p>
The decision of which attribute to use depends on the scope of the referenced item:
</p>
<ul>
<li>
<code class="OGC">id</code> is only valid in the same <abbr>XML</abbr> document that defines the object it references.
</li>
<li>
<code class="OGC">uuid</code> may be valid outside the <abbr>XML</abbr> document,
but someone must maintain a database providing the objects for each given UUID.
</li>
<li>
<code>xlink:href</code> may reference another <abbr>XML</abbr> document accessible on the Internet.
</li>
</ul>
<p>
In the <abbr title="Spatial Information System">SIS</abbr> library, all objects that can be identified in an <abbr>XML</abbr> document
implements the <code class="SIS">org.apache.sis.xml.IdentifiedObject</code> interface.
Each instance of this interface provides a view of its identifiers in the form of a <code>Map&lt;Citation,String&gt;</code>,
in which the <code class="GeoAPI">Citation</code> key indicates the type of identifier and the value is the identifier itself.
Some constants representing different types of identifiers are listed in <code class="SIS">IdentifierSpace</code>,
including <code class="SIS">ID</code>, <code class="SIS">UUID</code> and <code class="SIS">HREF</code>.
Each of these keys may be associated with a different type of value (usually <code>String</code>,
<code>UUID</code> or <code>URI</code>) depending on the key.
For example, the following code defines a value for the <code class="OGC">uuid</code> attribute:
</p>

<pre><b>import</b> org.apache.sis.metadata.iso.<code class="SIS">DefaultMetadata</code>;
<b>import</b> org.apache.sis.xml.<code class="SIS">IdentifierSpace</code>;
<b>import</b> java.util.UUID;

<b>public</b> <b>class</b> MyClass {
    <b>public</b> <b>void</b> myMethod() {
        UUID identifier = UUID.randomUUID();
        <code class="SIS"><code class="SIS">DefaultMetadata</code></code> metadata = <b>new</b> <code class="SIS"><code class="SIS">DefaultMetadata</code></code>();
        metadata.<code class="SIS">getIdentifierMap().putSpecialized</code>(<code class="SIS">IdentifierSpace</code>.UUID, identifier);
    }
}</pre>

<p>
Although this mechanism has been defined in order to better support the representation of <abbr>XML</abbr> attributes
of the <code class="OGC">gco:ObjectIdentification</code> group,
it also conveniently allows other types of identifiers to be manipulated.
For example, the <code class="GeoAPI">ISBN</code> and <code class="GeoAPI">ISSN</code> attributes of
<code class="GeoAPI">Citation</code> may be manipulated in this way.
The methods of the <code class="SIS">IdentifiedObject</code> interface therefore provides a specific location
where all types of identifiers (not only <abbr>XML</abbr>) associated with an object may be manipulated.
</p>



<h3 id="nilReason"><span class="section-number">6.1.2.</span> Representing Missing Values</h3>
<p>
When a property is not defined, the corresponding GeoAPI method usually returns <code>null</code>.
However, things become complicated when the missing property is a value considered mandatory by <abbr title="International Organization for Standardization">ISO</abbr> 19115 standard.
<abbr>ISO</abbr> 19115-3 allows for the omission of mandatory properties so long as the reason for the missing value is indicated.
The reason may be that the property is not applicable (<code class="OGC">inapplicable</code>),
that the value probably exists but is not known (<code class="OGC">unknown</code>),
that the value cannot exist (<code class="OGC">missing</code>),
or that the value cannot be revealed (<code class="OGC">withheld</code>), <i>etc.</i>
The transmission of this information requires the use of a non-nul object, even when the value is missing.
<abbr title="Spatial Information System">SIS</abbr> will then return an object that, besides implementing the desired GeoAPI interface,
also implements the <code class="SIS">org.apache.sis.xml.NilObject</code> interface.
This interface flags the instances where all methods return an empty collection, an empty table, <code>null</code>,
<code>NaN</code>, <code>0</code> or <code>false</code>, in this preference order, as permitted by the return types of the methods.
Each instance that implements <code class="SIS">NilObject</code> provides a <code class="SIS">getNilReason()</code> method
indicating why the object is nil.
</p>
<p>
In the following example, the left side shows a <code class="OGC">CI_Citation</code> element containing a
<code class="OGC">CI_Series</code> element, while on the right side the series is unknown.
If the <code class="OGC">CI_Series</code> element had been completely omitted,
then the <code class="GeoAPI">Citation​.getSeries()</code> method would return <code>null</code> in Java.
But when a <code class="OGC">nilReason</code> is present, the <abbr>SIS</abbr> implementation of
<code class="SIS">getSeries()</code> returns instead an object that implements both the
<code class="GeoAPI">Series</code> and <code class="SIS">NilReason</code> interfaces, and in which the
<code class="SIS">getNilReason()</code> method returns the constant <code class="SIS">UNKNOWN</code>.
</p>

<table class="hidden">
<tr>
<th>Information Included</th>
<th>Missing Information</th>
</tr>
<tr>
<td>
<pre class="xml" style="margin-top: 6pt">&lt;CI_Citation&gt;
  &lt;series&gt;
    &lt;CI_Series&gt;
      <code class="comment">&lt;!-- insert child properties here --&gt;</code>
    &lt;/CI_Series&gt;
  &lt;/series&gt;
&lt;/CI_Citation&gt;</pre>
</td>
<td>
<pre class="xml" style="margin-top: 6pt">&lt;CI_Citation&gt;
  &lt;series nilReason=<i>"unknown"</i>/&gt;
&lt;/CI_Citation&gt;</pre>
</td>
</tr>
</table>
</section>
<section>
<header>
<h1 id="reduce-direct-dependency"><span class="section-number">7.</span> Reduce direct dependency to Apache SIS</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#XML-ISO">Previous chapter</a></div><div class="next-chapter"><a href="#tests">Next chapter</a> ➡</div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#UML-annotation-geoapi">Mapping Given by @UML Annotations</a></li>
<li><a href="#ServiceLoader">Fetching implementations of GeoAPI Interfaces</a><ul>
<li><a href="#GeoAPI-simple">Defining Custom Implementations</a></li></ul></li></ul></nav>
<p>
Previous chapters used Apache SIS static methods for convenience.
In some cases, usage of those convenience methods can be replaced by Java code using only GeoAPI methods.
Such replacements may be desirable for applications who want to reduce direct dependency toward Apache SIS,
for example in order to ease migrations between SIS and other GeoAPI implementations.
However this may require that applications write their own convenience methods.
The following sections provide some tip for easing this task.
</p>

<h2 id="UML-annotation-geoapi"><span class="section-number">7.1.</span> Mapping Given by <code class="GeoAPI">@UML</code> Annotations</h2>
<p>
For each class, method and constant defined by an <abbr title="Open Geospatial Consortium">OGC</abbr> or <abbr title="International Organization for Standardization">ISO</abbr> standard,
GeoAPI indicates its provenance using annotations defined in the <code class="GeoAPI">org.opengis.annotation</code> package.
This mapping is described in the <a href="#UML-annotation">chapter about GeoAPI</a>.
Java reflection methods allow access to this information during the execution of an application.
Class <code class="SIS">org.apache.sis.util.iso.Types</code> provides static convenience methods like
<code class="SIS">getStandardName(Class)</code>, but one can avoid those methods.
The following example displays the standard name for the method <code class="GeoAPI">getTitle()</code> from the <code class="GeoAPI">Citation</code> interface:
</p>

<pre>Class&lt;?&gt; type   = <code class="GeoAPI">Citation</code>.<b>class</b>;
Method   method = type.getMethod(<i>"<code class="GeoAPI">getTitle</code>"</i>, (Class&lt;?&gt;[]) <b>null</b>);
<code class="GeoAPI">UML</code>      annot  = method.getAnnotation(<code class="GeoAPI">UML</code>.<b>class</b>);
String   id     = annot.identifier();
System.out.println(<i>"The standard name for the "</i> + method.getName() + <i>" method is "</i> + id);</pre>

<p>
The reverse operation — getting the Java class and method from a standard name — is a bit more complicated.
It requires reading the <code class="GeoAPI">class-index.properties</code> file provided in the <code class="GeoAPI">org.opengis.annotation</code> package.
The following example reads the files just before searching for the name of the interface corresponding to <code class="OGC">CI_Citation</code>.
Users are always encouraged to only read this file once and then save its contents in their application's cache.
</p>

<pre>Properties isoToGeoAPI = <b>new</b> Properties();
<b>try</b> (InputStream in = <code class="GeoAPI">UML</code>.<b>class</b>.getResourceAsStream(<i>"<code class="GeoAPI">class-index.properties</code>"</i>)) {
    isoToGeoAPI.load(in);
}
String isoName = <i>"<code class="OGC">CI_Citation</code>"</i>;
String geoName = getProperty(isoName);
Class&lt;?&gt;  type = Class.forName(geoName);
System.out.println(<i>"The GeoAPI interface for <abbr>ISO</abbr> type "</i> + isoName + <i>" is "</i> + type);</pre>

<p>
The <code class="SIS">org.apache.sis.util.iso.Types</code> convenience method for above task is
<code class="SIS">forStandardName(String)</code>.
</p>



<h2 id="ServiceLoader"><span class="section-number">7.2.</span> Fetching implementations of GeoAPI Interfaces</h2>
<p>
GeoAPI defines factories (<code class="GeoAPI">Factory</code>) that can create implementations of interfaces.
For example, <code class="GeoAPI">DatumFactory</code> provides methods that can create instances which implement interfaces of the
<code class="GeoAPI">org.opengis.referencing.datum</code> package.
A <code class="GeoAPI">Factory</code> must be implemented by a geospatial library,
and declared as a <i>service</i> as defined by the <code>java.util.ServiceLoader</code> class.
The <code>ServiceLoader</code> javadoc explains this procedure.
In brief, the library must create a file in the <code>META-INF/services/</code> directory,
with a name corresponding to the complete name of an interface in the factory
(in the preceding example, <code class="GeoAPI">org.opengis.referencing.datum.DatumFactory</code>).
On one line, this text file must include the complete name of the class that implements this interface.
This class may be hidden from users, as they do not need to know of its existence.
</p>
<p>
If the library has correctly declared its factories as services,
users may import them by using <code>ServiceLoader</code>, as in the example below.
This example only takes the first factory located; if there is more than one factory -
for example when multiple libraries coexist — then the choice is left to the user.
</p>

<pre><b>import</b> org.opengis.referencing.<code class="GeoAPI">GeodeticDatum</code>;
<b>import</b> org.opengis.referencing.<code class="GeoAPI">DatumFactory</code>;
<b>import</b> java.util.ServiceLoader;

<b>public</b> <b>class</b> MyApplication {
    <b>public</b> <b>void</b> createMyDatum() {
        ServiceLoader  loader = ServiceLoader.load(<code class="GeoAPI">DatumFactory</code>.<b>class</b>);
        <code class="GeoAPI">DatumFactory</code>  factory = loader.iterator().next();
        <code class="GeoAPI">GeodeticDatum</code> myDatum = factory.<code class="GeoAPI">createGeodeticDatum</code>(…);
    }
}</pre>



<h3 id="GeoAPI-simple"><span class="section-number">7.2.1.</span> Defining Custom Implementations</h3>
<p>
Implementing GeoAPI oneself in order to meet very specific needs is not difficult.
A developer might concentrate on a handful of interfaces among the hundreds available,
while keeping other interfaces as extension points to eventually implement as needed.
</p>
<p>
The conceptual model that the interfaces represent is complex. But this complexity may be reduced by combining certain interfaces.
For example, many libraries, even well-known ones, do not distinguish between a <cite>Coordinate System</cite> (<abbr>CS</abbr>)
and a <cite>Coordinate <u>Reference</u> System</cite> (<abbr title="Coordinate Reference System">CRS</abbr>).
A developer that also wishes not to make this distinction may implement these two interfaces with the same class.
The resulting implementation may have a simpler class hierarchy than that of GeoAPI interfaces.
The <code class="GeoAPI">geoapi-examples</code> module, discussed later, provides such combinations.
The following table lists a few possible combinations:
</p>
<table>
<tr>
<th>Main Interface</th>
<th>Auxiliary Interface</th>
<th>Use</th>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateReferenceSystem</code></td>
<td><code class="GeoAPI">CoordinateSystem</code></td>
<td>Description of a spatial reference system (<abbr>CRS</abbr>).</td>
</tr>
<tr>
<td><code class="GeoAPI">GeodeticDatum</code></td>
<td><code class="GeoAPI">Ellipsoid</code></td>
<td>Description of the geodetic datum.</td>
</tr>
<tr>
<td><code class="GeoAPI">CoordinateOperation</code></td>
<td><code class="GeoAPI">MathTransform</code></td>
<td>Coordinate transformation operations.</td>
</tr>
<tr>
<td><code class="GeoAPI">IdentifiedObject</code></td>
<td><code class="GeoAPI">ReferenceIdentifier</code></td>
<td>An objet (usually a <abbr>CRS</abbr>) that we can identify by a code.</td>
</tr>
<tr>
<td><code class="GeoAPI">Citation</code></td>
<td><code class="GeoAPI">InternationalString</code></td>
<td>Bibliographic reference consisting of a simple title.</td>
</tr>
<tr>
<td><code class="GeoAPI">GeographicBoundingBox</code></td>
<td><code class="GeoAPI">Extent</code></td>
<td>Spatial area in degrees of longitude and latitude.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValue</code></td>
<td><code class="GeoAPI">ParameterDescriptor</code></td>
<td>Description of a parameter (name, type) associated with its value.</td>
</tr>
<tr>
<td><code class="GeoAPI">ParameterValueGroup</code></td>
<td><code class="GeoAPI">ParameterDescriptorGroup</code></td>
<td>Description of a set of parameters associated with their values.</td>
</tr>
</table>



<p id="GeoAPI-examples">
The <code class="GeoAPI">geoapi-examples</code> module provides examples of simple implementations.
Many of these classes implement more than one interface at a time in order to provide a simpler conceptual model.
The <a href="http://www.geoapi.org/geoapi-examples/apidocs/overview-summary.html">javadoc for this module</a>
lists key packages and classes along with the combinations performed.
This module illustrates not only how GeoAPI might be implemented,
but also how the implementation might be tested using <code class="GeoAPI">geoapi-conformance</code>.
</p>
<p>
Although its primary goal is to serve as a source of inspiration for implementors,
<code class="GeoAPI">geoapi-examples</code> was also designed so as to be usable by applications with very simple needs.
As all the examples are in the public domain, developers are invited to freely adapt copies of these classes as necessary.
However, if changes are made outside the framework of the GeoAPI project,
fair use demands that modified copies be placed in a package with a different name than <code class="GeoAPI">org.opengis</code>.
</p>
<p>
For somewhat more involved needs, developers are invited to examine the
<code class="GeoAPI">geoapi-proj4</code> and <code class="GeoAPI">geoapi-netcdf</code> modules.
These two modules provide examples of adaptors that are allowed, via GeoAPI interfaces,
to use some of the features of external libraries (Proj.4 and <abbr title="Network Common Data Form">NetCDF</abbr>).
The advantage of using these interfaces is to provide a unified model to operate two very different <abbr title="Application Programming Interface">API</abbr>s,
while retaining the ability to switch easily to another library if desired.
</p>
</section>
<section>
<header>
<h1 id="tests"><span class="section-number">8.</span> Test suites</h1>
<nav><div class="chapter-links"><div class="previous-chapter">⬅ <a href="#reduce-direct-dependency">Previous chapter</a></div></div></nav>
</header>
<nav>In this chapter:<ul class="toc">
<li><a href="#GeoAPI-validators">Instance Validations</a></li>
<li><a href="#GeoAPI-tests">Executing Pre-defined Tests</a></li></ul></nav>
<p>
In addition to its own tests, Apache SIS uses tests defined by GeoAPI.
One advantages is that those tests provide an external source for the definition of expected results
(for example the numerical values of coordinates obtained after a map projection).
Such external source reduce the risk that some tests are actually anti-regression tests
instead of correctness tests.
Those tests can also be used by projects other than Apache SIS.
</p>
<p id="GeoAPI-conformance">
The <code class="GeoAPI">geoapi-conformance</code> module provides <i>validators</i>, a JUnit <i>test suite</i>, and <i>report generators</i>
in the form of <abbr title="Hypertext Markup Language">HTML</abbr> pages.
This module may be used with any GeoAPI implementation.
For developers of a geospatial library, it offers the following advantages:
</p>
<ul>
<li>Reduces the tedious task of writing tests by using existing tests.</li>
<li>Increases confidence in the validity of tests,
since <code class="GeoAPI">geoapi-conformance</code> has its own test suite and is applied to other implementations.</li>
<li>Facilitates comparison with other implementations.</li>
</ul>



<h2 id="GeoAPI-validators"><span class="section-number">8.1.</span> Instance Validations</h2>
<p>
GeoAPI can validate an instance of its interfaces by checking that certain constraints are observed.
Many constraints can not be expressed in the method signature. Those constraints
are usually described textually in the abstract specifications or in the javadoc.
</p>
<div class="example"><p><b>Example:</b>
A coordinate conversion or transformation (<code class="OGC">CC_CoordinateOperation</code>) may require a sequence of several steps.
In such a sequence of operations (<code class="OGC">CC_ConcatenatedOperation</code>), for each step (<code class="OGC">CC_SingleOperation</code>)
the number of output dimensions must equal the number of input dimensions in the next operation.
Expressed in Java, this constraint stipulates that for the entire index 0 &lt; <var>i</var> &lt; <var>n</var> where <var>n</var>
is the number of operations, we have <code>coordOperation[i].targetDimensions == coordOperation[i-1].sourceDimensions</code>.
</p></div>

<p>
The easiest way to perform these verifications is to call the static methods <code class="GeoAPI">validate(…)</code>
of the <code class="GeoAPI">org.opengis.test.Validators</code> class.
As all of <code class="GeoAPI">Validators</code> methods bear the same name, it is enough to write “<code>validate(<var>value</var>)</code>”
and then let the compiler choose the most appropriate method for the type of object given in argument.
If the object type is not known at the time of compilation,
the <code class="GeoAPI">dispatch(Object)</code> method can be invoked for redirecting the work to the most appropriate <code class="GeoAPI">validate(…)</code> method.
</p>
<p>
All <code class="GeoAPI">validate(…)</code> functions follow a chain of dependencies,
meaning that they will also validate each component of the object to be validated.
For example, the validation of a <code class="GeoAPI">GeographicCRS</code> implies the validation of its component
<code class="GeoAPI">GeodeticDatum</code>, which itself implies the validation of its component <code class="GeoAPI">Ellipsoid</code>, and so on.
Thus it is unnecessary to validate the components explicitely, unless the developer wishes to isolate the test for a particular item known to cause problems.
</p>
<p>
By default, validations are as strict as possible. It is always possible to relax certain rules.
The most common is to tolerate the absence of attributes that would normally be mandatory.
This rule and a few others may be modified globally for all tests executed by the currently running <abbr title="Java Virtual Machine">JVM</abbr>,
as in the following example:
</p>

<pre><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">Validators</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <code class="comment">/*
     * Tolerate the absence of mandatory attributes in metadata and citation packages.
     * This modification applies to all tests executed by the currently running <abbr>JVM</abbr>.
     * If there are multiple test classes, this initialization may be performed
     * in a parent class to all test classes.
     */</code>
    <b>static</b> {
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.metadata.requireMandatoryAttributes</code> = <b>false</b>;
        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">DEFAULT.citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Create an object here.
</code>        <code class="GeoAPI">Validators</code>.<code class="GeoAPI">validate</code>(myObject);
    }
}</pre>

<p>
Rules may also be modified for a particular test suite without affecting the default configuration of the standard <abbr>JVM</abbr>.
This approach requires the creation of a new instance of the validator that we wish to modify the configuration.
</p>

<pre><b>import</b> org.opengis.metadata.<code class="GeoAPI">Metadata</code>;
<b>import</b> org.opengis.test.<code class="GeoAPI">ValidatorContainer</code>;
<b>import</b> org.junit.Test;

<b>public</b> <b>class</b> MyTest {
    <b>private</b> <b>final</b> <code class="GeoAPI">ValidatorContainer</code> validators;

    <b>public</b> MyTest() {
        validators = <b>new</b> <code class="GeoAPI">ValidatorContainer</code>();
        validators.<code class="GeoAPI">metadata.requireMandatoryAttributes</code> = <b>false</b>;
        validators.<code class="GeoAPI">citation.requireMandatoryAttributes</code> = <b>false</b>;
    }

    @Test
    <b>public</b> <b>void</b> testMyMetadata() {
        <code class="GeoAPI">Metadata</code> myObject = …; <code class="comment">// Create an object here.
</code>        validators.<code class="GeoAPI">validate</code>(myObject);
    }
}</pre>



<h2 id="GeoAPI-tests"><span class="section-number">8.2.</span> Executing Pre-defined Tests</h2>
<p>
JUnit tests are defined in the <code class="GeoAPI">org.opengis.test</code> sub-packages.
All test classes bear a name ending in "<code>Test</code>".
GeoAPI also provides an <code class="GeoAPI">org.opengis.test.TestSuite</code> class including all test classes defined in the
<code class="GeoAPI">geoapi-conformance</code> module, but Apache <abbr title="Spatial Information System">SIS</abbr> does not use it.
Instead, Apache <abbr>SIS</abbr> inherits GeoAPI’s <code class="GeoAPI">*Test</code> classes on a case-by-case basis,
in the appropriate modules.
The example below gives an example of a customized GeoAPI test:
The <a href="http://www.geoapi.org/geoapi-conformance/apidocs/org/opengis/test/referencing/ParameterizedTransformTest.html">parent test javadoc</a>
documents the tests performed in detail.
In this example, only one test is modified and all the others are inherited as they are (it is not necessary to repeat them in the sub-class).
However, this example adds a supplemental verification, annotated with <code>@After</code>, which will be executed after each test.
</p>

<pre><b>import</b> org.junit.*;
<b>import</b> org.junit.runner.RunWith;
<b>import</b> org.junit.runners.JUnit4;
<b>import</b> org.opengis.test.referencing.<code class="GeoAPI">ParameterizedTransformTest</code>;
<b>import</b> <b>static</b> org.junit.Assert.*;

@RunWith(JUnit4.<b>class</b>)
<b>public</b> <b>class</b> MyTest <b>extends</b> <code class="GeoAPI">ParameterizedTransformTest</code> {
    <code class="comment">/**
     * Specify our own coordinate transformation factory for the GeoAPI tests.
     * GeoAPI will test the objects created by this factory.
     */</code>
    <b>public</b> MyTest() {
        <b>super</b>(<b>new</b> MyMathTransformFactory());
    }

    <code class="comment">/**
     * Changes the behaviour of a test. This example relaxes the requirements of this test a little,
     * by accepting errors of up to 10 centimetres, rather than the default value of 1 cm.
     * This change only applies to this method, and does not affect the other inherited tests.
     */</code>
    @Test
    @Override
    <b>public</b> <b>void</b> testLambertAzimuthalEqualArea() <b>throws</b> <code class="GeoAPI">FactoryException</code>, <code class="GeoAPI">TransformException</code> {
        <code class="GeoAPI">tolerance</code> = 0.1; <code class="comment">// 10 cm tolerance.
</code>        <b>super</b>.<code class="GeoAPI">testLambertAzimuthalEqualArea()</code>;
    }

    <code class="comment">/**
     * Supplemental verification performed after each test, inherited or not.
     * In this example, we are verifying that the transformation tested
     * works correctly in two-dimensional spaces.
     */</code>
    @After
    <b>public</b> <b>void</b> ensureAllTransformAreMath2D() {
        assertTrue(<code class="GeoAPI">transform</code> <b>instanceof</b> <code class="GeoAPI">MathTransform2D</code>);
    }
}</pre>
</section>
</main>
</body>
</html>