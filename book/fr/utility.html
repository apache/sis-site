<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>

<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
  <head>
    <title>Classes et méthodes utilitaires</title>
    <meta charset="UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../book.css"/>
  </head>
  <body>
    <header>
      <h1 id="Utilities">Classes et méthodes utilitaires</h1>
    </header>
    <p>
      Ce chapitre décrit des aspects de Apache <abbr>SIS</abbr> qui s’appliquent à l’ensemble de la bibliothèque.
      La plupart de ces utilitaires ne sont pas spécifiques aux systèmes d’information spatiales.
    </p>

    <h2 id="ComparisonMode">Modes de comparaisons des objets</h2>
    <p>
      Il existe différentes opinions sur la façon d’implémenter la méthode <code>Object.equals(Object)</code> du Java standard.
      Selon certains, il doit être possible de comparer différentes implémentations d’une même interface ou classe de base.
      Mais cette politique nécessite que chaque interface ou classe de base définisse entièrement dans sa Javadoc les critères ou calculs
      que doivent employer les méthodes <code>equals(Object)</code> et <code>hashCode()</code> dans toutes les implémentations.
      Cette approche est choisie notamment par <code>java.util.Collection</code> et ses interfaces filles.
      La transposition de cette approche aux centaines d’interfaces de GeoAPI serait toutefois une entreprise ardue,
      qui risquerait d’être assez peu suivie par les diverses implémentations.
      En outre, elle se fait au détriment de la possibilité de prendre en compte des attributs supplémentaires dans les interfaces filles
      si cette possibilité n’a pas été spécifiée dans l’interface parente.
      Cette contrainte découle des points suivants du contrat des méthodes <code>equals(Object)</code> et <code>hashCode()</code>:
    </p>
    <ul>
      <li><code>A.equals(B)</code> implique <code>B.equals(A)</code> (symétrie);</li>
      <li><code>A.equals(B)</code> et <code>B.equals(C)</code> implique <code>A.equals(C)</code> (transitivité);</li>
      <li><code>A.equals(B)</code> implique <code>A.hashCode() == B.hashCode()</code>.</li>
    </ul>
    <p>
      Par exemple ces trois contraintes sont violées si <var>A</var> (et éventuellement <var>C</var>)
      peuvent contenir des attributs que <var>B</var> ignore.
      Pour contourner cette difficulté, une approche alternative consiste à exiger que les objets comparés par la méthode
      <code>Object.equals(Object)</code> soient exactement de la même classe, c’est-à-dire que <code>A.getClass() == B.getClass()</code>.
      Cette approche est parfois considérée contraire aux principes de la programmation orientée objets.
      Dans la pratique, pour des applications relativement complexes, l’importance accordée à ces principes dépend du contexte dans lequel les objets sont comparés:
      si les objets sont ajoutés à un <code>HashSet</code> ou utilisés comme clés dans un <code>HashMap</code>,
      alors nous avons besoin d’un strict respect du contrat de <code>equals(Object)</code> et <code>hashCode()</code>.
      Mais si le développeur compare les objets lui-même, par exemple pour vérifier si des informations qui l’intéresse ont changées,
      alors les contraintes de symétrie, transitivité ou de cohérence avec les valeurs de hachages peuvent ne pas être pertinentes pour lui.
      Des comparaisons plus permissives peuvent être souhaitables, allant parfois jusqu’à tolérer de légers écarts dans les valeurs numériques.
    </p>
    <p>
      Afin de donner une certaine flexibilité aux développeurs, un grand nombre de classes de la bibliothèque <abbr>SIS</abbr>
      implémentent l’interface <code>org.apache.sis.util.LenientComparable</code>, qui défini une méthode <code class="SIS">equals(Object, ComparisonMode)</code>.
      Les principaux modes de comparaisons sont:
    </p>
    <ul>
      <li><p>
        <b><code class="SIS">STRICT</code></b> — Les objets comparés doivent être de la même classe
        et tous leurs attributs strictement égaux, y compris d’éventuels attributs publics propres à l’implémentation.
      </p></li>
      <li><p>
        <b><code class="SIS">BY_CONTRACT</code></b> — Les objets comparés doivent implémenter la même interface de GeoAPI (ou tout autre standard),
        mais n’ont pas besoin d’être de la même classe d’implémentation. Seuls les attributs définis dans l’interface sont comparés;
        tout autres attributs propres à l’implémentation — même s’ils sont publics — sont ignorés.
      </p></li>
      <li><p>
        <b><code class="SIS">IGNORE_METADATA</code></b> — Comme <code class="SIS">BY_CONTRACT</code>,
        mais ne compare que les attributs qui influencent les opérations (calculs numériques ou autre) effectuées par l’objet.
        Par exemple dans un référentiel géodésique, la longitude (par rapport à Greenwich) du méridien d’origine sera pris en compte
        alors que le nom de ce méridien sera ignoré.
      </p></li>
      <li><p>
        <b><code class="SIS">APPROXIMATIVE</code></b> — Comme <code class="SIS">IGNORE_METADATA</code>,
        mais tolère de légères différences dans les valeurs numériques.
      </p></li>
    </ul>
    <p>
      Le mode par défaut, utilisé par les toutes les méthodes <code>equals(Object)</code> de <abbr>SIS</abbr>,
      est <code class="SIS">STRICT</code>. Ce mode est choisi pour une utilisation sécuritaire — notamment avec <code>HashMap</code> —
      sans nécessiter de définitions rigoureuses des méthodes <code>equals(Object)</code> et <code>hashCode()</code> dans toutes les interfaces.
      Avec ce mode, l’ordre des objets (<code>A.equals(B)</code> ou <code>B.equals(A)</code>) n’a pas d’importance.
      C’est toutefois le seul mode à offrir cette garantie.
      Dans l’expression <code>A.equals(B)</code>, le mode <code class="SIS">BY_CONTRACT</code>
      (et donc par extension tous les autres modes qui en dépendent) ne comparera que les propriétés connues de <code>A</code>,
      sans se soucier de savoir si <code>B</code> en connaît davantage.
    </p>



    <h2 id="ObjectConverters">Object converters</h2>
    <p>
      Il est parfois nécessaire de convertir une instance d’un type source <code>&lt;S&gt;</code> vers un type destination <code>&lt;T&gt;</code>
      alors que ces types ne sont pas connus au moment de la compilation.
      Divers projets (Apache Common Convert, Spring, <i>etc.</i>)
      ont créé leur propres interfaces pour effectuer des conversions d’objets entre des types connus seulement au moment de l’exécution.
      Les détails varient, mais ces interfaces ressemblent typiquement à l’interface suivante:
    </p>
    <pre>interface ObjectConverter&lt;S,T&gt; {   // Certains projets utilisent seulement "Converter" comme nom d’interface.
    T apply(S object);             // Un autre nom de méthode souvent utilisé par les autres projets est "convert".
}</pre>
    <p>
      Comme d’autres projets, Apache <abbr>SIS</abbr> définit sa propre interface <code>ObjectConverter</code>.
      La principale différence entre l’interface de <abbr>SIS</abbr> est celle que l’on retrouve dans d’autres projets
      est que <abbr>SIS</abbr> fournit des informations à propos de certaines propriétés mathématiques des convertisseurs.
      Un convertisseur de Apache <abbr>SIS</abbr> peut avoir aucune, une ou plusieurs des propriétés suivantes:
    </p>
    <dl>
      <dt><dfn>Injective</dfn></dt>
      <dd>Une fonction est injective si aucune paire de valeurs de <var>S</var> ne peut produire la même valeur de <var>T</var>.
        <div class="example"><p><b>Exemple:</b>
          la conversion <code>Integer</code> → <code>String</code> effectuée par <code>Integer.toString()</code>
          est une fonction <cite>injective</cite> car si deux valeurs de type <code>Integer</code> ne sont pas égales,
          alors il est garanti que leurs conversions produiront différentes valeurs de <code>String</code>.
          En revanche la conversion <code>String</code> → <code>Integer</code> effectuée par <code>Integer.valueOf(String)</code>
          n’est <strong>pas</strong> une fonction injective
          parce que plusieurs valeurs distinctes de type <code>String</code> peuvent être converties vers la même valeur de type <code>Integer</code>.
          Par exemple les conversions des chaînes de caractères "42", "+42" et "0042" donnent toutes la même valeur entière 42.
        </p></div>
      </dd>

      <dt><dfn>Surjective</dfn></dt>
      <dd>Une fonction est surjective si chaque valeur de <var>T</var> peut être produite à partir d’au moins une valeur de <var>S</var>.
        <div class="example"><p><b>Exemple:</b>
          la conversion <code>String</code> → <code>Integer</code> effectuée par <code>Integer.valueOf(String)</code>
          est une fonction <cite>surjective</cite> car chaque valeur de type <code>Integer</code> peut être produite
          à partir d’un moins une valeur de <code>String</code>.
          En revanche la conversion <code>Integer</code> → <code>String</code> effectuée par <code>Integer.toString()</code>
          n’est <strong>pas</strong> une fonction surjective parce qu’elle ne peut pas produire toutes les valeurs possibles de type <code>String</code>.
          Par exemple il n’y a aucun moyen de produire la valeur "ABC" avec la méthode <code>Integer.toString()</code>.
        </p></div>
      </dd>

      <dt><dfn>Bijective</dfn></dt>
      <dd>Une fonction est bijective s’il y a une relation de un-à-un entre les valeurs de <var>S</var> et de <var>T</var>.
        <div class="example"><p><b>Note:</b>
          la propriété <cite>bijective</cite> est définie ici pour des raisons de clarté,
          mais en fait n’a pas d’item explicite dans l’énumération <code>FunctionProperty</code> de Apache <abbr>SIS</abbr>.
          Ce n’est pas nécessaire puisqu’une fonction qui est à la fois <cite>injective</cite> et <cite>surjective</cite>
          est nécessairement bijective.
        </p></div>
      </dd>

      <dt><dfn>Préservant l’ordre</dfn></dt>
      <dd>Une fonction préserve l’ordre si toute séquence de valeurs <var>S</var> croissantes correspond à une séquence de valeurs <var>T</var> croissantes.
        <div class="example"><p><b>Exemple:</b>
          la conversion du type <code>Integer</code> vers <code>Long</code> préserve l’ordre naturel des éléments.
          Toutefois la conversion du type <code>Integer</code> vers <code>String</code> ne préserve <strong>pas</strong> l’ordre naturel,
          parce que des séquences des nombres entiers croissants ont un ordre différents
          lorsque les chaînes de caractères sont classées par ordre lexicographique.
          Par exemple 1, 2, 10 devient "1", "10", "2".
        </p></div>
      </dd>

      <dt><dfn>Renversant l’ordre</dfn></dt>
      <dd>Une fonction renverse l’ordre si toute séquence de valeurs <var>S</var> croissantes correspond à une séquence de valeurs <var>T</var> décroissantes.
        <div class="example"><p><b>Exemple:</b>
          une conversion qui inverse le signe des nombres.
        </p></div>
      </dd>
    </dl>
    <p>
      Ces informations peuvent sembler inutiles lorsque l’on convertit des valeurs sans tenir compte du contexte où elles apparaissent.
      Mais lorsque la valeur à convertir fait parti d’un objet plus gros, alors ces informations peuvent impacter la façon dont la valeur convertie sera utilisée.
      Par exemple la conversion d’une plage de valeurs représentée par [<var>min</var> … <var>max</var>] est directe lorsque la fonction de conversion préserve l’ordre.
      Mais si la fonction de conversion renverse l’ordre, alors les valeurs minimale et maximale doivent être interchangées.
      Par exemple si la fonction de conversion inverse le signe des valeurs, alors la plage convertie sera [-<var>max</var> … -<var>min</var>].
      Si la fonction de conversion ne préserve ni ne renverse l’ordre, alors la plage de valeurs ne peut pas être convertie du tout
      (parce qu’elle ne contiendrait plus le même ensemble de valeurs) même si les valeurs individuelles auraient pu être converties.
    </p>



    <h2 id="Internationalization">Internationalisation</h2>
    <p>
      Dans une architecture où un programme exécuté sur un serveur fournit ses données à plusieurs clients,
      les conventions locales du serveur ne sont pas nécessairement les mêmes que celles des clients.
      Les conventions peuvent différer par la langue, mais aussi par la façon d’écrire les valeurs numériques
      (même entre deux pays parlant la même langue) ainsi que par le fuseau horaire.
      Pour produire des messages conformes aux conventions du client, <abbr>SIS</abbr> emploie
      deux approches qui diffèrent par leur niveau de granularité: au niveau des messages eux-mêmes,
      ou au niveau des objets produisant les messages. L’approche utilisée détermine aussi s’il est
      possible de partager une même instance d’un objet pour toutes les langues.
    </p>

    <h3 id="LocalizedString">Chaînes de caractères distinctes pour chaque conventions locales</h3>
    <p>
      Certaines classes ne sont conçues que pour fonctionner selon une convention locale à la fois.
      C’est évidemment le cas des implémentations standards de <code>java.text.Format</code>,
      puisqu’elles sont entièrement dédiées au travail d’internationalisation.
      Mais c’est aussi le cas de d’autres classes moins évidentes comme
      <code>javax.imageio.ImageReader</code>/<code>ImageWriter</code> ainsi que les sous-classes de <code>Exception</code>.
      Lorsque une de ces classes est implémentée par <abbr>SIS</abbr>,
      nous l’identifions en implémentant l’interface <code>org.apache.sis.util.Localized</code>.
      La méthode <code class="SIS">getLocale()</code> de cette interface permet alors de déterminer
      selon quelles conventions locales l’instance produira ses messages.
    </p>
    <p>
      Certaines sous-classes de <code>Exception</code> définies par <abbr>SIS</abbr> implémentent aussi l’interface <code>Localized</code>.
      Pour ces exceptions, le message d’erreur peut être produit selon deux conventions locales selon qu’il s’adresse à l’administrateur du système ou au client:
      <code>getMessage()</code> retourne le message de l’exception selon les conventions par défaut du système, alors que
      <code>getLocalizedMessage()</code> retourne le message de l’exception selon les conventions locales spécifiées par <code class="SIS">getLocale()</code>.
      Ce <code>Locale</code> sera lui-même déterminé par l’objet <code>Localized</code> qui a lancé l’exception.
    </p>
    <div class="example"><p><b>Exemple:</b>
      Supposons que dans un environnement où la langue par défaut serait l’anglais,
      un objet <code>AngleFormat</code> est construit pour lire des angles selon les conventions françaises.
      Si une <code>ParseException</code> est lancée lors de l’utilisation de ce formateur,
      alors <code>getMessage()</code> retournera le message d’erreur en anglais
      tandis que <code>getLocalizedMessage()</code> retournera le message d’erreur en français.
    </p></div>
    <p>
      Les exceptions définies par <abbr>SIS</abbr> n’implémentent pas toutes l’interface <code>Localized</code>.
      Seules celles dont le message est le plus susceptible d’être montré à l’utilisateur sont ainsi localisées.
      Les <code>ParseException</code> sont de bonnes candidates puisqu’elles surviennent souvent
      suite à une saisie incorrecte du client. En revanche les <code>NullPointerException</code>
      sont généralement la conséquence d’une erreur de programmation;
      elles peuvent être localisées dans la langue par défaut du système, mais ça sera généralement tout.
    </p>
    <p>
      La classe utilitaire <code>org.apache.sis.util.Exceptions</code> fournit
      des méthodes de commodité pour obtenir des messages selon des conventions locales spécifiées
      lorsque cette information est disponible.
    </p>



    <h3 id="InternationalString">Instance unique pour toutes les conventions locales</h3>
    <p>
      Les <abbr>API</abbr> définit par <abbr>SIS</abbr> ou hérités de GeoAPI privilégient plutôt l’utilisation du type
      <code>InternationalString</code> là où une valeur de type <code>String</code> serait susceptible d’être localisée.
      Cette approche permet de différer le processus d’internationalisation au moment d’obtenir
      une chaîne de caractères plutôt qu’au moment de construire l’objet qui les contient.
      C’est particulièrement utile pour les classes immutables qui serviront à créer des instances uniques
      indépendamment des conventions locales.
    </p>
    <div class="example"><p><b>Exemple:</b>
      Il existe dans <abbr>SIS</abbr> une seule instance de type
      <code>OperationMethod</code> représentant la projection de Mercator, quelle que soit la langue du client.
      Mais sa méthode <code class="GeoAPI">getName()</code> fournit (indirectement)
      une instance de <code>InternationalString</code> telle que
      <code>toString(Locale.ENGLISH)</code> retourne <cite>Mercator Projection</cite>
      alors que <code>toString(Locale.FRENCH)</code> retourne <cite>Projection de Mercator</cite>.
    </p></div>
    <p>
      En définissant des objets spatiaux indépendemment des conventions locales, on réduit les risques de sur-coûts de calculs.
      Par exemple il est plus facile de détecter que deux cartes emploient la même projection cartographique si cette dernière
      est représentée par la même instance de <code>CoordinateOperation</code>, même si la projection
      porte différents noms selon les pays. En outre, certain types de <code>CoordinateOperation</code>
      peuvent nécessiter des grilles de transformation de coordonnées, ce qui accroît l’intérêt de partager une instance unique
      pour des raisons d’économie de mémoire.
    </p>



    <h3 id="Locale.ROOT">Convention <code>Locale.ROOT</code></h3>
    <p>
      Toutes les méthodes <abbr>SIS</abbr> recevant ou retournant une valeur de type <code>Locale</code>
      acceptent la valeur <code>Locale.ROOT</code>. Cette valeur est interprétée comme signifiant de ne pas localiser le texte.
      La notion de <cite>texte non-localisé</cite> est un peu fausse, puisqu’il faut bien choisir une convention de format.
      Mais cette convention, bien que très proche de l’anglais, sera généralement légèrement différente.
      Par exemple:
    </p>
    <ul>
      <li>
        Les identifiants sont écrits tels qu’ils apparaissent dans les diagrammes <abbr>UML</abbr>,
        par exemple <cite>blurredImage</cite> au lieu de <cite>Blurred image</cite>.
      </li>
      <li>
        Les dates sont écrites selon le format <abbr>ISO</abbr> 8601,
        qui ne correspond pas aux conventions anglaises.
      </li>
      <li>
        Les nombres sont écrits à l’aide de leurs méthodes <code>toString()</code> plutôt qu’à l’aide d’un <code>java.text.NumberFormat</code>.
        Il en résulte des différences dans le nombre de chiffres significatifs, l’utilisation de la notation exponentielle et l’absence de séparateur des milliers.
      </li>
    </ul>



    <h3 id="UnicodePoint">Traitement des caractères</h3>
    <p>
      Les chaînes de caractères en Java utilisent l’encodage UTF-16. Il existe une correspondance directe
      entre les valeurs de type <code>char</code> et la très grande majorité des caractères, ce
      qui facilite l’utilisation des chaînes lorsque ces caractères suffisent.
      Mais certains caractères Unicode ne sont pas représentables par un seul <code>char</code>.
      Ces <i>caractères supplémentaires</i> comprennent certains idéogrammes,
      mais aussi des symboles routiers et géographiques dans la plage 1F680 à 1F700.
      Le support de ces caractères supplémentaires nécessite des itérations un peu plus complexes
      que le cas classique où l’on supposait une correspondance directe.
      Ainsi, au lieu de la boucle de gauche ci-dessous, les applications internationales devraient
      généralement utiliser la boucle de droite:
    </p>

    <table class="hidden">
      <tr>
        <th>Boucle à éviter</th>
        <th>Boucle recommandée</th>
        <th>Exemples de caractères supplémentaires</th>
      </tr>
      <tr>
        <td>
<pre style="margin-top: 6pt">for (int i=0; i&lt;string.length(); i++) {
    char c = string.charAt(i);
    if (Character.isWhitespace(c)) {
        // Un espace blanc a été trouvé.
    }
}</pre>
        </td>
        <td>
<pre style="margin-top: 6pt">for (int i=0; i&lt;string.length();) {
    int c = string.codePointAt(i);
    if (Character.isWhitespace(c)) {
        // Un espace blanc a été trouvé.
    }
    i += Character.charCount(c);
}</pre>
        </td>
        <td>
          <center>(l’affichage dépend des capacités du navigateur)</center>
          <p style="font-size: 40px">&#x1F689; &#x1F6A5; &#x1F6A7; &#x1F6AB;
            &#x1F6AF; &#x1F6B8; &#x1F6BA; &#x1F6B9; &#x1F6C4; &#x1F6AD;</p>
        </td>
      </tr>
    </table>

    <p>
      <abbr>SIS</abbr> supporte les caractères supplémentaires en utilisant la boucle de droite lorsque nécessaire.
      Mais la boucle de gauche reste occasionnellement utilisée lorsqu’il est connu que les caractères recherchés ne sont
      pas des caractères supplémentaires, même si la chaîne dans laquelle on fait la recherche peut en contenir.
    </p>



    <h4 id="Whitespaces">Interprétation des espaces blancs</h4>
    <p>
      Le Java standard fournit deux méthodes pour déterminer si un caractères est un espace blanc:
      <code>Character.isWhitespace(…)</code> et <code>Character.isSpaceChar(…)</code>.
      Ces deux méthodes diffèrent dans leurs interprétations des espaces insécables, des tabulations et des retours à la ligne.
      La première méthode est conforme à l’interprétation couramment utilisée dans des langages telles que le Java, C/C++ et <abbr>XML</abbr>,
      qui considère les tabulations et retours à la ligne comme des espaces blancs,
      alors que les espaces insécables sont interprétés comme des caractères non-blanc.
      La seconde méthode — strictement conforme à la définition Unicode — fait l’interprétation inverse.
    </p>
    <p>
      <abbr>SIS</abbr> emploie ces deux méthodes dans des contextes différents.
      <code>isWhitespace(…)</code> est utilisée pour <em>séparer</em> les éléments d’une liste (nombres, dates, mots, <i>etc.</i>),
      tandis que <code>isSpaceChar(…)</code> est utilisée pour ignorer les espaces blancs <em>à l’intérieur</em> d’un seul élément.
    </p>
    <div class="example"><p><b>Exemple:</b>
      Supposons une liste de nombres représentés selon les conventions françaises.
      Chaque nombre peut contenir des <em>espace insécables</em> comme séparateurs des milliers,
      tandis que les différents nombres de la liste peuvent être séparés par des espaces ordinaires, des tabulations ou des retours à la ligne.
      Pendant l’analyse d’un nombre, on veut considérer les espaces insécables comme faisant partie du nombre,
      alors qu’une tabulation ou un retour à la ligne indique très probablement une séparation entre ce nombre et le nombre suivant.
      On utilisera donc <code>isSpaceChar(…)</code>.
      Inversement, lors de la séparation des nombres de la liste, on veut considérer les tabulations et
      les retours à la ligne comme des séparateurs mais pas les espaces insécables.
      On utilisera donc <code>isWhitespace(…)</code>.
      Le rôle des espaces ordinaires, qui pourraient s’appliquer aux deux cas, doit être décidé en amont.
    </p></div>
    <p>
      Dans la pratique, cette distinction se traduit pas une utilisation de <code>isSpaceChar(…)</code>
      dans les implémentations de <code>java.text.Format</code>,
      et une utilisation de <code>isWhitespace(…)</code> dans pratiquement tout le reste
      de la bibliothèque <abbr>SIS</abbr>.
    </p>
  </body>
</html>
